<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOTA GoShimmer</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="goshimmer.html"><strong aria-hidden="true">1.</strong> GoShimmer</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">2.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/setup.html"><strong aria-hidden="true">3.1.</strong> Set up a node</a></li><li class="chapter-item expanded "><a href="tutorials/request_funds.html"><strong aria-hidden="true">3.2.</strong> Obtain tokens</a></li><li class="chapter-item expanded "><a href="tutorials/wallet.html"><strong aria-hidden="true">3.3.</strong> Wallet library</a></li><li class="chapter-item expanded "><a href="tutorials/dApp.html"><strong aria-hidden="true">3.4.</strong> Write a dApp</a></li><li class="chapter-item expanded "><a href="tutorials/manual_peering.html"><strong aria-hidden="true">3.5.</strong> Manual peering</a></li><li class="chapter-item expanded "><a href="tutorials/static_identity.html"><strong aria-hidden="true">3.6.</strong> Create a static identity</a></li><li class="chapter-item expanded "><a href="tutorials/custom_dRNG.html"><strong aria-hidden="true">3.7.</strong> Set up a custom dRNG committee</a></li><li class="chapter-item expanded "><a href="tutorials/monitoring.html"><strong aria-hidden="true">3.8.</strong> Set up the Monitoring Dashboard</a></li><li class="chapter-item expanded "><a href="tutorials/send_transaction.html"><strong aria-hidden="true">3.9.</strong> How to create and send transactions</a></li></ol></li><li class="chapter-item expanded "><a href="implementation_design.html"><strong aria-hidden="true">4.</strong> Implementation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="implementation_design/event_driven_model.html"><strong aria-hidden="true">4.1.</strong> Event driven model</a></li><li class="chapter-item expanded "><a href="implementation_design/packages_plugins.html"><strong aria-hidden="true">4.2.</strong> Packages and plugins</a></li><li class="chapter-item expanded "><a href="implementation_design/plugin.html"><strong aria-hidden="true">4.3.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="implementation_design/configuration_parameters.html"><strong aria-hidden="true">4.4.</strong> Configuration parameters</a></li><li class="chapter-item expanded "><a href="implementation_design/object_storage.html"><strong aria-hidden="true">4.5.</strong> Object storage</a></li></ol></li><li class="chapter-item expanded "><a href="protocol_specification.html"><strong aria-hidden="true">5.</strong> Protocol specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol_specification/protocol.html"><strong aria-hidden="true">5.1.</strong> Protocol high level overview</a></li><li class="chapter-item expanded "><a href="protocol_specification/components.html"><strong aria-hidden="true">5.2.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol_specification/tangle.html"><strong aria-hidden="true">5.2.1.</strong> Tangle</a></li><li class="chapter-item expanded "><a href="protocol_specification/autopeering.html"><strong aria-hidden="true">5.2.2.</strong> Autopeering</a></li><li class="chapter-item expanded "><a href="protocol_specification/mana.html"><strong aria-hidden="true">5.2.3.</strong> Mana</a></li><li class="chapter-item expanded "><a href="protocol_specification/congestion_control.html"><strong aria-hidden="true">5.2.4.</strong> Congestion Control</a></li><li class="chapter-item expanded "><a href="protocol_specification/consensus_mechanism.html"><strong aria-hidden="true">5.2.5.</strong> Consensus mechanism</a></li><li class="chapter-item expanded "><a href="protocol_specification/ledgerstate.html"><strong aria-hidden="true">5.2.6.</strong> UTXO and Ledgerstate</a></li><li class="chapter-item expanded "><a href="protocol_specification/advanced_outputs.html"><strong aria-hidden="true">5.2.7.</strong> Advanced Outputs (Experimental)</a></li><li class="chapter-item expanded "><a href="protocol_specification/markers.html"><strong aria-hidden="true">5.2.8.</strong> Markers</a></li></ol></li><li class="chapter-item expanded "><a href="protocol_specification/glossary.html"><strong aria-hidden="true">5.3.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">6.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apis/api.html"><strong aria-hidden="true">6.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="apis/webAPI.html"><strong aria-hidden="true">6.2.</strong> WebAPI</a></li><li class="chapter-item expanded "><a href="apis/info.html"><strong aria-hidden="true">6.3.</strong> Node info</a></li><li class="chapter-item expanded "><a href="apis/autopeering.html"><strong aria-hidden="true">6.4.</strong> Autopeering</a></li><li class="chapter-item expanded "><a href="apis/manual_peering.html"><strong aria-hidden="true">6.5.</strong> Manual peering</a></li><li class="chapter-item expanded "><a href="apis/communication.html"><strong aria-hidden="true">6.6.</strong> Communication layer</a></li><li class="chapter-item expanded "><a href="apis/ledgerstate.html"><strong aria-hidden="true">6.7.</strong> Ledgerstate</a></li><li class="chapter-item expanded "><a href="apis/mana.html"><strong aria-hidden="true">6.8.</strong> Mana</a></li><li class="chapter-item expanded "><a href="apis/dRNG.html"><strong aria-hidden="true">6.9.</strong> dRNG</a></li><li class="chapter-item expanded "><a href="apis/snapshot.html"><strong aria-hidden="true">6.10.</strong> Snapshot</a></li><li class="chapter-item expanded "><a href="apis/faucet.html"><strong aria-hidden="true">6.11.</strong> Faucet</a></li><li class="chapter-item expanded "><a href="apis/spammer.html"><strong aria-hidden="true">6.12.</strong> Spammer</a></li><li class="chapter-item expanded "><a href="apis/tools.html"><strong aria-hidden="true">6.13.</strong> Tools</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/docker_private_network.html"><strong aria-hidden="true">7.1.</strong> Docker private network</a></li><li class="chapter-item expanded "><a href="tooling/integration_tests.html"><strong aria-hidden="true">7.2.</strong> Integration tests</a></li></ol></li><li class="chapter-item expanded "><a href="team_resources.html"><strong aria-hidden="true">8.</strong> Team Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="teamresources/release.html"><strong aria-hidden="true">8.1.</strong> How to do a release</a></li><li class="chapter-item expanded "><a href="teamresources/guidelines.html"><strong aria-hidden="true">8.2.</strong> Code Guidelines</a></li><li class="chapter-item expanded "><a href="teamresources/local_development.html"><strong aria-hidden="true">8.3.</strong> Local development</a></li><li class="chapter-item expanded "><a href="teamresources/analysis_dashboard.html"><strong aria-hidden="true">8.4.</strong> Modify the Analysis dashboard</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">IOTA GoShimmer</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/iotaledger/goshimmer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the GoShimmer docs!</p>
<p>GoShimmer is a prototype node software exploring the implementation of <a href="https://github.com/iotaledger/IOTA-2.0-Research-Specifications">IOTA 2.0</a>. This wiki helps the reader to understand the basic concepts and ideas behind the Coordicide and how its modules are implemented in GoShimmer.</p>
<p>Due to the prototypical nature of the project, things written today may not be reflecting how things are tomorrow. We seek to keep the docs as updated as possible, since it is also used as guide for our team. If you find any inconsistencies, feel free to contact us on Discord or better, <a href="https://github.com/iotaledger/goshimmer/issues/new/choose">create an issue on this repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h3 id="what-is-goshimmer"><a class="header" href="#what-is-goshimmer">What is GoShimmer?</a></h3>
<p>GoShimmer is a research and engineering project from the IOTA Foundation seeking to evaluate Coordicide concepts by implementing them in a node software.</p>
<h3 id="what-kind-of-confirmation-time-can-i-expect"><a class="header" href="#what-kind-of-confirmation-time-can-i-expect">What kind of confirmation time can I expect?</a></h3>
<p>Since non conflicting transactions aren't even voted up on, they materialize after 2x the average network delay parameter we set. This means that a transaction usually confirms within a time boundary of ~10 seconds.</p>
<h3 id="where-can-i-see-the-state-of-the-goshimmer-testnet"><a class="header" href="#where-can-i-see-the-state-of-the-goshimmer-testnet">Where can I see the state of the GoShimmer testnet?</a></h3>
<p>You can access the global analysis dashboard <a href="http://ressims.iota.cafe:28080/autopeering">here</a> showcasing the network graph and active ongoing votes on conflicts.</p>
<h3 id="how-much-tps-can-goshimmer-sustain"><a class="header" href="#how-much-tps-can-goshimmer-sustain">How much TPS can GoShimmer sustain?</a></h3>
<p>The transactions per second metric is irrelevant for the current development state of GoShimmer. We are evaluating components from Coordicide and aren't currently interested in squeezing out every little ounce of performance. Meaning, we value simplicity over optimization since the primary goal is to evaluate Coordicide components. Even if we would put out a TPS number, it would simply not reflect an actual metric in a finished production ready node software. </p>
<h3 id="how-is-spamming-prevented"><a class="header" href="#how-is-spamming-prevented">How is spamming prevented?</a></h3>
<p>The Coordicide lays out concepts for spam prevention through the means of rate control and such. However, in the current version, GoShimmer relies on PoW to prevent over saturation of the network. Usually doing the PoW for a message will take a couple of seconds on commodity hardware.</p>
<h3 id="what-happens-if-i-issue-a-double-spend"><a class="header" href="#what-happens-if-i-issue-a-double-spend">What happens if I issue a double spend?</a></h3>
<p>If you have funds and are simultaneously issuing transactions spending those, then with high certainty your transactions are going to be rejected by the network. This goes even so far, that your funds will be blocked indefinitely (this might change in the future). If you issue a transaction, await the average network delay and then issue the double spend, then the first issued transaction should usually become confirmed and the 2nd one rejected.</p>
<h3 id="whos-the-target-audience-for-operating-a-goshimmer-node"><a class="header" href="#whos-the-target-audience-for-operating-a-goshimmer-node">Who's the target audience for operating a GoShimmer node?</a></h3>
<p>We are mainly interested in individuals helping us out who have a strong IT background, since we simply lack time to help people with things like setting up their nodes, fixing their NAT configs, teaching them how to use Linux and so on. People interested in trying out the bleeding edge of IOTA development and providing meaningful feedback or problem reporting (in form of issues) are welcome. Again, our primary focus is on testing out Coordicide components rather than giving people of any knowledge-level the easiest way to operate a node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-goshimmer-node"><a class="header" href="#setting-up-a-goshimmer-node">Setting up a GoShimmer node</a></h1>
<p>This page describes how to setup your own GoShimmer node in the GoShimmer testnet with Docker.</p>
<blockquote>
<p>DISCLAIMER: <strong>Note that there will be breaking changes frequently (approx. bi-weekly) where the entire network needs to upgrade. If you don't have time to continuously monitor and upgrade your node, then running a GoShimmer node might not be for you.</strong>  We want to emphasize that running a GoShimmer node requires proper knowledge in Linux and IT related topics such as networking and so on. It is not meant as a node to be run by people with little experience in the mentioned fields. <strong>Do not plan to run any production level services on your node/network.</strong></p>
</blockquote>
<table><thead><tr><th align="left">Contents</th></tr></thead><tbody>
<tr><td align="left"><a href="tutorials/setup.html#why-you-should-run-a-node">Why you should run a node</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#running-the-goshimmer-node">Running the GoShimmer node</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></td></tr>
</tbody></table>
<h2 id="why-you-should-run-a-node"><a class="header" href="#why-you-should-run-a-node">Why you should run a node</a></h2>
<p>Running a node in the GoShimmer testnet helps us in the following ways:</p>
<ul>
<li>It increases the amount of nodes in the network and thus lets it form a more realistic network.</li>
<li>Your node will be configured to send debug log messages to a centralized logger from which we can assess and debug research questions and occurring problems.</li>
<li>Your node is configured to send metric data to a centralized analysis server where we store information such as resource consumption, traffic, FPC vote context processing and so on. This data helps us further fostering the development of GoShimmer and assessing network behavior.</li>
<li>If you expose your HTTP API port, you provide an entrypoint for other people to interact with the network.</li>
</ul>
<blockquote>
<p>Note that any metric data is anonymous.</p>
</blockquote>
<h2 id="installing-goshimmer-with-docker"><a class="header" href="#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></h2>
<h4 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h4>
<blockquote>
<p>Note that we do not provide a Docker image or binaries for ARM based systems such as Raspberry Pis.</p>
</blockquote>
<p>We recommend running GoShimmer on a x86 VPS with following minimum hardware specs:</p>
<ul>
<li>2 cores / 4 threads</li>
<li>4 GB of memory</li>
<li>40 GB of disk space</li>
</ul>
<p>A cheap <a href="https://www.hetzner.de/cloud">CX21 Hetzner instance</a> is thereby sufficient.</p>
<p>If you plan on running your GoShimmer node from home, please only do so if you know how to properly configure NAT on your router, as otherwise your node will not correctly participate in the network.</p>
<hr />
<blockquote>
<p>In the following sections we are going to use a CX21 Hetzner instance with Ubuntu 20.04 while being logged in as root</p>
</blockquote>
<p>Lets first upgrade the packages on our system:</p>
<pre><code>apt update &amp;&amp; apt dist-upgrade -y
</code></pre>
<h4 id="install-docker"><a class="header" href="#install-docker">Install Docker</a></h4>
<p>Install needed dependencies:</p>
<pre><code>apt-get install \
     apt-transport-https \
     ca-certificates \
     curl \
     gnupg-agent \
     software-properties-common
</code></pre>
<p>Add Docker’s official GPG key:</p>
<pre><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</code></pre>
<p>Verify that the GPG key matches:</p>
<pre><code>apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096 2017-02-22 [S]

</code></pre>
<p>Add the actual repository:</p>
<pre><code>add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
</code></pre>
<p>Update the package index:</p>
<pre><code>apt-get update
</code></pre>
<p>And finally, install docker:</p>
<pre><code>apt-get install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>On windows-subsystem for Linux (WSL2) it may be necessary to start docker seperately:</p>
<pre><code>/etc/init.d/docker start
</code></pre>
<p>Note, this may not work on WSL1.</p>
<p>Check whether docker is running by executing <code>docker ps</code>:</p>
<pre><code>docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre>
<h3 id="install-docker-compose"><a class="header" href="#install-docker-compose">Install Docker Compose</a></h3>
<p>Docker compose gives us the ability to define our services with <code>docker-compose.yml</code> files instead of having to define all container parameters directly on the CLI.</p>
<p>Download docker compose:</p>
<pre><code>curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre>
<p>Make it executable:</p>
<pre><code>chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>Check that docker compose works:</p>
<pre><code>docker-compose --version
docker-compose version 1.26.0, build d4451659
</code></pre>
<h3 id="define-the-docker-composeyml"><a class="header" href="#define-the-docker-composeyml">Define the docker-compose.yml</a></h3>
<p>First, lets create a user defined bridged network. Unlike the already existing <code>bridge</code> network, the user defined one will have container name DNS resolution for containers within that network. This is useful if later we want to setup additional containers which need to speak with the GoShimmer container.</p>
<pre><code>docker network create --driver=bridge shimmer
c726034d295c3df66803b92c71ca517a0cf0e3c65c1c6d84ee5fa34ae76cbcd4
</code></pre>
<p>Lets create a folder holding our <code>docker-compose.yml</code>:</p>
<pre><code>mkdir /opt/goshimmer
</code></pre>
<p>Lets create a folder holding our database:</p>
<pre><code>cd /opt/goshimmer
mkdir db
chmod 0777 db
</code></pre>
<p>Finally, lets create our <code>docker-compose.yml</code>:</p>
<pre><code>nano docker-compose.yml
</code></pre>
<p>and add following content:</p>
<pre><code class="language-yaml">version: '3.3'

networks:
  outside:
    external:
      name: shimmer

services:
  goshimmer:
    image: iotaledger/goshimmer:latest
    container_name: goshimmer
    hostname: goshimmer
    stop_grace_period: 2m
    volumes:
      - &quot;./db:/tmp/mainnetdb:rw&quot;   
      - &quot;/etc/localtime:/etc/localtime:ro&quot;
    ports:
      # Autopeering 
      - &quot;0.0.0.0:14626:14626/udp&quot;
      # Gossip
      - &quot;0.0.0.0:14666:14666/tcp&quot;
      # FPC
      - &quot;0.0.0.0:10895:10895/tcp&quot;
      # HTTP API
      - &quot;0.0.0.0:8080:8080/tcp&quot;
      # Dashboard
      - &quot;0.0.0.0:8081:8081/tcp&quot;
      # pprof profiling
      - &quot;0.0.0.0:6061:6061/tcp&quot;
    environment:
      - ANALYSIS_CLIENT_SERVERADDRESS=ressims.iota.cafe:21888
      - AUTOPEERING_PORT=14626
      - DASHBOARD_BINDADDRESS=0.0.0.0:8081
      - GOSSIP_PORT=14666
      - WEBAPI_BINDADDRESS=0.0.0.0:8080
      - PROFILING_BINDADDRESS=0.0.0.0:6061
      - NETWORKDELAY_ORIGINPUBLICKEY=9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd
      - FPC_BINDADDRESS=0.0.0.0:10895
      - PROMETHEUS_BINDADDRESS=0.0.0.0:9311
    command: &gt;
      --skip-config=true
      --autopeering.entryNodes=2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626,5EDH4uY78EA6wrBkHHAVBWBMDt7EcksRq6pjzipoW15B@entryshimmer.tanglebay.com:14646
      --node.disablePlugins=
      --node.enablePlugins=remotelog,networkdelay,spammer,prometheus
      --logger.level=info
      --logger.disableEvents=false
      --logger.remotelog.serverAddress=ressims.iota.cafe:5213
      --drng.pollen.instanceId=1
      --drng.pollen.threshold=3
      --drng.pollen.committeeMembers=AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG,FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z,GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P,4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7,64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga
      --drng.xteam.instanceId=1339
      --drng.xteam.threshold=4
      --drng.xteam.committeeMembers=GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo,68vNzBFE9HpmWLb2x4599AUUQNuimuhwn3XahTZZYUHt,Dc9n3JxYecaX3gpxVnWb4jS3KVz1K1SgSK1KpV1dzqT1,75g6r4tqGZhrgpDYZyZxVje1Qo54ezFYkCw94ELTLhPs,CN1XLXLHT9hv7fy3qNhpgNMD6uoHFkHtaNNKyNVCKybf,7SmttyqrKMkLo5NPYaiFoHs8LE6s7oCoWCQaZhui8m16,CypSmrHpTe3WQmCw54KP91F5gTmrQEL7EmTX38YStFXx
    networks:
      - outside
</code></pre>
<blockquote>
<p>If performance is a concern, you can also run your containers with <code>network_mode: &quot;host&quot;</code>, however, you must then adjust the hostnames in the configs for the corresponding containers and perhaps also create some iptable rules to block traffic from outside accessing your services directly.</p>
</blockquote>
<p>Note how we are setting up NATs for different ports:</p>
<table><thead><tr><th>Port</th><th>Functionality</th><th>Protocol</th></tr></thead><tbody>
<tr><td>14626</td><td>Autopeering</td><td>UDP</td></tr>
<tr><td>14666</td><td>Gossip</td><td>TCP</td></tr>
<tr><td>10895</td><td>FPC</td><td>TCP/HTTP</td></tr>
<tr><td>8080</td><td>HTTP API</td><td>TCP/HTTP</td></tr>
<tr><td>8081</td><td>Dashboard</td><td>TCP/HTTP</td></tr>
<tr><td>6061</td><td>pprof HTTP API</td><td>TCP/HTTP</td></tr>
</tbody></table>
<p>It is important that the ports are correctly mapped so that the node for example actively participates in FPC votes or can gain inbound neighbors.</p>
<blockquote>
<p>If the UDP NAT mapping is not configured correctly, GoShimmer will terminate with an error message stating to check the NAT configuration</p>
</blockquote>
<h2 id="running-the-goshimmer-node"><a class="header" href="#running-the-goshimmer-node">Running the GoShimmer node</a></h2>
<p>Within the <code>/opt/goshimmer</code> folder where the <code>docker-compose.yml</code> resides, simply execute:</p>
<pre><code>docker-compose up -d
Pulling goshimmer (iotaledger/goshimmer:0.2.0)...
...
</code></pre>
<p>to start the GoShimmer node.</p>
<p>You should see your container running now:</p>
<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                                                                    NAMES
687f52b78cb5        iotaledger/goshimmer:0.2.0       &quot;/run/goshimmer --sk…&quot;   19 seconds ago      Up 17 seconds       0.0.0.0:6061-&gt;6061/tcp, 0.0.0.0:8080-8081-&gt;8080-8081/tcp, 0.0.0.0:10895-&gt;10895/tcp, 0.0.0.0:14666-&gt;14666/tcp, 0.0.0.0:14626-&gt;14626/udp   goshimmer
</code></pre>
<p>You can follow the log output of the node via:</p>
<pre><code>docker logs -f --since=1m goshimmer
</code></pre>
<h3 id="syncing"><a class="header" href="#syncing">Syncing</a></h3>
<p>When the node starts for the first time, it must synchronize its state with the rest of the network. GoShimmer currently uses the Tangle Time to help nodes determine their synced status.</p>
<h4 id="dashboard"><a class="header" href="#dashboard">Dashboard</a></h4>
<p>The dashboard of your GoShimmer node should be accessible via <code>http://&lt;your-ip&gt;:8081</code>. If your node is still synchronizing, you might see a higher inflow of MPS.</p>
<p><img src="https://user-images.githubusercontent.com/11289354/119599542-c3985e00-be17-11eb-8769-7e639f365ae5.png" alt="" /></p>
<p>After a while, your node's dashboard should also display up to 8 neighbors:
<img src="https://i.imgur.com/gAyAXK9.png" alt="" /></p>
<h4 id="http-api"><a class="header" href="#http-api">HTTP API</a></h4>
<p>GoShimmer also exposes an HTTP API. To check whether that works correctly, you can access it via <code>http://&lt;your-ip&gt;:8080/info</code> which should return a JSON response in the form of:</p>
<pre><code>{
  &quot;version&quot;: &quot;v0.6.2&quot;,
  &quot;networkVersion&quot;: 30,
  &quot;tangleTime&quot;: {
    &quot;messageID&quot;: &quot;6ndfmfogpH9H8C9X9Fbb7Jmuf8RJHQgSjsHNPdKUUhoJ&quot;,
    &quot;time&quot;: 1621879864032595415,
    &quot;synced&quot;: true
  },
  &quot;identityID&quot;: &quot;D9SPFofAGhA5V9QRDngc1E8qG9bTrnATmpZMdoyRiBoW&quot;,
  &quot;identityIDShort&quot;: &quot;XBgY5DsUPng&quot;,
  &quot;publicKey&quot;: &quot;9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd&quot;,
  &quot;solidMessageCount&quot;: 74088,
  &quot;totalMessageCount&quot;: 74088,
  &quot;enabledPlugins&quot;: [
    ...
  ],
  &quot;disabledPlugins&quot;: [
    ...
  ],
  &quot;mana&quot;: {
    &quot;access&quot;: 1,
    &quot;accessTimestamp&quot;: &quot;2021-05-24T20:11:05.451224937+02:00&quot;,
    &quot;consensus&quot;: 10439991680906,
    &quot;consensusTimestamp&quot;: &quot;2021-05-24T20:11:05.451228137+02:00&quot;
  },
  &quot;manaDelegationAddress&quot;: &quot;1HMQic52dz3xLY2aeDXcDhX53LgbsHghdfD8eGXR1qVHy&quot;,
  &quot;mana_decay&quot;: 0.00003209,
  &quot;scheduler&quot;: {
    &quot;running&quot;: true,
    &quot;rate&quot;: &quot;5ms&quot;,
    &quot;nodeQueueSizes&quot;: {}
  },
  &quot;rateSetter&quot;: {
    &quot;rate&quot;: 20000,
    &quot;size&quot;: 0
  }
}
</code></pre>
<h2 id="managing-the-goshimmer-node-lifecycle"><a class="header" href="#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></h2>
<h5 id="stopping-the-node"><a class="header" href="#stopping-the-node">Stopping the node</a></h5>
<pre><code>docker-compose stop
</code></pre>
<h5 id="resetting-the-node"><a class="header" href="#resetting-the-node">Resetting the node</a></h5>
<pre><code>docker-compose down
</code></pre>
<h5 id="upgrading-the-node"><a class="header" href="#upgrading-the-node">Upgrading the node</a></h5>
<p><strong>Ensure that the image version in the <code>docker-compose.yml</code> is <code>latest</code></strong> then execute following commands:</p>
<pre><code>docker-compose down
rm db/*
docker-compose pull
docker-compose up -d
</code></pre>
<h5 id="following-log-output"><a class="header" href="#following-log-output">Following log output</a></h5>
<pre><code>docker logs -f --since=1m goshimmer
</code></pre>
<h5 id="create-a-logtxt"><a class="header" href="#create-a-logtxt">Create a log.txt</a></h5>
<pre><code>docker logs goshimmer &gt; log.txt
</code></pre>
<h5 id="update-grafana-dashboard"><a class="header" href="#update-grafana-dashboard">Update Grafana Dashboard</a></h5>
<p>If you set up the Grafana dashboard for your node according to the next section &quot;Setting up the Grafana dashboard&quot;, the following method will help you to update when a new version is released.</p>
<p>You have to manually copy the new <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">dashboard file</a> into <code>/opt/goshimmer/grafana/dashboards</code> directory.
Supposing you are at <code>/opt/goshimmer/</code>:</p>
<pre><code>wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
cp local_dashboard.json grafana/dashboards
</code></pre>
<p>Restart the grafana container:</p>
<pre><code>docker restart grafana
</code></pre>
<h2 id="setting-up-the-grafana-dashboard"><a class="header" href="#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></h2>
<h4 id="add-prometheus-and-grafana-containers-to-docker-composeyml"><a class="header" href="#add-prometheus-and-grafana-containers-to-docker-composeyml">Add Prometheus and Grafana Containers to <code>docker-compose.yml</code></a></h4>
<p>Append the following to the previously described <code>docker-compose.yml</code> file (<strong>make sure to also copy the space in front of &quot;prometheus&quot;/the entire whitespace</strong>):</p>
<pre><code class="language-yaml">  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - &quot;9090:9090/tcp&quot;
    command:
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./prometheus/data:/prometheus:rw
    depends_on:
      - goshimmer
    networks:
      - outside

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    environment:
      # path to provisioning definitions can only be defined as
      # environment variables for grafana within docker
      - GF_PATHS_PROVISIONING=/var/lib/grafana/provisioning
    ports:
      - &quot;3000:3000/tcp&quot;
    user: &quot;472&quot;
    volumes:
      - ./grafana:/var/lib/grafana:rw
    networks:
      - outside
</code></pre>
<h4 id="create-prometheus-config"><a class="header" href="#create-prometheus-config">Create Prometheus config</a></h4>
<ol>
<li>Create a <code>prometheus/data</code> directory in <code>/opt/goshimmer</code>:</li>
</ol>
<pre><code>cd /opt/goshimmer
mkdir -p prometheus/data
</code></pre>
<ol start="2">
<li>Create a <code>prometheus.yml</code> in <code>prometheus</code> directory:</li>
</ol>
<pre><code>nano prometheus/prometheus.yml
</code></pre>
<p>The content of the file should be:</p>
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        - goshimmer:9311
</code></pre>
<ol start="3">
<li>Add permissions to <code>prometheus</code> config directory:</li>
</ol>
<pre><code>chmod -R 777 prometheus
</code></pre>
<h4 id="create-grafana-configs"><a class="header" href="#create-grafana-configs">Create Grafana configs</a></h4>
<ol>
<li>Create necessary config dirs in <code>/opt/goshimmer/</code>.</li>
</ol>
<pre><code>mkdir -p grafana/provisioning/datasources grafana/provisioning/dashboards grafana/provisioning/notifiers
mkdir -p grafana/dashboards
</code></pre>
<ol start="2">
<li>Create a datasource configuration file in <code>grafana/provisioning/datasources</code>:</li>
</ol>
<pre><code>nano grafana/provisioning/datasources/datasources.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    # &lt;string, required&gt; access mode. proxy or direct (Server or Browser in the UI). Required
    access: proxy
    orgId: 1
    url: http://prometheus:9090
    jsonData:
      graphiteVersion: '1.1'
      timeInterval: '1s'
    # &lt;string&gt; json object of data that will be encrypted.
    secureJsonData:
      # &lt;string&gt; database password, if used
      password:
      # &lt;string&gt; basic auth password
      basicAuthPassword:
    version: 1
    # &lt;bool&gt; allow users to edit datasources from the UI.
    editable: true
</code></pre>
<ol start="3">
<li>Create a dashboard configuration file in <code>grafana/provisioning/dashboards</code>:</li>
</ol>
<pre><code>nano grafana/provisioning/dashboards/dashboards.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

providers:
  - name: 'Goshimmer Local Metrics'
    orgId: 1
    folder: ''
    type: file
    disableDeletion: false
    editable: true
    updateIntervalSeconds: 10
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards
</code></pre>
<ol start="4">
<li>Add predefined GoShimmer Local Metrics Dashboard.</li>
</ol>
<p>Head over to the GoShimmer repository and download <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a>.</p>
<pre><code>wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
cp local_dashboard.json grafana/dashboards
</code></pre>
<ol start="5">
<li>Add permissions to Grafana config folder</li>
</ol>
<pre><code>chmod -R 777 grafana
</code></pre>
<h4 id="run-goshimmer-with-prometheus-and-grafana"><a class="header" href="#run-goshimmer-with-prometheus-and-grafana">Run GoShimmer with Prometheus and Grafana:</a></h4>
<pre><code>docker-compose up -d
</code></pre>
<p>The Grafana dashboard should be accessible at <code>http://&lt;your-ip&gt;:3000</code>.</p>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code>: admin</li>
<li><code>password</code>: admin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-obtain-tokens-from-the-faucet"><a class="header" href="#how-to-obtain-tokens-from-the-faucet">How to obtain tokens from the faucet</a></h1>
<h2 id="the-faucet-dapp"><a class="header" href="#the-faucet-dapp">The faucet dApp</a></h2>
<p>The faucet is a dApp built on top of the <a href="tutorials/../concepts/layers.html">value and communication layer</a>. It sends IOTA tokens to addresses by listening to faucet request messages. A faucet message is a Message containing a special payload with an address encoded in Base58, the aManaPledgeID, the cManaPledgeID and a nonce as a proof that some Proof Of Work has been computed. The PoW is just a way to rate limit and avoid abuse of the Faucet. The Faucet has an additional protection by means of granting request to a given address only once. That means that, in order to receive funds from the Faucet multuple times, the address must be different.</p>
<p>After sending a faucet request message, you can check your balances via <a href="tutorials/../apis/ledgerstate.html"><code>GetAddressUnspentOutputs()</code></a>.</p>
<h2 id="obtain-tokens-from-the-faucet"><a class="header" href="#obtain-tokens-from-the-faucet">Obtain tokens from the faucet</a></h2>
<p>There are 3 ways to send a faucet request message to obtain IOTA tokens:</p>
<ol>
<li>Via the Go client library</li>
<li>Via the HTTP API directly</li>
<li>Via the wallet</li>
</ol>
<h3 id="via-the-go-client-library"><a class="header" href="#via-the-go-client-library">Via the Go client library</a></h3>
<p>Follow the instructions in <a href="tutorials/../apis/api.html">Use the API</a> to set up the API instance. </p>
<p>Example:</p>
<pre><code class="language-go">// provide your Base58 encoded destination address,
// the proof of work difficulty,
// the optional aManaPledgeID (Base58 encoded),
// the optional cManaPledgeID (Base58 encoded)
messageID, err := goshimAPI.SendFaucetRequest(&quot;JaMauTaTSVBNc13edCCvBK9fZxZ1KKW5fXegT1B7N9jY&quot;, 22, &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;, &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)

---- or

// invoke go get github.com/iotaledger/goshimmer/client/wallet for wallet usage
// get the given address from a wallet instance and
connector := wallet.GenericConnector(wallet.NewWebConnector(&quot;http://localhost:8080&quot;))
addr := wallet.New(connector).Seed().Address(0)
// use String() to get base58 representation
// the proof of work difficulty,
// the optional aManaPledgeID (Base58 encoded),
// the optional cManaPledgeID (Base58 encoded)
messageID, err := goshimAPI.SendFaucetRequest(addr.String(), 22, &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;, &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
</code></pre>
<h3 id="via-the-wallet"><a class="header" href="#via-the-wallet">Via the wallet</a></h3>
<p>Currently, there is one cli-wallet that you can refer to the tutorial <a href="tutorials/./wallet.html">Command Line Wallet
</a> and two GUI wallets to use. One from the community member <a href="https://github.com/Dr-Electron/ElectricShimmer">Dr-Electron ElectricShimmer</a> and another from the foundation <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a>. You can request funds from the faucet with these two implementations.</p>
<p>As for pollen-wallet, follow the instructions in <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a> to build and execute the wallet, or download executable file directly in <a href="https://github.com/iotaledger/pollen-wallet/releases">GoShimmer wallet release</a>.</p>
<p>You can request funds by pressing the <code>Request Funds</code> in the wallet.</p>
<p><strong>Note</strong>: You need to create a wallet first before requesting funds.</p>
<img src="https://user-images.githubusercontent.com/11289354/88524828-70edea00-d02c-11ea-9a01-d7e1a8b7bdfd.png" height="450">
<p>This may take a while to receive funds:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525200-e0fc7000-d02c-11ea-9f7f-a545cf14b318.png" width="450">
<p>When the faucet request is successful, you can check the received balances:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525478-38024500-d02d-11ea-92c7-25c80eb6a947.png" width="450">
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-wallet"><a class="header" href="#command-line-wallet">Command Line Wallet</a></h1>
<p>This page describes how to use the command line wallet (cli-wallet).</p>
<p>GoShimmer ships with a basic (golang) wallet library so that developers and testers can use it to move tokens around,
create digital assets, NFTs or delegate funds.
The cli-wallet is built by using this wallet library to demonstrate the capabilities of the protocol.</p>
<p>The main features in the wallet are:</p>
<ul>
<li>Requesting tokens from the faucet</li>
<li>Creating digital assets</li>
<li>Sending tokens or assets to addresses</li>
<li>Creating, transferring or destroying Non-Fungible Tokens (NFTs)</li>
<li>Managing NFT owned tokens or assets</li>
<li>Delegating tokens or digital assets</li>
</ul>
<p>In the following, we will go through these features one-by-one to aid the reader in learning how to use the wallet.</p>
<p>Disclaimer: The command line wallet and this tutorial is intended for developer audience, you at least have to be familiar with using a terminal.</p>
<h2 id="initializing-the-wallet"><a class="header" href="#initializing-the-wallet">Initializing the wallet</a></h2>
<ul>
<li>Download the latest cli-wallet for the system of your choice from the <a href="https://github.com/iotaledger/goshimmer/releases">GoShimmer GitHub Releases</a> page.</li>
<li>If needed, make the downloaded binary executable (<code>chmod +x &lt;downloaded-binary&gt;</code> on linux).</li>
<li>For simplicity, we renamed the binary to <code>cli-wallet</code> in this tutorial.</li>
</ul>
<p>The first time the wallet is started, it has to be initialized. This step involves generating a secret seed that is used
to generate addresses and sign transactions. The generated seed is persisted in <code>wallet.dat</code> after the first run.</p>
<p>The wallet can be configured by creating a <code>config.json</code> file in the directory of the executable:</p>
<pre><code class="language-json">{
	&quot;WebAPI&quot;: &quot;http://127.0.0.1:8080&quot;,
	&quot;basic_auth&quot;: {
	  &quot;enabled&quot;: false,
	  &quot;username&quot;: &quot;goshimmer&quot;,
	  &quot;password&quot;: &quot;goshimmer&quot;
	},
	&quot;reuse_addresses&quot;: false,
	&quot;faucetPowDifficulty&quot;: 25,
	&quot;assetRegistryNetwork&quot;: &quot;nectar&quot;
}
</code></pre>
<ul>
<li>The <code>WebAPI</code> tells the wallet which node API to communicate with. Set it to the url of a node API.</li>
<li>If the node has basic authentication enabled, you may configure your wallet with a username and password.</li>
<li>The <code>resuse_addresses</code> option specifies if the wallet should treat addresses as reusable, or whether it should try to
spend from any wallet address only once.</li>
<li><code>faucetPowDifficulty</code> defines the difficulty of the faucet request POW the wallet should do.</li>
<li><code>assetRegistryNetwork</code> defines which asset registry network to use for pushing/fetching asset metadata to/from the registry.
By default, the wallet chooses the <code>nectar</code> network.</li>
</ul>
<p>To perform the wallet initialization, run the <code>init</code> command of the wallet:</p>
<pre><code class="language-bash">./cli-wallet init
</code></pre>
<p>If successful, you'll see the generated seed (encoded in base58) on your screen:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2
GENERATING NEW WALLET ...                                 [DONE]

================================================================
!!!            PLEASE CREATE A BACKUP OF YOUR SEED           !!!
!!!                                                          !!!
!!!       ExzYy6wS2k59dPh19Q9JiAf6z1jyDq1hieDEMmbUzkbE       !!!
!!!                                                          !!!
!!!            PLEASE CREATE A BACKUP OF YOUR SEED           !!!
================================================================

CREATING WALLET STATE FILE (wallet.dat) ...               [DONE]
</code></pre>
<h2 id="requesting-tokens"><a class="header" href="#requesting-tokens">Requesting Tokens</a></h2>
<p>To get your hands on some precious testnet tokens, execute the <code>request-funds</code> command:</p>
<pre><code class="language-bash">./cli-wallet request-funds
</code></pre>
<p>Output:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Requesting funds from faucet ... [PERFORMING POW]          (this can take a while)
Requesting funds from faucet ... [DONE]
</code></pre>
<p>Once executed, you can check the balance of your wallet by running the <code>balance</code> command:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<p>Output:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[PEND]  1000000 I               IOTA                                            IOTA
</code></pre>
<p>The status of your token balance is pending (<code>[PEND]</code>) until the network has confirmed the transaction. Pending token balances
can not be spent, wait until status becomes <code>[ OK ]</code>. Call the <code>balance</code> command again to check for status changes.</p>
<h2 id="creating-digital-assets"><a class="header" href="#creating-digital-assets">Creating Digital Assets</a></h2>
<p>Digital assets are tokens with a special attribute, namely, a color. A color is a sequence of 32 bytes represented as
a base58 encoded string. The color of a token is derived from the unique transaction that created the asset, therefore,
it is not possible to create assets with the same color in a subsequent transaction.</p>
<p>The transaction &quot;minting&quot; the assets can specify the amount of tokens to be created with the unique color. To create
assets with the cli-wallet, execute the <code>create-asset</code> command.</p>
<pre><code class="language-bash">./cli-wallet create-asset -name MyUniqueToken -symbol MUT -amount 1000
</code></pre>
<ul>
<li>The <code>name</code> flag specifies the name of the asset.</li>
<li>The <code>symbol</code> flag specifies the symbol of the asset.</li>
<li>The <code>amount</code> flag specifies the amount of asset tokens to create.</li>
</ul>
<p>Output:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Creating 1000 tokens with the color 'HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn' ...   [DONE]
</code></pre>
<p>By executing the <code>balance</code> command shortly after, you will notice that the wallet balances changed:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[PEND]  999000                  IOTA                                            IOTA
[PEND]  1000                    HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
</code></pre>
<p>1000 IOTA tokens were tagged with the color <code>HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn</code> to create <code>MyUniqueToken</code>.
The IOTA balance is decremented, but we have received assets in return for the used IOTAs. The created asset tokens
behave exactly like an IOTA token, they can be transferred without fees to any address.</p>
<h3 id="fetching-info-of-a-digital-asset"><a class="header" href="#fetching-info-of-a-digital-asset">Fetching Info of a Digital Asset</a></h3>
<p>In the previous step we have created a digital asset called <code>MyUniqueToken</code>. It's name, symbol and initial supply
is known to the wallet because we provided this input while creating it. The network however doesn't store this
information, it only knows its unique identifier, the assetID (or color).
To help others discover the attributes of the asset, upon asset creation, the <code>cli-wallet</code> automatically sends this
information to a metadata registry service.
When you receive an asset unknown locally to your wallet, it queries this registry service for the metadata. You can
also query this metadata yourself by running the <code>asset-info</code> command in the wallet:</p>
<pre><code class="language-bash">./cli-wallet asset-info -id HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn
</code></pre>
<pre><code class="language-bash">IOTA 2.0 DevNet CLI-Wallet 0.2

Asset Info

PROPERTY                        VALUE
-----------------------         --------------------------------------------
Name                            MyUniqueToken
Symbol                          MUT
AssetID(color)                  HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn
Initial Supply                  1000
Creating Transaction            G7ergf7YzVUSqQMS69jGexYtihbhpsvELEsPHWToYtKj
Network                         test
</code></pre>
<h2 id="sending-tokens-and-assets"><a class="header" href="#sending-tokens-and-assets">Sending Tokens and Assets</a></h2>
<p>Funds in IOTA are tied to addresses. Only the owner of the private key behind the address is able to spend (move) the funds,
let them be IOTA tokens or digital assets. In previous steps, we have requested funds from the faucet, which actually sent
these tokens to an address provided by our wallet. When we created <code>MyUniqueToken</code>, the wallet internally generated a new address
to hold the assets. You may examine the addresses used by the wallet by executing the <code>address -list</code> command:</p>
<pre><code class="language-bash">./cli-wallet address -list
</code></pre>
<p>Output:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

INDEX   ADDRESS                                         SPENT
-----   --------------------------------------------    -----
0       19ZD79gRvVzXpQV4QfpY5gefqgrBA4gp11weeyqbY89FK   true
1       1BbywJFGFtDFXpZidmjN39d8cVWUskT2MhbFqSrmVs3qi   false
</code></pre>
<p>Consequently, when you wish to send tokens, you need to provide an address where to send the tokens to. </p>
<h3 id="simple-send"><a class="header" href="#simple-send">Simple Send</a></h3>
<p>Let's suppose your friend gave you their address <code>1E5Q82XTF5QGyC598br9oCj71cREyjD1CGUk2gmaJaFQt</code> and you want to send 
them some of your <code>MyUniqueTokens</code>. The <code>send-funds</code> command is the one you are looking for. Let's ask for some help on
what options we have:</p>
<pre><code class="language-bash">./cli-wallet send-funds -help
</code></pre>
<p>Output:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet send-funds [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -amount int
        the amount of tokens that are supposed to be sent
  -color string
        (optional) color of the tokens to transfer (default &quot;IOTA&quot;)
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -dest-addr string
        destination address for the transfer
  -fallb-addr string
        (optional) fallback address that can claim back the (unspent) sent funds after fallback deadline
  -fallb-deadline int
        (optional) unix timestamp after which only the fallback address can claim the funds back
  -help
        show this help screen
  -lock-until int
        (optional) unix timestamp until which time the sent funds are locked from spending
</code></pre>
<p>You can ignore the mana pledge options, as your wallet can derive pledge IDs automatically. The more important options are:</p>
<ul>
<li><code>amount</code> is the amount of token you want to send,</li>
<li><code>color</code> is an optional flag to send digital assets with a certain color. When not specified, it defaults to the
color of the IOTA token.</li>
<li><code>dest-addr</code> is the destination address for the transfer. You'll have to se this to the address your friend provided you with.</li>
<li><code>fallb-addr</code> and <code>fallb-deadline</code> are optional flags to initiate a conditional transfer. A conditional transfer has a
fallback deadline set, after which, only <code>fallback-address</code> can unlock the funds. Obviously, before the fallback deadline,
it is only the receiver of the funds who can spend the funds. Such conditional transfers therefore have to be claimed
by the receiving party before the deadline expires.</li>
<li><code>lock-until</code> is an optional flag for a simple time locking mechanism: before the time lock expires, the funds are locked
and can not be spent by the owner.</li>
</ul>
<p>To simply send 500 <code>MyUniqueTokens</code> to your friend's address, run the following command:</p>
<pre><code class="language-bash">./cli-wallet send-funds -amount 500 -color HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn -dest-addr 1E5Q82XTF5QGyC598br9oCj71cREyjD1CGUk2gmaJaFQt
</code></pre>
<p>Note, that you have to tell the wallet that <code>MyUniqueTokens</code> are of color <code>HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn</code>.</p>
<h3 id="time-locked-sending"><a class="header" href="#time-locked-sending">Time Locked Sending</a></h3>
<p>What if you wanted to send your friend IOTA tokens, but you don't want them to spend it right away, so you impose a one-week
locking period. You should execute the <code>send-funds</code> command with the <code>-lock-until</code> flag.</p>
<p>The <code>-lock-until</code> flag expects a unix timestamp. On linux, to get a unix timestamp 7 days in the future, execute:</p>
<pre><code class="language-bash">date -d &quot;+7 days&quot; +%s
1621426409
</code></pre>
<p>Noe that you have a unix timestamp, you can execute the transfer:</p>
<pre><code class="language-bash">$ ./cli-wallet send-funds -amount 500 -dest-addr 1E5Q82XTF5QGyC598br9oCj71cREyjD1CGUk2gmaJaFQt -lock-until 1621426409
</code></pre>
<h3 id="conditional-sending"><a class="header" href="#conditional-sending">Conditional Sending</a></h3>
<p>You have the option to specify a fallback unlocking mechanism on the tokens you send. If the recipient doesn't claim
the funds before the fallback deadline you specify expires, the fallback address can essentially take back the tokens.</p>
<p>So let's assume you want to send your friend some IOTAs, but if your friend doesn't claim them for a week, you want to
have them back. First things first, let's get the receive address of your wallet by running:</p>
<pre><code class="language-bash">./cli-wallet address -receive
</code></pre>
<p>which will give you your wallets current receive address:</p>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Latest Receive Address: 17KoEZbWoBLRjBsb6oSyrSKVVqd7DVdHUWpxfBFbHaMSm
</code></pre>
<p>Then we can execute the send with the proper parameters:</p>
<pre><code class="language-bash">./cli-wallet send-funds -amount 500 -dest-addr 1E5Q82XTF5QGyC598br9oCj71cREyjD1CGUk2gmaJaFQt \
-fallb-addr 17KoEZbWoBLRjBsb6oSyrSKVVqd7DVdHUWpxfBFbHaMSm --fallb-deadline 1621426409
</code></pre>
<p>When you receive such conditional funds, they will be displayed on the balance page in the wallet:</p>
<pre><code class="language-bash">./cli-wallet balance
IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 I                   IOTA                                            IOTA

Conditional Token Balances - execute `claim-conditional` command to sweep these funds into wallet

STATUS  OWNED UNTIL                     BALANCE                 COLOR                                           TOKEN NAME
------  ------------------------------  ---------------         --------------------------------------------    -------------------------
[ OK ]  2021-05-19 14:13:29 +0200 CEST  500 I                   IOTA                                            IOTA
</code></pre>
<p>As the output suggests, you need to execute the <code>claim-conditional</code> command to claim these funds:</p>
<pre><code class="language-bash">./cli-wallet claim-conditional
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Claiming conditionally owned funds... [DONE]
</code></pre>
<pre><code>./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[PEND]  500                     IOTA                                            IOTA
</code></pre>
<h2 id="creating-nfts"><a class="header" href="#creating-nfts">Creating NFTs</a></h2>
<p>NFTs are non-fungible tokens that have unique properties. In IOTA, NFTs are represented as non-forkable, uniquely
identifiable outputs. When such an output is spent, the transaction spending it is only valid if it satisfies the
constraints defined in the outputs. One such constraint is, that immutable data attached to the output can not change.
Therefore, we can create an NFT and record immutable metadata in its output.</p>
<p>Let's create our first NFT with the help of the cli-wallet.</p>
<pre><code class="language-bash">./cli-wallet create-nft -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet create-nft [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -color string
        color of the tokens that should be deposited into the nft upon creation (on top of the minimum required) (default &quot;IOTA&quot;)
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -immutable-data string
        path to the file containing the immutable data that shall be attached to the nft
  -initial-amount int
        the amount of tokens that should be deposited into the nft upon creation (on top of the minimum required)
</code></pre>
<p>None of the flags are strictly required to mint an NFT, so we could just execute the command as it is, however, in most
cases, you'll want to attach immutable metadata to it, which is only possible during creation. Each NFT must have some
IOTAs backing it (locked into its output) to prevent bloating the ledger database. Currently, the minimum requirement
is 100 IOTA tokens, but bear in mind that it might change in the future.
Nevertheless, on top of the minimum required amount IOTAs, you can lock any additional funds into the NFT. To do so,
use the <code>-initial-amount</code> and <code>-color</code> flags.</p>
<p>To attach immutable data to the NFT, you can define a path to a file that holds the metadata. The wallet will read the
byte content of the file and attach it to the NFT. Note, that currently the maximum allowed metadata file size is 4
kilobytes. Use the <code>-immutable-data</code> flag to specify a path to a file that holds the metadata.</p>
<p>Let's create our very first NFT. We create an <code>nft_metadata.json</code> file in the directory of the cli-wallet with the
following content:</p>
<pre><code class="language-json">{
  &quot;title&quot;: &quot;Asset Metadata&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;description&quot;: &quot;MyFirstNFT&quot;
    },
    &quot;description&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;description&quot;: &quot;My very first NFT that has this metadata attached to it.&quot;
    },
    &quot;image&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;description&quot;: &quot;&lt;uri to resource holding the content of my first NFT&gt;&quot;
    }
  }
}
</code></pre>
<p>The above JSON file is just a template, you can define any binary data that fits the size limit to be attached to the NFT.</p>
<p>To create the NFT, simply execute:</p>
<pre><code class="language-bash">./cli-wallet create-nft -immutable-data nft_metadata.json
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Created NFT with ID:  gSfeBrWp1HwDLwSL7rt1qEMM59YBFZ4iBgAqHuqaQHo5
Creating NFT ... [DONE]
</code></pre>
<p>The created NFT's unique identifier is <code>gSfeBrWp1HwDLwSL7rt1qEMM59YBFZ4iBgAqHuqaQHo5</code> that is also a valid IOTA address.
Navigate to a node dashboard/explorer and search for the address. On a node dashboard, you would see something like this:
<img src="https://i.imgur.com/JYx0v5w.png" alt="" /></p>
<p>The immutable data field contains the attached binary metadata (encoded in base64 in the node dashboard).</p>
<p>The NFT is also displayed on the balance page of the cli-wallet:</p>
<pre><code>./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  996200 I                IOTA                                            IOTA

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  gSfeBrWp1HwDLwSL7rt1qEMM59YBFZ4iBgAqHuqaQHo5    100                     IOTA                                            IOTA
</code></pre>
<h2 id="transferring-nfts"><a class="header" href="#transferring-nfts">Transferring NFTs</a></h2>
<p>Any valid IOTA address can own NFTs, so how can we send it?
The <code>transfer-nft</code> command of the cli-wallet comes to the rescue:</p>
<pre><code>./cli-wallet transfer-nft -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet transfer-nft [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -dest-addr string
        destination address for the transfer
  -help
        show this help screen
  -id string
        unique identifier of the nft that should be transferred
  -reset-delegation
        defines whether to reset the delegation status of the alias being transferred
  -reset-state-addr
        defines whether to set the state address to dest-addr
</code></pre>
<p>There are 2 mandatory flags that need to be provided for a valid transfer: <code>-id</code> and <code>-dest-addr</code>. The former is the
unique identifier of the NFT that you wish to transfer, the latter is the destination address.</p>
<p>Let's transfer the NFT to our friend's address:</p>
<pre><code class="language-bash">./cli-wallet transfer-nft -id gSfeBrWp1HwDLwSL7rt1qEMM59YBFZ4iBgAqHuqaQHo5 -dest-addr 1E5Q82XTF5QGyC598br9oCj71cREyjD1CGUk2gmaJaFQt
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Transferring NFT... [DONE]
</code></pre>
<h2 id="destroying-nfts"><a class="header" href="#destroying-nfts">Destroying NFTs</a></h2>
<p>The owner of an NFT has the ability to destroy it. When an NFT is destroyed, all of its balance is transferred to
the current owner, and the alias output representing the NFT is spent without creating a corresponding next alias output.</p>
<p>The command to destroy an NFT is called <code>destroy-nft</code> in the cli-wallet:</p>
<pre><code>./cli-wallet destroy-nft -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet destroy-nft [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -id string
        unique identifier of the nft that should be destroyed

</code></pre>
<p>Let's create an NFT and destroy it right after:</p>
<pre><code class="language-bash">./cli-wallet create-nft
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Created NFT with ID:  bdrvyKvaE6CZUEbdRDK57oBCRb2SLUyE8padFGxrV3zg
Creating NFT ... [DONE]
</code></pre>
<p>Then let's wait until the balance page shows that the NFT status is <code>OK</code>:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  996100 I                IOTA                                            IOTA

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  bdrvyKvaE6CZUEbdRDK57oBCRb2SLUyE8padFGxrV3zg    100                     IOTA                                            IOTA
</code></pre>
<p>Finally, let's destroy it:</p>
<pre><code class="language-bash">./cli-wallet destroy-nft -id bdrvyKvaE6CZUEbdRDK57oBCRb2SLUyE8padFGxrV3zg
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Destroying NFT... [DONE]
</code></pre>
<h2 id="managing-nft-owned-assets"><a class="header" href="#managing-nft-owned-assets">Managing NFT Owned Assets</a></h2>
<p>An NFT is not only a valid IOTA address via its NFT ID, but it is stored as an output in the ledger. Therefore, the NFT
is not only capable of receiving funds to its address, but the owner can directly manage the funds held in the NFT
output.</p>
<ul>
<li>The owner might deposit assets into an NFT, or withdraw assets from there, essentially using it as a standalone wallet.</li>
<li>Other users in the network can send any asset to the NFT address, that will be owned by the NFT. The owner might choose
to deposit such funds into the NFT or sweep them into their own wallet.</li>
</ul>
<h3 id="deposit-assets-into-owned-nft"><a class="header" href="#deposit-assets-into-owned-nft">Deposit Assets Into Owned NFT</a></h3>
<p>Suppose I have created an NFT with the minimum required 100 IOTA balance. Later I figure, that I would like to keep some
assets in the NFT. I can deposit the assets via the <code>deposit-to-nft</code> command:</p>
<pre><code class="language-bash">./cli-wallet deposit-to-nft -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet deposit-to-nft [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -amount int
        the amount of tokens that are supposed to be deposited
  -color string
        color of funds to deposit (default &quot;IOTA&quot;)
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -id string
        unique identifier of the nft to deposit to
</code></pre>
<p>To deposit some previously created <code>MyUniqueTokens</code> into the NFT, we need to specify the following flags:</p>
<ul>
<li><code>-id</code> the NFT ID to deposit to</li>
<li><code>-amount</code> amount of assets to deposit</li>
<li><code>-color</code> asset color to deposit</li>
</ul>
<p>Balance before the deposit looks like this:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  996300 I                IOTA                                            IOTA
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg    100                     IOTA                                            IOTA
</code></pre>
<p>The actual deposit operation:</p>
<pre><code class="language-bash">./cli-wallet deposit-to-nft -id f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg -amount 500 -color HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2
Depositing funds into NFT ... [DONE]
</code></pre>
<pre><code>./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  996300 I                IOTA                                            IOTA

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg    100                     IOTA                                            IOTA
                                                        500                     HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
</code></pre>
<h3 id="withdrawing-assets-from-nft"><a class="header" href="#withdrawing-assets-from-nft">Withdrawing Assets From NFT</a></h3>
<p>The reverse of the deposit command looks quite similar:</p>
<pre><code class="language-bash">./cli-wallet withdraw-from-nft -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet withdraw-from-nft [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -amount int
        the amount of tokens that are supposed to be withdrew
  -color string
        color of funds to withdraw (default &quot;IOTA&quot;)
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -dest-addr string
        (optional) address to send the withdrew tokens to
  -help
        show this help screen
  -id string
        unique identifier of the nft to withdraw from
</code></pre>
<p>Therefore, to withdraw the previously deposited <code>MyUniqueTokens</code>, execute the following command:</p>
<pre><code class="language-bash">./cli-wallet withdraw-from-nft -id f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg -amount 500 -color HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Withdrawing funds from NFT... [DONE]
</code></pre>
<p>Once the transaction confirms, you'll see the updated balance:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  996300 I                IOTA                                            IOTA

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg    100                     IOTA                                            IOTA
</code></pre>
<p>Note, that if the withdrawal leaves less, than the minimum required funds in the NFT, the transaction fails.</p>
<h3 id="sweep-nft-owned-funds"><a class="header" href="#sweep-nft-owned-funds">Sweep NFT Owned Funds</a></h3>
<p>We have previously explained, that an NFT can receive funds to its NFT ID because it is  a valid IOTA address. Such
funds can be collected by the owner of the NFT with the <code>sweep-nft-owned-funds</code> command:</p>
<pre><code class="language-bash">./cli-wallet sweep-nft-owned-funds -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet sweep-nft-owned-funds [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -id string
        unique identifier of the nft that should be checked for outputs with funds
  -to string
        optional address where to sweep
</code></pre>
<p>The only mandatory flag is the <code>-id</code>, as it specifies which NFT ID (address) to scan for funds.</p>
<p>Let's suppose that are friend sent funds form their wallet to our NFT <code>f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg</code>
with a normal <code>send-funds</code> command:</p>
<pre><code class="language-bash">./your-friends-wallet send-funds -amount 1000000 -dest-addr f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg
</code></pre>
<p>We can execute the <code>sweep-nft-owned-funds</code> command to transfer these funds into our wallet:</p>
<pre><code class="language-bash">./cli-wallet sweep-nft-owned-funds -id f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Sweeping NFT owned funds... [DONE]
</code></pre>
<p>The wallet balance should be updated, the wallet contains 1 MI more:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  1996300 I               IOTA                                            IOTA

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg    100                     IOTA                                            IOTA
</code></pre>
<h3 id="sweep-nft-owned-nfts"><a class="header" href="#sweep-nft-owned-nfts">Sweep NFT Owned NFTs</a></h3>
<p>NFTs can own other NFTs, that in turn can own other NFTs and so on... wow, NFTception!
Let's say your friend created an NFT, and transferred it to your NFT's ID <code>f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg</code>.</p>
<pre><code class="language-bash">./your-friends-wallet create-nft
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Created NFT with ID:  faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi
Creating NFT ... [DONE]
</code></pre>
<pre><code>./your-friends-wallet transfer-nft -id faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi -dest-addr f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Transferring NFT... [DONE]
</code></pre>
<p>Your NFT <code>f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg</code> now owns NFT <code>faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi</code>.
To sweep the owned NFT into your wallet, execute the <code>sweep-nft-owned-nft</code> command:</p>
<pre><code class="language-bash">./cli-wallet sweep-nft-owned-nfts -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet sweep-nft-owned-nfts [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -id string
        unique identifier of the nft that should be checked for owning other nfts
  -to string
        optional address where to sweep
</code></pre>
<p>All you need to specify is the <code>-id</code> of your NFT that you would like to check for owned NFTs:</p>
<pre><code class="language-bash">./cli-wallet sweep-nft-owned-nfts -id f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Swept NFT faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi into the wallet
Sweeping NFT owned NFTs... [DONE]
</code></pre>
<p>That's it, your wallet owns <code>faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi</code> now. If this NFT owned other funds or NFTs,
you would be able to sweep them into your wallet just like you did for <code>f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg</code>.</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  1996300 I               IOTA                                            IOTA
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken

Owned NFTs (Governance Controlled Aliases)

STATUS  NFT ID (ALIAS ID)                               BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  f1BW8jcdDn3staviCVbVz54NqVwsshb5gpNLqY6Rrgrg    100                     IOTA                                            IOTA
[ OK ]  faf9tkdBfcTv2AgPm3Zt8duX4iUGKjqbEyrdBYsUb2hi    100                     IOTA                                            IOTA
</code></pre>
<h2 id="delegating-assets"><a class="header" href="#delegating-assets">Delegating Assets</a></h2>
<p>The primary use case of fund delegation in Coordicide is to enable refreshing a node's access mana without requiring
the use of a master key that has full control over the funds. A delegated key can not spend the funds, but can
&quot;refresh&quot; the outputs holding the funds in a transaction that can pledge mana to any arbitrary nodes.</p>
<p>A token holder can therefore keep their funds in secure cold storage, while delegating them to a node or third party
to utilize the mana generated by the funds. Assuming there is demand for access mana in the network, the holder of the
assets can then sell the generated mana to realize return on their assets.</p>
<p>Delegating funds via the cli-wallet is rather simple: you just need to execute the <code>delegate-funds</code> command. By default,
the cli-wallet will delegate funds to the node that the wallet is connected to, unless you specify a delegation
address via the <code>-del-addr</code> flag.
specify a valid IOTA address where to delegate to.</p>
<pre><code class="language-bash">./cli-wallet delegate-funds -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet delegate-funds [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -amount int
        the amount of tokens that should be delegated
  -color string
        color of the tokens that should delegated (default &quot;IOTA&quot;)
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -del-addr string
        address to delegate funds to. when omitted, wallet delegates to the node it is connected to
  -help
        show this help screen
  -until int
        unix timestamp until which the delegated funds are timelocked
</code></pre>
<ul>
<li>Mandatory parameter is only the <code>-amount</code>.</li>
<li>Use the <code>-del-addr</code> flag to delegate to arbitrary address.</li>
<li>You may specify a delegation deadline via the <code>-until</code> flag. If this is set, the delegated party can not unlock
the funds for refreshing mana after the deadline expired, but the neither can the owner reclaim the funds before
that. If the <code>-until</code> flag is omitted, the delegation is open-ended, the owner can reclaim the delegated funds at
any time.</li>
<li>You can specify a certain asset to be delegated (<code>-color</code>), default is IOTA.</li>
</ul>
<p>Let's delegate some funds to an address provided by a node in the network, <code>1EqJf5K1LJ6bVMCrxxxdZ6VNYoBTvEoXgxnbLJe7aqajc</code>:</p>
<pre><code class="language-bash">./cli-wallet delegate-funds -amount 1000000 -del-addr 1EqJf5K1LJ6bVMCrxxxdZ6VNYoBTvEoXgxnbLJe7aqajc
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Delegating to address 1EqJf5K1LJ6bVMCrxxxdZ6VNYoBTvEoXgxnbLJe7aqajc
Delegation ID is:  tGoTKjt2y277ssKax9stsZXfLGdf8bPj3TZFaUDcAEwK
Delegating funds... [DONE]
</code></pre>
<p>If we omitted the <code>-del-addr</code> flag and its value, the wallet would have asked the node it is connected to, to provide
a delegation address. You can get this delegation address yourself as well by running the <code>server-status</code> command in
the wallet, or querying the <code>/info</code> endpoint of a node through the webapi.</p>
<pre><code class="language-bash">./cli-wallet server-status
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Server ID:  2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5
Server Synced:  true
Server Version:  v0.5.9
Delegation Address:  1HG9Z5NSiWTmT1HG65JLmn1jxQj7xUcVppKKi2vHAZLmr
</code></pre>
<p>By running the <code>balance</code> command, we can see the delegated funds:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  996500 I                IOTA                                            IOTA

Delegated Funds

STATUS  DELEGATION ID (ALIAS ID)                        BALANCE                 COLOR                                           TOKEN NAME
------  --------------------------------------------    ---------------         --------------------------------------------    -------------------------
[ OK ]  tGoTKjt2y277ssKax9stsZXfLGdf8bPj3TZFaUDcAEwK    1000000                 IOTA                                            IOTA
</code></pre>
<p>To be able to reclaim the delegated funds, we will need the delegation ID of the delegated funds.</p>
<h2 id="reclaiming-delegated-assets"><a class="header" href="#reclaiming-delegated-assets">Reclaiming Delegated Assets</a></h2>
<p>To reclaim delegated funds, you have to tell the cli-wallet the delegation ID that is displayed on the balance page.
Use the <code>reclaim-delegated</code> command once you got the delegation ID:</p>
<pre><code class="language-bash"> ./cli-wallet reclaim-delegated -help
IOTA 2.0 DevNet CLI-Wallet 0.2

USAGE:
  cli-wallet reclaim-delegated [OPTIONS]

OPTIONS:
  -access-mana-id string
        node ID to pledge access mana to
  -consensus-mana-id string
        node ID to pledge consensus mana to
  -help
        show this help screen
  -id string
        delegation ID that should be reclaimed
  -to-addr string
        optional address where to send reclaimed funds, wallet receive address by default
</code></pre>
<p>To reclaim the funds delegated in the previous section, simply run:</p>
<pre><code class="language-bash">./cli-wallet reclaim-delegated -id tGoTKjt2y277ssKax9stsZXfLGdf8bPj3TZFaUDcAEwK
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Reclaimed delegation ID is:  tGoTKjt2y277ssKax9stsZXfLGdf8bPj3TZFaUDcAEwK
Reclaiming delegated fund... [DONE]
</code></pre>
<p>The balance should appear in the <code>Available Balances</code> section of the balance page:</p>
<pre><code class="language-bash">./cli-wallet balance
</code></pre>
<pre><code>IOTA 2.0 DevNet CLI-Wallet 0.2

Available Token Balances

STATUS  BALANCE                 COLOR                                           TOKEN NAME
------  ---------------         --------------------------------------------    -------------------------
[ OK ]  500 MUT                 HJdkZkn6MKda9fNuXFQZ8Dzdzu1wvuSUQp8QX1AMH4wn    MyUniqueToken
[ OK ]  1996500 I               IOTA                                            IOTA
</code></pre>
<h2 id="common-flags"><a class="header" href="#common-flags">Common Flags</a></h2>
<p>As you may have noticed, there are some universal flags in many commands, namely:</p>
<ul>
<li><code>-help</code> that brings up the command usage and help information,</li>
<li><code>access-mana-id</code> that is the nodeID to which the transaction should pledge access mana to, and</li>
<li><code>consensus-mana-id</code> that is the nodeID to which the transaction should pledge consensus mana to.</li>
</ul>
<p>The latter teo are determined by default by your wallet depending on which node you connect it to. However, if that node
doesn't filter user submitted transactions based on the mana pledge IDs, you are free to define which node to pledge
mana to.</p>
<h2 id="command-reference"><a class="header" href="#command-reference">Command Reference</a></h2>
<h3 id="balance"><a class="header" href="#balance">balance</a></h3>
<p>Show the balances held by this wallet.</p>
<h3 id="send-funds"><a class="header" href="#send-funds">send-funds</a></h3>
<p>Initiate a transfer of tokens or assets (funds).</p>
<h3 id="consolidate-funds"><a class="header" href="#consolidate-funds">consolidate-funds</a></h3>
<p>Consolidate all available funds to one wallet address.</p>
<h3 id="claim-conditional"><a class="header" href="#claim-conditional">claim-conditional</a></h3>
<p>Claim (move) conditionally owned funds into the wallet.</p>
<h3 id="request-funds"><a class="header" href="#request-funds">request-funds</a></h3>
<p>Request funds from the testnet-faucet.</p>
<h3 id="create-asset"><a class="header" href="#create-asset">create-asset</a></h3>
<p>Create an asset in the form of colored coins.</p>
<h3 id="delegate-funds"><a class="header" href="#delegate-funds">delegate-funds</a></h3>
<p>Delegate funds to an address.</p>
<h3 id="reclaim-delegated"><a class="header" href="#reclaim-delegated">reclaim-delegated</a></h3>
<p>Reclaim previously delegated funds.</p>
<h3 id="create-nft"><a class="header" href="#create-nft">create-nft</a></h3>
<p>Create an NFT as an unforkable alias output.</p>
<h3 id="transfer-nft"><a class="header" href="#transfer-nft">transfer-nft</a></h3>
<p>Transfer the ownership of an NFT.</p>
<h3 id="destroy-nft"><a class="header" href="#destroy-nft">destroy-nft</a></h3>
<p>Destroy an NFT.</p>
<h3 id="deposit-to-nft"><a class="header" href="#deposit-to-nft">deposit-to-nft</a></h3>
<p>Deposit funds into an NFT.</p>
<h3 id="withdraw-from-nft"><a class="header" href="#withdraw-from-nft">withdraw-from-nft</a></h3>
<p>Withdraw funds from an NFT.</p>
<h3 id="sweep-nft-owned-funds-1"><a class="header" href="#sweep-nft-owned-funds-1">sweep-nft-owned-funds</a></h3>
<p>Sweep all available funds owned by NFT into the wallet.</p>
<h3 id="sweep-nft-owned-nfts-1"><a class="header" href="#sweep-nft-owned-nfts-1">sweep-nft-owned-nfts</a></h3>
<p>weep all available NFTs owned by NFT into the wallet.</p>
<h3 id="address"><a class="header" href="#address">address</a></h3>
<p>Start the address manager of this wallet.</p>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<p>Generate a new wallet using a random seed.</p>
<h3 id="server-status"><a class="header" href="#server-status">server-status</a></h3>
<p>Display the server status.</p>
<h3 id="pending-mana"><a class="header" href="#pending-mana">pending-mana</a></h3>
<p>Display current pending mana of all outputs in the wallet grouped by address.</p>
<h3 id="pledge-id"><a class="header" href="#pledge-id">pledge-id</a></h3>
<p>Query nodeIDs accepted as pledge IDs in transaction by the node (server).</p>
<h3 id="help"><a class="header" href="#help">help</a></h3>
<p>Display this help screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-create-dapps"><a class="header" href="#how-to-create-dapps">How to create dApps</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<blockquote>
<p><strong>DISCLAIMER:</strong> GoShimmer is a rapidly evolving prototype software. As such, the described steps here will likely change in the future. Specifically, we are envisioning to ease the process of dApp creation and installation for node owners. Furthermore, the current approach is in no way hardened and should be seen as purely experimental. Do not write any software for actual production use.</p>
</blockquote>
<h2 id="intro"><a class="header" href="#intro">Intro</a></h2>
<p>Throughout this tutorial we will learn how to write simple dApps as GoShimmer plugins. We provide two different examples: a chat dApp and a network delay dApp. Hope you enjoy the reading!</p>
<h2 id="chat-dapp"><a class="header" href="#chat-dapp">Chat dApp</a></h2>
<p>In this guide we are going to explain how to write a very simple chat dApp so that anyone, connected to a GoShimmer node, could write a short message and read what is being written into the Tangle.</p>
<p>The complete source code of the application can be found <a href="https://github.com/iotaledger/goshimmer/tree/develop/plugins/chat">in the repository</a>. </p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>Our chat dApp can be implemented in a few simple steps:</p>
<ol>
<li>A node sends a special message containing a chat payload via the Tangle.</li>
<li>Upon receipt, every other node in the network processes this message and - if the chat dApp/plugin is enabled - triggers an event that a chat message has been received.</li>
</ol>
<p>Within GoShimmer we need 3 components to realize this undertaking. First, we need to <strong>define and register a chat payload type</strong>. Second, we need a way to <strong>initiate a message</strong> with a chat payload via the web API. And lastly, we need to <strong>listen</strong> for chat payloads and take appropriate action.</p>
<p>If a node does not have our chat dApp installed and activated, the chat message will be simply treated as a raw data message without any particular meaning. In general that means that in order for a dApp to be useful, node owners need to explicitly install it. In our case we simply ship it with GoShimmer as a <a href="tutorials/../implementation_design/plugin.html">plugin</a>.</p>
<h3 id="define--register-the-chat-payload"><a class="header" href="#define--register-the-chat-payload">Define &amp; Register The Chat Payload</a></h3>
<p>First, we need to decide what data our chat payload should contain and define the byte layout accordingly.
In our case we need a <code>From</code> field to identify the sender of the message (e.g., a nickname, the ID of the node); a <code>To</code> field to identify an optional recipient of the message (e.g., a chat room ID, a nickname); a <code>Message</code> field containing the actual chat message.
Therefore, we can define the byte layout as follows:</p>
<pre><code>length&lt;uint32-4bytes&gt; // every payload has to have this
type&lt;uint32-4bytes&gt; // every payload has to have this
From&lt;string&gt;
To&lt;string&gt;
Message&lt;string&gt;
</code></pre>
<p>Next, we need to fulfill the <code>Payload</code> interface and provide the functionality to read/write a payload from/to bytes. The <a href="https://github.com/iotaledger/hive.go/tree/master/marshalutil"><code>hive.go/marshalutil</code></a> package simplifies this step tremendously.</p>
<pre><code class="language-Go">// Payload represents the generic interface for a payload that can be embedded in Messages of the Tangle.
type Payload interface {
    // Type returns the Type of the Payload.
    Type() Type
    
    // Bytes returns a marshaled version of the Payload.
    Bytes() []byte
    
    // String returns a human readable version of the Payload.
    String() string
}
</code></pre>
<p>Finally, we need to create and register our chat payload type so that it can be properly unmarshalled. </p>
<pre><code class="language-Go">// Type represents the identifier which addresses the chat payload type.
var Type = payload.NewType(payloadType, PayloadName, func(data []byte) (payload payload.Payload, err error) {
	var consumedBytes int
	payload, consumedBytes, err = FromBytes(data)
	if err != nil {
		return nil, err
	}
	if consumedBytes != len(data) {
		return nil, errors.New(&quot;not all payload bytes were consumed&quot;)
	}
	return
})
</code></pre>
<h3 id="create-the-web-api-endpoints"><a class="header" href="#create-the-web-api-endpoints">Create The Web API Endpoints</a></h3>
<p>In order to issue a message with our newly created chat payload, we need to create a web API endpoint. Here we simply bind a json request containing the necessary fields: <code>from</code>, <code>to</code> and <code>message</code> and then issue it into the Tangle with <code>messagelayer.Tangle().IssuePayload(chatPayload)</code>. This plugin takes care of all the specifics and employs the <code>MessageFactory</code> to, i.a., select tips and sign the message.</p>
<pre><code class="language-Go">webapi.Server().POST(&quot;chat&quot;, SendChatMessage)

// SendChatMessage sends a chat message.
func SendChatMessage(c echo.Context) error {
	req := &amp;Request{}
	if err := c.Bind(req); err != nil {
		return c.JSON(http.StatusBadRequest, jsonmodels.NewErrorResponse(err))
	}
	chatPayload := NewPayload(req.From, req.To, req.Message)

	msg, err := messagelayer.Tangle().IssuePayload(chatPayload)
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
	}

	return c.JSON(http.StatusOK, Response{MessageID: msg.ID().Base58()})
}
</code></pre>
<h3 id="listen-for-chat-payloads"><a class="header" href="#listen-for-chat-payloads">Listen for chat payloads</a></h3>
<p>Every dApp listens for messages from the <em>communication layer</em> and when its payload type is detected, takes appropriate action. For us that means listening for chat payload type and triggering an event if we encounter any. In this case the event will contain information about the chat message and also the <code>MessageID</code> in terms of a Tangle message as well as its issuance timestamp.</p>
<pre><code class="language-Go">func onReceiveMessageFromMessageLayer(messageID tangle.MessageID) {
	var chatEvent *ChatEvent
	messagelayer.Tangle().Storage.Message(messageID).Consume(func(message *tangle.Message) {
		if message.Payload().Type() != Type {
			return
		}

		chatPayload, _, err := FromBytes(message.Payload().Bytes())
		if err != nil {
			app.LogError(err)
			return
		}

		chatEvent = &amp;ChatEvent{
			From:      chatPayload.From,
			To:        chatPayload.To,
			Message:   chatPayload.Message,
			Timestamp: message.IssuingTime(),
			MessageID: message.ID().Base58(),
		}
	})

	if chatEvent == nil {
		return
	}

	app.LogInfo(chatEvent)
	Events.MessageReceived.Trigger(chatEvent)
}
</code></pre>
<h2 id="network-delay-dapp"><a class="header" href="#network-delay-dapp">Network Delay dApp</a></h2>
<p>In this guide we are going to explain how to write a very simple dApp based on an actual dApp we are using in GoShimmer to help us measure the network delay, i.e., how long it takes for every active node in the network to receive a message. Gathering this data will enable us to set realistic parameters for FCoB.</p>
<p>The complete source code of the application can be found <a href="https://github.com/iotaledger/goshimmer/tree/develop/plugins/networkdelay">in the repository</a>. </p>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p>Our network delay dApp should help us to identify the time it takes for every active node to receive and process a message. That can be done in a few simple steps:</p>
<ol>
<li>A (known) node sends a special message containing a network delay payload.</li>
<li>Upon receipt, every other node in the network answers to the special message by posting its current time to our remote logger.</li>
<li>For simplicity, we gather the information in an <a href="https://www.elastic.co/what-is/elk-stack">ELK stack</a>. This helps us to easily interpret and analyze the data.</li>
</ol>
<p>Within GoShimmer we need 3 components to realize this undertaking. First, we need to <strong>define and register a network delay payload type</strong>. Second, we need a way to <strong>initiate a message</strong> with a network delay payload via the web API. And lastly, we need to <strong>listen</strong> for network delay payloads and take appropriate action.</p>
<p>If a node does not have our dApp installed and activated, the message will be simply treated as a raw data message without any particular meaning. In general that means that in order for a dApp to be useful, node owners need to explicitly install it. In our case we simply ship it with GoShimmer as a <a href="tutorials/../implementation_design/plugin.html">plugin</a>.</p>
<h3 id="define--register-the-network-delay-object"><a class="header" href="#define--register-the-network-delay-object">Define &amp; Register The Network Delay Object</a></h3>
<p>First, we need to decide what data our network delay payload should contain and define the byte layout accordingly.
In our case we need an <code>ID</code> to identify a network delay message and the <code>sent time</code> of the initiator. 
Therefore, we can define the byte layout as follows:</p>
<pre><code>length&lt;uint32-4bytes&gt; // every payload has to have this
type&lt;uint32-4bytes&gt; // every payload has to have this
id&lt;32bytes&gt;
sentTime&lt;int64-8bytes&gt;
</code></pre>
<p>Next, we need to fulfill the <code>Payload</code> interface and provide the functionality to read/write a payload from/to bytes. The <a href="https://github.com/iotaledger/hive.go/tree/master/marshalutil"><code>hive.go/marshalutil</code></a> package simplifies this step tremendously.</p>
<pre><code class="language-Go">// Payload represents the generic interface for a payload that can be embedded in Messages of the Tangle.
type Payload interface {
    // Type returns the Type of the Payload.
    Type() Type
    
    // Bytes returns a marshaled version of the Payload.
    Bytes() []byte
    
    // String returns a human readable version of the Payload.
    String() string
}
</code></pre>
<p>Finally, we need to create and register our network delay payload type so that it can be properly unmarshalled. </p>
<pre><code class="language-Go">// Type represents the identifier which addresses the network delay Object type.
var Type = payload.NewType(189, ObjectName, func(data []byte) (payload payload.Payload, err error) {
    var consumedBytes int
    payload, consumedBytes, err = FromBytes(data)
    if err != nil {
        return nil, err
    }
    if consumedBytes != len(data) {
        return nil, errors.New(&quot;not all payload bytes were consumed&quot;)
    }
    return
})
</code></pre>
<h3 id="create-the-web-api-endpoints-1"><a class="header" href="#create-the-web-api-endpoints-1">Create The Web API Endpoints</a></h3>
<p>In order to issue a message with our newly created network delay payload, we need to create a web API endpoint. Here we simply create a random <code>ID</code> and the <code>sentTime</code> and then issue a message with <code>issuer.IssuePayload()</code>. This plugin takes care of all the specifics and employs the <code>MessageFactory</code> to, i.a., select tips and sign the message.</p>
<pre><code class="language-Go">webapi.Server.POST(&quot;networkdelay&quot;, broadcastNetworkDelayObject)

func broadcastNetworkDelayObject(c echo.Context) error {
	// generate random id
	rand.Seed(time.Now().UnixNano())
	var id [32]byte
	if _, err := rand.Read(id[:]); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{Error: err.Error()})
	}

	msg, err := issuer.IssuePayload(NewObject(id, time.Now().UnixNano()))
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
	}
	return c.JSON(http.StatusOK, Response{ID: msg.Id().String()})
}
</code></pre>
<h3 id="listen-for-network-delay-payloads"><a class="header" href="#listen-for-network-delay-payloads">Listen for network delay payloads</a></h3>
<p>Every dApp listens for messages from the <em>communication layer</em> and when its data type is detected, takes appropriate action. For us that means listening for network delay payloads and sending messages to our remote logger if we encounter any. Of course in this context, we only want to react to network delay payloads which were issued by our analysis/entry node server. Therefore, matching the message signer's public key with a configured public key lets us only react to the appropriate network delay payloads.</p>
<pre><code class="language-Go">func onReceiveMessageFromMessageLayer(messageID tangle.MessageID) {
    messagelayer.Tangle().Storage.Message(messageID).Consume(func(solidMessage *tangle.Message) {
        messagePayload := solidMessage.Payload()
        if messagePayload.Type() != Type {
            return
        }
    
        // check for node identity
        issuerPubKey := solidMessage.IssuerPublicKey()
        if issuerPubKey != originPublicKey || issuerPubKey == myPublicKey {
            return
        }
        
        networkDelayObject, ok := messagePayload.(*Object)
        if !ok {
            app.LogInfo(&quot;could not cast payload to network delay payload&quot;)
            return
        }
        
        now := clock.SyncedTime().UnixNano()
        
        // abort if message was sent more than 1min ago
        // this should only happen due to a node resyncing
        if time.Duration(now-networkDelayObject.sentTime) &gt; time.Minute {
            app.LogDebugf(&quot;Received network delay message with &gt;1min delay\n%s&quot;, networkDelayObject)
        return
        }
    
        sendToRemoteLog(networkDelayObject, now)
    })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-peering"><a class="header" href="#manual-peering">Manual Peering</a></h1>
<p>Manual peering enables node operators to exchange their nodes' information and let them peer with each other, orthogonal to autopeering. It can be an additional protection against eclipse attacks as the manual peering is completely in the hands of the node operator based on real world trust. Furthermore, it allows to operate nodes without exposing their IP address to the network.
There are two ways to configure the list of known peers of the node:</p>
<ol>
<li>Add known peers using the JSON config file</li>
<li>Add/View/Delete via the web API of the node</li>
</ol>
<h2 id="how-manual-peering-works"><a class="header" href="#how-manual-peering-works">How Manual Peering Works</a></h2>
<p>When the user provides the list of known peers, which looks like a list of IP addresses with ports and public keys of peers,
the node remembers it and starts a background process that is trying to connect with every peer from the list. To establish
the connection with a peer, the other peer should have our local peer in its list of known peers. So the condition for
peers to connect is that they should have each other in their known peers lists. In case of network failure the node
will keep reconnecting with known peers until it succeeds.</p>
<p>In other words, the only thing that users have to do to be connected via manual peering is to 
exchange their IP address with port and public key and set that information to known peers of their nodes and machines will do the rest.</p>
<h2 id="how-to-set-known-peers-via-config-file"><a class="header" href="#how-to-set-known-peers-via-config-file">How to Set Known Peers via Config File</a></h2>
<p>Add the following record to the root of your JSON config file that you are using to run the node.</p>
<h3 id="config-record-example"><a class="header" href="#config-record-example">Config Record Example</a></h3>
<pre><code class="language-json">{
  &quot;manualPeering&quot;: {
    &quot;knownPeers&quot;: [
      {
        &quot;publicKey&quot;: &quot;CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3&quot;,
        &quot;address&quot;: &quot;127.0.0.1:14666&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="config-record-description"><a class="header" href="#config-record-description">Config Record Description</a></h3>
<table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manualPeering.knownPeers.publicKey</code></td><td align="left">Public key of the peer.</td></tr>
<tr><td align="left"><code>manualPeering.knownPeers.address</code></td><td align="left">IP address of the peer's node and its gossip port.</td></tr>
</tbody></table>
<h2 id="how-to-manage-known-peers-via-web-api"><a class="header" href="#how-to-manage-known-peers-via-web-api">How to manage Known Peers via web API</a></h2>
<p>See manual peering API docs <a href="tutorials/./../apis/manual_peering.html">page</a>
for information on how to manage the known peers list via web API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-static-identity"><a class="header" href="#create-a-static-identity">Create a static identity</a></h1>
<p>To create a static GoShimmer identity, you will need to generate a random 32byte autopeering seed. You can use <code>openssl</code> or the <code>rand-seed</code> tool we provide under the GoShimmer folder <code>tools/rand-seed</code>.
For example, by running:</p>
<ul>
<li><code>openssl rand -base64 32</code>: generates a random 32 byte sequence encoded in base64. The output should look like: <code>gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=</code></li>
<li><code>go run main.go</code> under the GoShimmer folder <code>tools/rand-seed</code>: generates a random 32 byte sequence encoded in both base64 and base58. The output is written into the file <code>random-seed.txt</code> and should look like:</li>
</ul>
<pre><code>base64:nQW9MhNSLpIqBUiZe90XI320g680zxFoB1UIK09Acus=
base58:BZx5tDLymckUV5wiswXJtajgQrBEzTBBRR4uGfr1YNGS
</code></pre>
<p>You can now copy one of that strings (together with the encoding type prefix) and paste it into the GoShimmer <code>config.json</code> under the <code>autopeering</code> section:</p>
<pre><code>&quot;autopeering&quot;: {
    &quot;entryNodes&quot;: [
      &quot;2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626&quot;
    ],
    &quot;port&quot;: 14626,
    &quot;seed&quot;:&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
  },
</code></pre>
<p>Or if you are using docker and prefer to set this with a command, you can define the same by changing the GoShimmer docker-compose.yml:</p>
<pre><code class="language-yml">goshimmer:
    network_mode: host
    image: iotaledger/goshimmer
    build:
      context: ./
      dockerfile: Dockerfile
    container_name: iota_goshimmer
    command: &gt;
      --node.enablePlugins=prometheus
      --autopeering.seed=&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
    # Mount volumes:
    # make sure to give read/write access to the folder ./mainnetdb (e.g., chmod -R 777 ./mainnetdb)
    # optionally, you can mount a config.json into the container
    volumes:
      - ./mainnetdb/:/tmp/mainnetdb/:rw
      - ./config.json:/config.json:ro
    # Expose ports:
    # gossip:       - &quot;14666:14666/tcp&quot;
    # autopeering:  - &quot;14626:14626/udp&quot;
    # webAPI:       - &quot;8080:8080/tcp&quot;
    # dashboard:    - &quot;8081:8081/tcp&quot;
    ports:
      - &quot;14666:14666/tcp&quot;
      - &quot;14626:14626/udp&quot;
      - &quot;9311:9311/tcp&quot; # prometheus exporter
      - &quot;8080:8080/tcp&quot; # webApi
      - &quot;8081:8081/tcp&quot; # dashboard
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drng-api"><a class="header" href="#drng-api">dRNG API</a></h1>
<p>All the steps are described in the <a href="https://github.com/iotaledger/drng/wiki">dRNG wiki</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-monitoring-dashboard"><a class="header" href="#setting-up-monitoring-dashboard">Setting up Monitoring Dashboard</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>GoShimmer is shipped with its internal node dashboard that you can reach at <code>127.0.0.1:8081</code> by default. While this dashboard provides some basic metrics information, its main functionality is to provide a graphical interface to interact with your node.</p>
<p>Node operators who wish to have more insights into what is happening within their node have the option to enable a <a href="https://prometheus.io/">Prometheus</a> exporter plugin that gathers important metrics about their node. To visualize these metrics, a <a href="https://grafana.com/oss/grafana/">Grafana Dashboard</a> is utilized.</p>
<h1 id="setting-up-run-goshimmer-from-a-vps"><a class="header" href="#setting-up-run-goshimmer-from-a-vps">Setting up (run GoShimmer from a VPS)</a></h1>
<p>To enable the <strong>Monitoring Dashboard</strong> for a GoShimmer node running from a VPS as described <a href="tutorials/./setup.html">here</a>, you need to carry out some additional steps.</p>
<ol>
<li>Edit <code>docker-compose.yml</code>
TODO</li>
<li>Create Prometheus config.
TODO</li>
<li>Create Grafana config.
TODO</li>
<li>Run <code>docker-compose up</code>.
TODO</li>
</ol>
<h1 id="setting-up-run-goshimmer-from-your-home-machine"><a class="header" href="#setting-up-run-goshimmer-from-your-home-machine">Setting up (run GoShimmer from your home machine)</a></h1>
<p>Depending on how you run your GoShimmer node, there are different ways to set up the <strong>Monitoring Dashboard</strong>.</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>One of the easiest ways to run a node is to use <a href="https://www.docker.com/">Docker</a>. To automatically launch GoShimmer and the Monitoring Dashboard with docker, follow these steps:</p>
<ol>
<li><a href="https://docs.docker.com/get-docker/">Install docker</a>. On Linux, make sure you install both the <a href="https://docs.docker.com/engine/install/">Docker Engine</a> and <a href="https://docs.docker.com/compose/install/">Docker Compose</a>.</li>
<li>Clone the GoShimmer repository.
<pre><code class="language-bash">$ git clone git@github.com:iotaledger/goshimmer.git
</code></pre>
</li>
<li>Create a <code>config.json</code> from the provided <code>config.default.json</code>.
<pre><code class="language-bash">$ cd goshimmer
$ cp config.default.json config.json
</code></pre>
Make sure, that following entry is present in <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>From the root of the repo, start GoShimmer with:
<pre><code class="language-bash">$ docker-compose up
</code></pre>
</li>
</ol>
<p>You should be able to reach the Monitoring Dashboard via browser at <a href="http://localhost:3000">localhost:3000</a>. Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<p>After initial login, you will be prompted to change your password.
You can experiment with the dashboard, change layout, add panels and discover metrics. Your changes will be saved into a Grafana database located in the repo at <code>tools/monitoring/grafana/grafana.db</code>.</p>
<h2 id="binary"><a class="header" href="#binary">Binary</a></h2>
<p>If you run the <a href="https://github.com/iotaledger/goshimmer/releases">released binaries</a>, or build GoShimmer from source, you need to setup Prometheus and Grafana separately, furthermore, you have to configure GoShimmer to export data.</p>
<h3 id="goshimmer-configuration"><a class="header" href="#goshimmer-configuration">GoShimmer Configuration</a></h3>
<ol>
<li>Make sure that the <code>prometheus.bindAddress</code> config parameter is set in your <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>Make sure, that the <code>prometheus</code> plugin is enabled in your <code>config.json</code>:
<pre><code class="language-json">&quot;node&quot;: {
  &quot;disablePlugins&quot;: [],
  &quot;enablePlugins&quot;: [&quot;prometheus&quot;]
},
</code></pre>
</li>
</ol>
<h3 id="install-and-configure-prometheus"><a class="header" href="#install-and-configure-prometheus">Install and Configure Prometheus</a></h3>
<p>First, we take a look on how to configure and run Prometheus as a standalone application. Then, we setup a Linux system service that automatically runs Prometheus in the background.</p>
<h4 id="prometheus-as-standalone-app"><a class="header" href="#prometheus-as-standalone-app">Prometheus as Standalone App</a></h4>
<ol>
<li><a href="https://prometheus.io/download/">Download</a> the latest release of Prometheus for your system.</li>
<li>Unpack the downloaded file:
<pre><code class="language-bash">$ tar xvfz prometheus-*.tar.gz
$ cd prometheus-*
</code></pre>
</li>
<li>Create a <code>prometheus.yml</code> in the unpacked directory with the following content:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
</li>
<li>Start Prometheus from the unpacked folder:
<pre><code class="language-bash"># By default, Prometheus stores its database in ./data (flag --storage.tsdb.path).
$ ./prometheus --config.file=prometheus.yml
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<h4 id="prometheus-as-a-system-service-linux"><a class="header" href="#prometheus-as-a-system-service-linux">Prometheus as a System Service (Linux)</a></h4>
<p>Note: you have to have root privileges with your user to carry out the following steps.</p>
<ol>
<li>Create a Prometheus user, directories, and set this user as the owner of those directories.
<pre><code>$ sudo useradd --no-create-home --shell /bin/false prometheus
$ sudo mkdir /etc/prometheus
$ sudo mkdir /var/lib/prometheus
$ sudo chown prometheus:prometheus /etc/prometheus
$ sudo chown prometheus:prometheus /var/lib/prometheus
</code></pre>
</li>
<li>Download Prometheus source, extract and rename.
<pre><code>$ wget https://github.com/prometheus/prometheus/releases/download/v2.19.1/prometheus-2.19.1.linux-amd64.tar.gz
$ tar xvfz prometheus-2.19.1.linux-amd64.tar.gz
$ mv prometheus-2.19.1.linux-amd64.tar.gz prometheus-files
</code></pre>
</li>
<li>Copy Prometheus binaries to <code>/bin</code> and change their ownership
<pre><code>$ sudo cp prometheus-files/prometheus /usr/local/bin/
$ sudo cp prometheus-files/promtool /usr/local/bin/
$ sudo chown prometheus:prometheus /usr/local/bin/prometheus
$ sudo chown prometheus:prometheus /usr/local/bin/promtool
</code></pre>
</li>
<li>Copy Prometheus console libraries to <code>/etc</code> and change their ownership.
<pre><code>$ sudo cp -r prometheus-files/consoles /etc/prometheus
$ sudo cp -r prometheus-files/console_libraries /etc/prometheus
$ sudo chown -R prometheus:prometheus /etc/prometheus/consoles
$ sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries
</code></pre>
</li>
<li>Create Prometheus config file, define targets.
To create and open up the config file:
<pre><code>$ sudo nano /etc/prometheus/prometheus.yml
</code></pre>
Put the following content into the file:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
Save and exit the editor.</li>
<li>Change ownership of the config file.
<pre><code>$ sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
</code></pre>
</li>
<li>Create a Prometheus service file.
<pre><code>$ sudo nano /etc/systemd/system/prometheus.service
</code></pre>
Copy the following content into the file:
<pre><code class="language-yaml">[Unit]
Description=Prometheus GoShimmer Server
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
    --config.file /etc/prometheus/prometheus.yml \
    --storage.tsdb.path /var/lib/prometheus/ \
    --web.console.templates=/etc/prometheus/consoles \
    --web.console.libraries=/etc/prometheus/console_libraries

[Install]
WantedBy=multi-user.target
</code></pre>
</li>
<li>Reload <code>systemd</code> service to register the prometheus service.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start prometheus
</code></pre>
</li>
<li>Check if the service is running.
<pre><code>$ sudo systemctl status prometheus
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<p>+1. When you want to stop the service, run:</p>
<pre><code>$ sudo systemctl stop prometheus
</code></pre>
<p>Prometheus now collects metrics from your node, but we need to setup Grafana to visualize the collected data.</p>
<h3 id="install-and-configure-grafana"><a class="header" href="#install-and-configure-grafana">Install and configure Grafana</a></h3>
<p>Head over to <a href="https://grafana.com/docs/grafana/latest/installation/">Grafana Documentation</a> and install Grafana. For Linux, the OSS Release is recommended.</p>
<h4 id="grafana-as-standalaon-app"><a class="header" href="#grafana-as-standalaon-app">Grafana as Standalaon App</a></h4>
<p>Depending on where you install Grafana from, the configuration directories will change. For clarity, we will proceed with the binary install here.</p>
<ol>
<li>
<p><a href="https://grafana.com/grafana/download">Download Grafana</a> binary and extract it into a folder.
For example:</p>
<pre><code class="language-bash">$ wget https://dl.grafana.com/oss/release/grafana-7.0.4.linux-amd64.tar.gz
$ tar -zxvf grafana-7.0.4.linux-amd64.tar.gz
</code></pre>
</li>
<li>
<p>We will need couple files from the GoShimmer repository. Here we suppose, that you have the repository directory <code>goshimmer</code> on the same level as the extracted <code>grafana-7.0.4</code> directory:</p>
<pre><code>├── grafana-7.0.4   
│   ├── bin       
│   ├── conf         
│   ├── LICENSE   
│   ├── NOTICE.md
│   ├── plugins-bundled
│   ├── public 
│   ├── README.md
│   ├── scripts 
│   └── VERSIO
├── goshimmer               
│   ├── CHANGELOG.md
│   ├── client             
│   ├── config.default.json
    ...
</code></pre>
<p>We copy a couple configuration files from the repository into Grafana's directory:</p>
<pre><code>$ cp -R goshimmer/tools/monitoring/grafana/dashboards/local_dashboard.json grafana-7.0.4/public/dashboards/
$ cp goshimmer/tools/monitoring/grafana/provisioning/datasources/datasources.yaml grafana-7.0.4/conf/provisioning/datasources/datasources.yaml
$ cp goshimmer/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml grafana-7.0.4/conf/provisioning/dashboards/dashboards.yaml
</code></pre>
</li>
<li>
<p>Run Grafana.</p>
<pre><code>$ cd grafana-7.0.4/bin
$ ./grafana-server
</code></pre>
</li>
<li>
<p>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</p>
</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-as-a-system-service-linux"><a class="header" href="#grafana-as-a-system-service-linux">Grafana as a System Service (Linux)</a></h4>
<p>Instead of running the <code>grafana-server</code> app each time we can create a service that runs in the background.</p>
<p>When you install Grafana from</p>
<ul>
<li><a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-from-apt-repository">APT repository</a> or <code>.deb</code> <a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-deb-package">package</a> (Ubuntu or Debian),</li>
<li><a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-from-yum-repository">YUM repository</a> or <code>.rpm</code> <a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-with-rpm">package</a> (CentOS, Fedora, OpenSuse, RedHat),</li>
</ul>
<p>then Grafana is configured to run as a system service without any modification. All you need to do is copy config files from the GoShimmer repository:</p>
<ol>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/datasources/datasources.yaml">datasource yaml config</a> to <code>/etc/grafana</code>:
(assuming you are at the root of the cloned GoShimmer repository)
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/datasources/datasources.yaml /etc/grafana/provisioning/datasources
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml">dashboard yaml config</a> to <code>/etc/grafana</code>:
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml /etc/grafana/provisioning/dashboards
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">GoShimmer Local Metrics</a> dashboard to <code>/var/lib/grafana/</code>:
<pre><code>$ sudo cp -R tools/monitoring/grafana/dashboards /var/lib/grafana/
</code></pre>
</li>
<li>Reload daemon and start Grafana.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start grafana-server
</code></pre>
</li>
<li>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-config-via-gui"><a class="header" href="#grafana-config-via-gui">Grafana Config via GUI</a></h4>
<p>If you successfully installed Grafana and would like to set it up using its graphical interface, here are the steps you need to take:</p>
<ol>
<li>Run Grafana.</li>
<li>Open <a href="http://localhost:3000">localhost:3000</a> in a browser window.
Default login credentials are:
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
</li>
<li>On the left side, open <strong>Configuration -&gt; Data Sources</strong>. Click on <strong>Add data source</strong> and select <strong>Prometheus</strong> core plugin.</li>
<li>Fill the following fields:
<ul>
<li><code>URL</code>: http://localhost:9090</li>
<li><code>Scrape interval</code>: 5s</li>
</ul>
</li>
<li>Click on <strong>Save &amp; Test</strong>. If you have a running Prometheus server, everything should turn green. If the URL can't be reached, try changing the <strong>Access</strong> field to <code>Browser</code>.</li>
<li>On the left side panel, click on <strong>Dashboards -&gt; Manage</strong>.</li>
<li>Click on <strong>Import</strong>. Paste the content of <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a> in the <strong>Import via panel json</strong>, or download the life and use the <strong>Upload .json file</strong> option.</li>
<li>Now you can open <strong>GoShimmer Local Metrics</strong> dashboard under <strong>Dashboards</strong>. Don't forget to start your node and run Prometheus!</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-send-transaction"><a class="header" href="#how-to-send-transaction">How to send transaction</a></h1>
<p>The simplest and easiest way for creating transaction is to use ready solution, such us GUI wallets: <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a> and <a href="https://github.com/Dr-Electron/ElectricShimmer">Dr-Electron ElectricShimmer</a>
or command line wallet <a href="tutorials/./wallet.html">Command Line Wallet</a>. However, there is also an option to create a transaction directly with Go client library, which will be main focus of this tutorial.</p>
<p>For code examples you can go directly to <a href="tutorials/send_transaction.html#code-examples">Code examples</a>.</p>
<h2 id="funds"><a class="header" href="#funds">Funds</a></h2>
<p>To create a transaction, firstly we need to be in possession of tokens. We can receive them from other network users or request them from the faucet. For more details on how to request funds, see <a href="tutorials/./request_funds.html">this</a> tutorial.</p>
<h2 id="preparing-transaction"><a class="header" href="#preparing-transaction">Preparing transaction</a></h2>
<p>A transaction is built from two parts: a transaction essence, and the unlock blocks. The transaction essence contains, among other information, the amount, the origin and where the funds should be sent. The unlock block makes sure that only the owner of the funds being transferred is allowed to successfully perform this transaction.</p>
<h3 id="seed"><a class="header" href="#seed">Seed</a></h3>
<p>In order to send funds we need to have a private key that can be used to prove that we own the funds and consequently unlock them. If you want to use an existing seed from one of your wallets, just use the backup seed showed during a wallet creation. With this, we can decode the string with the <code>base58</code> library and create the <code>seed.Seed</code> instance. That will allow us to retrieve the wallet addresses (<code>mySeed.Address()</code>) and the corresponding private and public keys (<code>mySeed.KeyPair()</code>).</p>
<pre><code class="language-Go">seedBytes, _ := base58.Decode(&quot;BoDjAh57RApeqCnoGnHXBHj6wPwmnn5hwxToKX5PfFg7&quot;) // ignoring error
mySeed := walletseed.NewSeed(seedBytes)
</code></pre>
<p>Another option is to generate a completely new seed and addresses.</p>
<pre><code class="language-Go">mySeed := walletseed.NewSeed()
fmt.Println(&quot;My secret seed:&quot;, myWallet.Seed.String())
</code></pre>
<p>We can obtain the addresses from the seed by providing their index, in our example it is <code>0</code>. Later we will use the same index to retrieve the corresponding keys.</p>
<pre><code class="language-Go">myAddr := mySeed.Address(0)
</code></pre>
<p>Additionally, we should make sure that unspent outputs we want to use are already confirmed.
If we use a wallet, this information will be available along with the wallet balance. We can also use the dashboard and look up for our address in the explorer. To check the confirmation status with Go use <code>PostAddressUnspentOutputs()</code> API method to get the outputs and check their inclusion state.</p>
<pre><code class="language-Go">resp, _ := goshimAPI.PostAddressUnspentOutputs([]string{myAddr.Base58()}) // ignoring error
for _, output := range resp.UnspentOutputs[0].Outputs {
		fmt.Println(&quot;outputID:&quot;, output.Output.OutputID.Base58, &quot;confirmed:&quot;, output.InclusionState.Confirmed)
}
</code></pre>
<h3 id="transaction-essence"><a class="header" href="#transaction-essence">Transaction essence</a></h3>
<p>The transaction essence can be created with:
<code>NewTransactionEssence(version, timestamp, accessPledgeID, consensusPledgeID, inputs, outputs)</code>
We need to provide the following arguments:</p>
<pre><code class="language-Go">var version TransactionEssenceVersion
var timestamp time.Time
var accessPledgeID identity.ID
var consensusPledgeID identity.ID
var inputs ledgerstate.Inputs
var outputs ledgerstate.Outputs
</code></pre>
<h4 id="version-and-timestamp"><a class="header" href="#version-and-timestamp">Version and timestamp</a></h4>
<p>We use <code>0</code> for a version and provide the current time as a timestamp of the transaction.</p>
<pre><code class="language-Go">version = 0
timestamp = time.Now()
</code></pre>
<h4 id="mana-pledge-ids"><a class="header" href="#mana-pledge-ids">Mana pledge IDs</a></h4>
<p>We also need to specify the nodeID to which we want to pledge the access and consensus mana. We can use two different nodes for each type of mana.
We can retrieve an identity instance by converting base58 encoded node ID as in the following example:</p>
<pre><code class="language-Go">pledgeID, err := mana.IDFromStr(base58encodedNodeID)
accessPledgeID = pledgeID
consensusPledgeID = pledgeID
</code></pre>
<p>or discard mana by pledging it to the empty nodeID:</p>
<pre><code class="language-Go">accessPledgeID = identity.ID{}
consensusPledgeID = identity.ID{}
</code></pre>
<h4 id="inputs"><a class="header" href="#inputs">Inputs</a></h4>
<p>As inputs for the transaction we need to provide unspent outputs.
To get unspent outputs of the address we can use the following example.</p>
<pre><code class="language-Go">resp, _ := goshimAPI.GetAddressUnspentOutputs(myAddr.Base58())  // ignoring error
// iterate over unspent outputs of an address
for _, output := range resp2.Outputs {
    var out ledgerstate.Output
    out, _ = output.ToLedgerstateOutput()  // ignoring error
}
</code></pre>
<p>To check the available output's balance use <code>Balances()</code> method and provide the token color. We use the default, IOTA color.</p>
<pre><code class="language-Go">balance, colorExist := out.Balances().Get(ledgerstate.ColorIOTA)
fmt.Println(balance, exist)
</code></pre>
<p>or iterate over all colors and balances:</p>
<pre><code class="language-Go">out.Balances().ForEach(func(color ledgerstate.Color, balance uint64) bool {
			fmt.Println(&quot;Color:&quot;, color.Base58())
			fmt.Println(&quot;Balance:&quot;, balance)
			return true
		})
</code></pre>
<p>At the end we need to wrap the selected output to match the interface of the inputs:</p>
<pre><code class="language-Go">inputs = ledgerstate.NewInputs(ledgerstate.NewUTXOInput(out))
</code></pre>
<h4 id="outputs"><a class="header" href="#outputs">Outputs</a></h4>
<p>To create the most basic type of output use
<code>ledgerstate.NewSigLockedColoredOutput()</code> and provide it with a balance and destination address. Important is to provide the correct balance value. The total balance with the same color has to be equal for input and output.</p>
<pre><code class="language-Go">balance := ledgerstate.NewColoredBalances(map[ledgerstate.Color]uint64{
							ledgerstate.ColorIOTA: uint64(100),
						})
outputs := ledgerstate.NewOutputs(ledgerstate.NewSigLockedColoredOutput(balance, destAddr.Address()))
</code></pre>
<p>The same as in case of inputs we need to adapt it with <code>ledgerstate.NewOutputs()</code> before passing to the <code>NewTransactionEssence</code> function.</p>
<h3 id="signing-transaction"><a class="header" href="#signing-transaction">Signing transaction</a></h3>
<p>After preparing the transaction essence, we should sign it and put the signature to the unlock block part of the transaction.
We can retrieve private and public key pairs from the seed by providing it with indexes corresponding to the addresses that holds the unspent output that we want to use in our transaction.</p>
<pre><code class="language-Go">kp := *mySeed.KeyPair(0)
txEssence := NewTransactionEssence(version, timestamp, accessPledgeID, consensusPledgeID, inputs, outputs)
</code></pre>
<p>We can sign the transaction in two ways: with ED25519 or BLS signature. The wallet seed library uses <code>ed25519</code> package and keys, so we will use <code>Sign()</code> method along with <code>ledgerstate.ED25519Signature</code> constructor to sign the transaction essence bytes.
Next step is to create the unlock block from our signature.</p>
<pre><code class="language-Go">signature := ledgerstate.NewED25519Signature(kp.PublicKey, kp.PrivateKey.Sign(txEssence.Bytes())
unlockBlock := ledgerstate.NewSignatureUnlockBlock(signature)
</code></pre>
<p>Putting it all together, now we are able to create transaction with previously created transaction essence and adapted unlock block.</p>
<pre><code class="language-Go">tx := ledgerstate.NewTransaction(txEssence, ledgerstate.UnlockBlocks{unlockBlock})
</code></pre>
<h2 id="sending-transaction"><a class="header" href="#sending-transaction">Sending transaction</a></h2>
<p>There are two web API methods that allows us to send the transaction:
<code>PostTransaction()</code> and <code>IssuePayload()</code>. The second one is a more general method that sends the attached payload. We are going to use the first one that will additionally check the transaction validity before issuing and wait with sending the response until the message is booked.
The method accepts a byte array, so we need to call <code>Bytes()</code>.
If the transaction will be booked without any problems, we should be able to get the transaction ID from the API response.</p>
<pre><code class="language-Go">resp, err := goshimAPI.PostTransaction(tx.Bytes())
if err != nil {
	return
}
fmt.Println(&quot;Transaction issued, txID:&quot;, resp.TransactionID)
</code></pre>
<h2 id="code-examples"><a class="header" href="#code-examples">Code examples</a></h2>
<h3 id="creating-the-transaction"><a class="header" href="#creating-the-transaction">Creating the transaction</a></h3>
<p>Constructing a new <code>ledgerstate.Transaction</code>. </p>
<pre><code class="language-go">import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;time&quot;

	&quot;github.com/iotaledger/goshimmer/client&quot;
	walletseed &quot;github.com/iotaledger/goshimmer/client/wallet/packages/seed&quot;
	&quot;github.com/iotaledger/goshimmer/packages/ledgerstate&quot;
	&quot;github.com/iotaledger/goshimmer/packages/mana&quot;
)

func buildTransaction() (tx *ledgerstate.Transaction, err error) {
	// node to pledge access mana.
	accessManaPledgeIDBase58 := &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
	accessManaPledgeID, err := mana.IDFromStr(accessManaPledgeIDBase58)
	if err != nil {
		return
	}

	// node to pledge consensus mana.
	consensusManaPledgeIDBase58 := &quot;1HzrfXXWhaKbENGadwEnAiEKkQ2Gquo26maDNTMFvLdE3&quot;
	consensusManaPledgeID, err := mana.IDFromStr(consensusManaPledgeIDBase58)
	if err != nil {
		return
	}
     
        /**
        N.B to pledge mana to the node issuing the transaction, use empty pledgeIDs.
        emptyID := identity.ID{}
        accessManaPledgeID, consensusManaPledgeID := emptyID, emptyID
        **/      

	// destination address.
	destAddressBase58 := &quot;your_base58_encoded_address&quot;
	destAddress, err := ledgerstate.AddressFromBase58EncodedString(destAddressBase58)
	if err != nil {
		return
	}

	// output to consume.
	outputIDBase58 := &quot;your_base58_encoded_outputID&quot;
	out, err := ledgerstate.OutputIDFromBase58(outputIDBase58)
	if err != nil {
		return
	}
	inputs := ledgerstate.NewInputs(ledgerstate.NewUTXOInput(out))

	// UTXO output.
	output := ledgerstate.NewSigLockedColoredOutput(ledgerstate.NewColoredBalances(map[ledgerstate.Color]uint64{
		ledgerstate.ColorIOTA: uint64(1337),
	}), destAddress)
	outputs := ledgerstate.NewOutputs(output)

	// build tx essence.
	txEssence := ledgerstate.NewTransactionEssence(0, time.Now(), accessManaPledgeID, consensusManaPledgeID, inputs, outputs)

	// sign.
	seed := walletseed.NewSeed([]byte(&quot;your_seed&quot;))
	kp := seed.KeyPair(0)
	sig := ledgerstate.NewED25519Signature(kp.PublicKey, kp.PrivateKey.Sign(txEssence.Bytes()))
	unlockBlock := ledgerstate.NewSignatureUnlockBlock(sig)

	// build tx.
	tx = ledgerstate.NewTransaction(txEssence, ledgerstate.UnlockBlocks{unlockBlock})
	return
}
</code></pre>
<h3 id="post-the-transaction"><a class="header" href="#post-the-transaction">Post the transaction</a></h3>
<p>There are 2 available options to post the created transaction.</p>
<ul>
<li>GoShimmer client lib</li>
<li>Web API</li>
</ul>
<h4 id="post-via-client-lib"><a class="header" href="#post-via-client-lib">Post via client lib</a></h4>
<pre><code class="language-go">func postTransactionViaClientLib() (res string , err error) {
	// connect to goshimmer node
	goshimmerClient := client.NewGoShimmerAPI(&quot;http://127.0.0.1:8080&quot;, client.WithHTTPClient(http.Client{Timeout: 60 * time.Second}))

	// build tx from previous step
	tx, err := buildTransaction()
	if err != nil {
		return
	}

	// send the tx payload.
	res, err = goshimmerClient.PostTransaction(tx.Bytes())
	if err != nil {
		return
	}
	return
}
</code></pre>
<h4 id="post-via-web-api"><a class="header" href="#post-via-web-api">Post via web API</a></h4>
<p>First, get the transaction bytes.</p>
<pre><code class="language-go">// build tx from previous step
tx, err := buildTransaction()
if err != nil {
    return
}
bytes := tx.Bytes()

// print bytes
fmt.Println(string(bytes))
</code></pre>
<p>Then, post the bytes.</p>
<pre><code class="language-shellscript">curl --location --request POST 'http://localhost:8080/ledgerstate/transactions' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;tx_bytes&quot;: &quot;bytes...&quot;
}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-design"><a class="header" href="#implementation-design">Implementation design</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-driven-model"><a class="header" href="#event-driven-model">Event driven model</a></h1>
<p>Event driven model is popular approach often used for example in GUI applications, where a program is waiting for some external event to take place (e.g. mouse click) in order to perform some action.
In case of GoShimmer there is no GUI, however it applies this architecture approach as it's really flexible and is used to handle communication with other nodes and other internal parts. 
In GoShimmer some of those events can be e.g. arrival of new tangle message, peering request or plugin start. 
When an event is triggered, an event handler (or a collection of handlers) is executed and the state of the application is updated as necessary.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary:</a></h2>
<p>At first let's define some terms used further to avoid misunderstandings:</p>
<ul>
<li>
<p>Event - represents the type of event (e.g. new message or peering request) as well as set of handlers and trigger functions. Each type of event is separately defined 
which means that events are independent of each other - each event has its own set of handlers and is triggered separately.</p>
</li>
<li>
<p>Event handler (callback) - is a function that is executed when an event of given type occurs. An event handler can accept multiple arguments (e.g. message ID or plugin) so that it can perform appropriate actions.
Every handler must accept the same set of parameters. Each event has a different set of handlers (there can be multiple handlers) that are executed when the event is triggered.</p>
</li>
<li>
<p>Trigger - is a method that triggers execution of event handlers with given parameter values.</p>
</li>
</ul>
<h2 id="creating-new-event-with-custom-callbacks"><a class="header" href="#creating-new-event-with-custom-callbacks">Creating new event with custom callbacks</a></h2>
<p>Below are the steps that show the example code necessary to create a custom event, attach a handler and trigger the event. </p>
<ol>
<li>Create a function that will call event handlers (handler caller) for a specific event. 
Each event has only one handler caller. It enforces that all handlers for the event must share the same interface, because the caller will pass a fixed set of arguments of specific types to handler function. 
It's not possible to pass different number of arguments or types to the handler function. 
Callers for all events must also share the same interface - the first argument represents the handler function that will be called represented by a generic argument.
Further arguments represent parameters that will be passed to the handler during execution. Below are example callers that accept one and two parameters respectively. 
More arguments can be passed in similar manner. </li>
</ol>
<pre><code class="language-go">func singleArgCaller(handler interface{}, params ...interface{}) {
    handler.(func (*Plugin))(params[0].(*Plugin))
}

func twoArgsCaller(handler interface{}, params ...interface{}) {
    handler.(func(*peer.Peer, error))(params[0].(*peer.Peer), params[1].(error))
}
</code></pre>
<p><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - this code seems a little complicated, so to make things simpler we will divide into smaller parts and explain each:</p>
<ul>
<li><code>handler.(func (*Plugin))</code> (A) - this part does type-cast the handler from generic type onto type of desired, specific function type - in this case it's a function that accepts <code>*Plugin</code> as its only parameter.</li>
<li><code>params[0].(*Plugin)</code> (B)- similarly to previous part, first element of parameter slice is type-casted onto <code>*Plugin</code> type, so that it matches the handler function interface.</li>
<li><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - the whole expression calls the type-casted handler function with the type-casted parameter value. We can also write this as <code>A(B)</code> to make things simpler.</li>
</ul>
<p>The above explanation also allows a better understanding of why all handlers must share the same interface - handler caller passes fixed number of parameters and does type-casting of arguments onto specific types.</p>
<ol start="2">
<li>Next, a new event object needs to be created. We pass the handler caller as an argument, which is saved inside the object to be called when the event is triggered.</li>
</ol>
<pre><code class="language-go">import &quot;github.com/iotaledger/hive.go/events&quot;

ThisEvent := events.NewEvent(singleArgCaller)
</code></pre>
<ol start="3">
<li>After creating the event, handlers (or callbacks) can be attached to it. An event can have multiple callbacks, however they all need to share the same interface. 
One thing to note, is that functions are not passed directly - first they are wrapped into a <code>events.Closure</code> object like in the example below. </li>
</ol>
<pre><code class="language-go">ThisEvent.Attach(events.NewClosure(func (arg *Plugin) {
    // do something
}))
</code></pre>
<ol start="4">
<li>In order to trigger the event with some parameters we need to run the <code>.Trigger</code> method on the event object with parameters that handler functions will receive:</li>
</ol>
<pre><code class="language-go">somePlugin Plugin
ThisEvent.Trigger(&amp;somePlugin)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-of-packages-and-plugins"><a class="header" href="#dependency-of-packages-and-plugins">Dependency of packages and plugins</a></h1>
<p>In GoShimmer, new features are added through the <a href="implementation_design/plugin.html">plugin system</a>.
When creating a new plugin, it must implement an interface shared with all other plugins, so it's easy to add new
plugins and change their internal implementation without worrying about compatibility. 
Because of this, to make the code clean and easily manageable the plugin's internal logic has to be implemented in a different package.
This is an example of an <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter design pattern</a> that is often used in plugin systems.
It's really useful in a prototype software like GoShimmer, because it's possible to easily switch between different implementations 
and internal interfaces just by using a different plugin, without having to rewrite the code using it. </p>
<p>When creating a new plugin, the logic should be implemented in a separate package stored in the <code>packages/</code> directory. 
The package should contain all struct and interface definitions used, as well as the specific logic. 
It should not reference any <code>plugin</code> packages from the <code>plugin/</code> directory as this could lead to circular dependencies between packages.</p>
<p>There are no special interfaces or requirements that packages in the <code>packages/</code> directory are forced to follow. However, they should be independent of other packages if possible, 
to avoid problems due to changing interfaces in other packages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-system"><a class="header" href="#plugin-system">Plugin system</a></h1>
<p>GoShimmer is a complex application that is used in a research environment where requirements often changed and new ideas arise. 
The Plugin system allows to quickly and easily add and remove modules that need to be started. However, one thing that might be non-intuitive about the use of plugins is that it's taken to an extreme - everything is run through plugins. 
The only code that is not executed through a plugin system is the code responsible for configuring and starting the plugins.
All new future features added to the GoShimmer must be added by creating a new plugin. </p>
<h2 id="plugin-structure"><a class="header" href="#plugin-structure">Plugin structure</a></h2>
<p><code>Plugin</code> structure is defined as following.</p>
<pre><code class="language-go">type Plugin struct {
	Node   *Node
	Name   string
	Status int
	Events pluginEvents
	wg     *sync.WaitGroup
}
</code></pre>
<p>Below is a brief description of each field: </p>
<ul>
<li><code>Node</code> - contains a pointer to <code>Node</code> object which contains references to all the plugins and node-level logger. #TODO: figure out why it is there - not really used anywhere</li>
<li><code>Name</code> - descriptive name of the plugin.</li>
<li><code>Status</code> - flag indicating whether plugin is enabled or disabled.</li>
<li><code>Events</code> - structure containing events used to properly deploy the plugin. Details described below.</li>
<li><code>wg</code> - a private field containing WaitGroup. #TODO: figure out why it is there - not really used anywhere</li>
</ul>
<h2 id="plugin-events"><a class="header" href="#plugin-events">Plugin events</a></h2>
<p>Each plugin defines 3 events: <code>Init</code>, <code>Configure</code>, <code>Run</code>. 
Those events are triggered during different stages of node startup, but the plugin doesn't have to define handlers for all of those events in order to do what it's been designed for.
Execution order and purpose of each event is described below: </p>
<ol>
<li><code>Init</code> - is triggered almost immediately after a node is started. It's used in plugins that are critical for GoShimmer such as reading config file or initializing global logger. Most plugins don't need to use this event.</li>
<li><code>Configure</code> - this event is used to configure the plugin before it is started. It is used to define events related to internal plugin logic or initialize objects used by the plugin. </li>
<li><code>Run</code> - this event is triggered as the last one. The event handler function contains the main logic of the plugin. 
For many plugins, the event handler function creates a separate worker that works in the background, so that the handler function for one plugin can finish and allow other plugins to be started.</li>
</ol>
<p>Each event could potentially have more than one handler, however currently all existing plugins follow a convention where each event has only one handler.</p>
<p>It is important to note that each event is triggered for all plugins sequentially, so that the event <code>Init</code> is triggered for all plugins, then <code>Configure</code> is triggered for all plugins and finally <code>Run</code>. 
Such order is crucial, because some plugins rely on other plugins' initialization or configuration. The order in which plugins are initialized, configured and run is also important and this is described below. </p>
<p>Handler functions for all plugin events share the same interface, so they could potentially be used interchangeably. Sample handler functions look like this:</p>
<pre><code class="language-go">func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) { 
    // run plugin	
}
</code></pre>
<p>The handler functions receive one argument of type <code>*Plugin</code>. The code responsible for triggering those events passes a pointer to the plugin object itself. 
The object needs to be passed so that the handler function can access plugin fields (e.g. plugin name to configure logger).</p>
<h2 id="creating-new-plugin"><a class="header" href="#creating-new-plugin">Creating new plugin</a></h2>
<p>A plugin object can be created by calling the <code>node.NewPlugin</code> method. 
The method creates and returns a new plugin object, as well as registers it so that GoShimmer knows the plugin is available.
It accepts the following arguments:</p>
<ul>
<li><code>name string</code> - plugin name.</li>
<li><code>status int</code> - flag indicating whether plugin is enabled or disabled by default. This can be overridden by enabling/disabling the plugin in the external configuration file. Possible values: <code>node.Enabled</code>, <code>node.Disabled</code>. </li>
<li><code>callbacks ...Callback</code> - list of event handler functions. The method will correctly create a plugin when passing up to 2 callbacks. Note: <code>type Callback = func(plugin *Plugin)</code>, which is a raw function type without being wrapped in <code>events.Closure</code>.</li>
</ul>
<p>There is a couple of ways that the method can be called, depending on which plugin events need to be configured. </p>
<ul>
<li>Define <code>Configure</code> and <code>Run</code> event handlers. It's the most common usage that plugins currently use. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
</code></pre>
<ul>
<li>Define only <code>Configure</code> event. It's used for plugins that are used to configure objects used (or managed) by other plugins, such as creating API endpoints. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure)
</code></pre>
<ul>
<li>Define a plugin without <code>Configure</code> or <code>Run</code> event handlers. This is used to create plugins that perform some action when the <code>Init</code> event is triggered.</li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled)
</code></pre>
<p>However, the <code>Init</code> event handler cannot be attached using the <code>node.NewPlugin</code> method. 
In order to specify this handler, plugin creator needs to attach it manually to the event, for example inside the package's <code>init()</code> method in the file containing the rest of the plugin definition.</p>
<pre><code class="language-go">func init() {
	plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
		// do something
	}))
}
</code></pre>
<p>It's important to note, that the <code>node.NewPlugin</code> accepts handler functions in a raw format, that is, without being wrapped by the <code>events.Closure</code> object as the method does the wrapping inside.
However, when attaching the <code>Init</code> event handler manually, it must be wrapped by the <code>events.Closure</code> object. </p>
<p>It's crucial that each plugin is created only once and <code>sync.Once</code> class is used to guarantee that. Contents of a file containing sample plugin definition is presented. All plugins follow this format.</p>
<pre><code class="language-go">const PluginName = &quot;SamplePlugin&quot;

var (
	// plugin is the plugin instance of the new plugin plugin.
	plugin     *node.Plugin
	pluginOnce sync.Once
)

// Plugin gets the plugin instance.
func Plugin() *node.Plugin {
	pluginOnce.Do(func() {
		plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
	})
	return plugin
}

// Handler functions
func init() {
    plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
        // do something
    }))
}
func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) {
    // run stuff	
}
</code></pre>
<h2 id="running-new-plugin"><a class="header" href="#running-new-plugin">Running new plugin</a></h2>
<p>In order to correctly add a new plugin to GoShimmer, apart from defining it, it must also be passed to the <code>node.Run</code> method. 
Because there are plenty of plugins, in order to improve readability and make managing plugins easier, they are grouped into separate wrappers passed to the <code>node.Run</code> method. 
When adding a new plugin, it must be added into one of those groups, or a new group must be created.</p>
<pre><code class="language-go">node.Run(
    plugins.Core,
    plugins.Research,
    plugins.UI,
    plugins.WebAPI,
)
</code></pre>
<p>You can add a plugin simply by calling the <code>Plugin()</code> method of the newly created plugin and passing the argument further. An example group definition is presented below. When it's added, the plugin is correctly added and will be run when GoShimmer starts.</p>
<pre><code class="language-go">var Core = node.Plugins(
    banner.Plugin(),
    newPlugin.Plugin(),
    // other plugins ommited 
)
</code></pre>
<h2 id="background-workers"><a class="header" href="#background-workers">Background workers</a></h2>
<p>In order to run plugins beyond the scope of the short-lived <code>Run</code> event handler, possibly multiple <code>daemon.BackgroundWorker</code> instances can be started inside the handler function. 
This allows the <code>Run</code> event handler to finish quickly, and the plugin logic can continue running concurrently in a separate goroutine. </p>
<p>Background worker can be started by running the <code>daemon.BackgroundWorker</code> method, which accepts following arguments:</p>
<ul>
<li><code>name string</code> - background worker name</li>
<li><code>handler WorkerFunc</code> - long-running function that will be started in its own goroutine. It accepts a single argument of type <code>&lt;-chan struct{}</code>. When something is sent to that channel, the worker will shut down. Note: <code>type WorkerFunc = func(shutdownSignal &lt;-chan struct{})</code></li>
<li><code>order ...int</code> - value used to define in which shutdown order this particular background worker must be shut down (higher = earlier).
The parameter can either accept one or zero values, more values will be ignored. When passing zero values, default value of <code>0</code> is assumed.
Values are normalized in the <code>github.com/iotaledger/goshimmer/packages/shutdown</code> package, and it should be used instead of passing integers manually. 
Correct shutdown order is as important as correct start order, because different plugins depend on others working correctly, so when one plugin shuts down too soon, other plugins may run into errors, crash and leave an incorrect state. </li>
</ul>
<p>An example code for creating a background worker: </p>
<pre><code class="language-go">func start(shutdownSignal &lt;-chan struct{}) {
	// long-running function
	// possibly start goroutines here
	// wait for shutdown signal
    &lt;-shutdownSignal
}

if err := daemon.BackgroundWorker(backgroundWorkerName, start, shutdown.PriorityGossip); err != nil {
	log.Panicf(&quot;Failed to start as daemon: %s&quot;, err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration parameters</a></h1>
<h2 id="customizing-configuration"><a class="header" href="#customizing-configuration">Customizing configuration</a></h2>
<p>Users can pass configuration parameters in two ways when running GoShimmer. One way is through a JSON configuration file and another way is through command line arguments.
Settings passed through command line arguments take precedence. The JSON configuration file is structured as a JSON object containing parameters and their values.
Parameters are grouped into embedded objects containing parameters for a single plugin or functionality. There is no limit on how deep the configuration object may be embedded.
For example, the config below contains example parameters for the PoW plugin.</p>
<pre><code class="language-json">{
  &quot;pow&quot;: {
    &quot;difficulty&quot;: 2,
    &quot;numThreads&quot;: 1,
    &quot;timeout&quot;: &quot;10s&quot;
  }
}
</code></pre>
<p>The same arguments can be passed through command line arguments in the following way. Embedded objects' values are described using JSON dot-notation.
Additionally,the user can pass the path of the JSON config file through a command-line argument as well, as shown in an example below. </p>
<pre><code class="language-bash">goshimmer \
--config=/tmp/config.json \
--pow.difficulty=2 \
--pow.numThreads=1 \
--pow.timeout=10s 
</code></pre>
<h2 id="custom-parameter-fields"><a class="header" href="#custom-parameter-fields">Custom parameter fields</a></h2>
<p>Currently, in the code there are two ways in which parameters are registered with GoShimmer. However, one is deprecated way, while the second should be used any longer when adding new parameters.</p>
<h3 id="old-deprecated-way"><a class="header" href="#old-deprecated-way">Old, deprecated way</a></h3>
<p>The old way is described shortly to give a basic understanding of how it works, but it should not be used any longer when adding new parameters.</p>
<p>In a package where the parameters will be used, create a <code>parameters.go</code> file, that contains the definition of constants, which define parameter names in JSON dot-notation. 
The constants will be later used in the code to access the parameter value. 
The file should also contain an <code>init()</code> function, which registers the parameters with the <code>flag</code> library responsible for parsing configuration along with its default value and short description.
It should include comments describing what the parameter is for. Here is an example <code>parameters.go</code> file:</p>
<pre><code class="language-go">package customPackage

import (
	flag &quot;github.com/spf13/pflag&quot;
)
const (
	// ParamName contains some value used within the plugin
	ParamName = &quot;customPlugin.paramName&quot;
)

func init() {
	flag.Float64(paramName, 0.31, &quot;ParamName used in some calculation&quot;)
}
</code></pre>
<p>The parameter values can be accessed in the code in the following way through the <code>config</code> plugin:</p>
<pre><code class="language-go">import &quot;github.com/iotaledger/goshimmer/plugins/config&quot;

config.Node().Int(CfgGossipPort)
</code></pre>
<h3 id="new-way"><a class="header" href="#new-way">New way</a></h3>
<p>Defining configuration parameters using the new way is really similar, however the parameters are not registered directly with the package reading the configuration,
but rather with our custom package that contains all the logic required to make it work seamlessly. </p>
<p>In this approach, instead of defining a parameter name, a new structure is defined with all necessary parameters, their default values and usage descriptions using Go's struct field tags.</p>
<p>One difference is that parameter names do not contain the namespace they belong to, the namespace is set when registering the parameters structure with the <code>configuration</code> package. One <code>parameters.go</code> file can contain definitions and register multiple parameter structures.</p>
<pre><code class="language-go">package customPlugin

import &quot;github.com/iotaledger/hive.go/configuration&quot;

// Parameters contains the configuration parameters used by the custom plugin.
var Parameters = struct {
	// ParamName contains some value used within the plugin
	ParamName float64 `default:&quot;0.31&quot; usage:&quot;ParamName used in some calculation&quot;`

	// ParamGroup contains an example of embedded configuration definitions.
	ParamGroup struct {
		// DetailedParam1 is the example value
		DetailedParam1        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam1 used in the plugin&quot;`
		// DetailedParam2 is the example value
		DetailedParam2        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam2 used in the plugin&quot;`
	}
}{}

func init() {
	configuration.BindParameters(&amp;Parameters, &quot;customPlugin&quot;)
}
</code></pre>
<p>In order to access the parameter value, a user can simply access the structure's field: <code>Parameters.ParamName</code> or <code>Parameters.ParamGroup.DetailedParam1</code> 
and it will be populated either with the default value or values passed through a JSON config or command-line argument. </p>
<p>This approach makes it more simple to define new parameters as well as makes accessing configuration values more clear. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-storage"><a class="header" href="#object-storage">Object storage</a></h1>
<p>In GoShimmer <code>ObjectStorage</code>  is used as a base data structure for many data collection elements such as <code>branchStorage</code>, <code>conflictStorage</code>, <code>messageStorage</code> and others.
It can be described by the following characteristics, it:</p>
<ul>
<li>is a manual cache which keeps objects in memory as long as consumers are using it</li>
<li>uses key-value storage type </li>
<li>provides mutex options for guarding shared variables and preventing changing the object state by multiple goroutines at the same time</li>
<li>takes care of  dynamic creation of different object types depending on the key, and the serialized data it receives through the utility <code>objectstorage.Factory</code></li>
<li>helps with the creation of multiple <code>ObjectStorage</code> instances from the same package and  automatic configuration.</li>
</ul>
<p>In order to create an object storage we need to provide the underlying <code>kvstore.KVStore</code> structure backed by the database.</p>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<p>GoShimmer stores data in the form of an object storage system. The data is stored in one large repository with flat structure. It is a scalable solution that allows for fast data retrieval because of its categorization structure.</p>
<p>Additionally, GoShimmer leaves the possibility to store data only in memory that can be specified with the parameter <code>CfgDatabaseInMemory</code> value. In-memory storage is purely based on a Go map, package <code>mapdb</code> from hive.go.
For the persistent storage in a database it uses <code>RocksDB</code>. It is a fast key-value database that performs well for both reads and writes simultaneously that was chosen due to its low memory consumption. </p>
<p>Both solutions are implemented in the <code>database</code> package, along with prefix definitions that can be used during the creation of new object storage elements.</p>
<p>The database plugin is responsible for creating a <code>store</code> instance of the chosen database under the directory specified with <code>CfgDatabaseDir</code> parameter. It will manage a proper closure of the database upon receiving a shutdown signal. During the start configuration, the database is marked as unhealthy, and it will be marked as healthy on shutdown. Then the garbage collector is run and the database can be closed.</p>
<h2 id="objectstorage"><a class="header" href="#objectstorage">ObjectStorage</a></h2>
<p>Assume we need to store data for some newly created object <code>A</code>. Then we need to define a new prefix for our package in the <code>database</code> package, and prefixes for single storage objects. They will be later used during <code>ObjectStorage</code> creation. A package prefix will be combined with a store specific prefix to create a specific realm.</p>
<pre><code class="language-Go">package example

type Storage struct {
	A                   *objectstorage.ObjectStorage
	...
	shutdownOnce        sync.Once
}
</code></pre>
<h3 id="objectstorage-factory"><a class="header" href="#objectstorage-factory">ObjectStorage factory</a></h3>
<p>To easily create multiple storage objects instances for one package, the most convenient way is to use the factory function.</p>
<pre><code class="language-Go">osFactory := objectstorage.NewFactory(store, database.Prefix)
</code></pre>
<p>It needs two parameters:</p>
<ul>
<li><code>store</code> - the key value <code>kvstore</code> instance</li>
<li><code>database.Prefix</code> - a prefix defined in the <code>database</code> package for our new <code>example</code> package. It will be responsible for automatic configuration of the newly provided <code>kvstore</code> instance.</li>
</ul>
<p>After defining the storage factory for the group of objects, we can use it to create an <code>*objectstorage.ObjectStorage</code> instance:</p>
<pre><code class="language-Go">AStorage = osFactory.New(objPrefix, FromObjectStorage)
AStorage = osFactory.New(objPrefix, FromObjectStorage, optionalOptions...)
</code></pre>
<p>For the function parameter we should provide:</p>
<ul>
<li><code>objPrefix</code> - mentioned before, we provide the object specific prefix.</li>
<li><code>FromObjectStorage</code> - a function that allows the dynamic creation of different object types depending on the stored data.</li>
<li><code>optionalOptions</code> -  an optional parameter provided in the form of options array <code>[]objectstorage.Option</code>. All possible options are defined in <code>objectstorage.Options</code>. If we do not specify them during creation, the default values will be used, such as enabled persistence or setting cache time to 0.</li>
</ul>
<h3 id="storableobject"><a class="header" href="#storableobject">StorableObject</a></h3>
<p><code>StorableObject</code> is an interface that allows the dynamic creation of different object types depending on the stored data. We need to make sure that all methods required by the interface are implemented to use the object storage factory.</p>
<ul>
<li><code>SetModified</code> - marks the object as modified, which will be written to the disk (if persistence is enabled).</li>
<li><code>IsModified</code> - returns true if the object is marked as modified</li>
<li><code>Delete</code> - marks the object to be deleted from the persistence layer</li>
<li><code>IsDeleted</code> - returns true if the object was marked as deleted</li>
<li><code>Persist</code> - enables or disables persistence for this object</li>
<li><code>ShouldPersist</code> - returns true if this object is going to be persisted</li>
<li><code>Update</code> - updates the object with the values of another object - requires an explicit implementation</li>
<li><code>ObjectStorageKey</code> - returns the key that is used to store the object in the database - requires an explicit implementation</li>
<li><code>ObjectStorageValue</code> - marshals the object data into a sequence of bytes that are used as the value part in the object storage - requires an explicit implementation</li>
</ul>
<p>Most of these have their default implementation in <code>objectstorage</code> library, except from <code>Update</code>, <code>ObjectStorageKey</code>, <code>ObjectStorageValue</code> which need to be provided.</p>
<h3 id="storableobjectfactory-function"><a class="header" href="#storableobjectfactory-function">StorableObjectFactory function</a></h3>
<p>The function <code>ObjectFromObjectStorage</code> from object storage provides functionality to restore objects from the <code>ObjectStorage</code>. By convention the implementation of this function usually follows the schema:
<code>ObjectFromObjectStorage</code> uses <code>ObjectFromBytes</code></p>
<pre><code class="language-Go">func ObjectFromObjectStorage(key []byte, data []byte) (result StorableObject, err error) {
    result, err := ObjectFromBytes(marshalutil.New(data))
    ...
    return
}
</code></pre>
<p><code>ObjectFromBytes</code> unmarshals the object sequence of bytes with a help of <code>marshalutil</code> library. The returned <code>consumedBytes</code> can be used for the testing purposes.
The created <code>marshalUtil</code> instance stores the stream of bytes and keeps track of what has been already read (<code>readOffset</code>).</p>
<pre><code class="language-Go">func ObjectFromBytes(bytes []byte) (object *ObjectType, consumedBytes int, err error) {
    marshalUtil := marshalutil.New(bytes)
    if object, err = ObjectFromMarshalUtil(marshalUtil); err != nil {
    ...
    consumedBytes = marshalUtil.ReadOffset()
    return
}
</code></pre>
<p>The key logic is implemented in <code>ObjectFromMarshalUtil</code> that takes the marshaled object and transforms it into the object of specified type.
Because the data is stored in a sequence of bytes, it has no information about the form of an object and any data types it had before writing to the database.
Thus, we need to serialize any data into a stream of bytes in order to write it (marshaling), and deserialize the stream of bytes back into correct data structures when reading it (unmarshaling). 
Let's consider as an example, unmarshaling of the <code>Approver</code> object.</p>
<pre><code class="language-Go">type Approver struct {
    approverType            ApproverType    //  8 bytes
    referencedMessageID     MessageID       // 32 bytes
    approverMessageID       MessageID       // 32 bytes
}
</code></pre>
<p>The order in which we read bytes has to reflect the order in which it was written down during marshaling. As in the example, the order: <code>referencedMessageID</code>, <code>approverType</code>, <code>approverMessageID</code> is the same in both marshalling and unmarshalling.</p>
<pre><code class="language-Go">// Unmarshalling
func ApproverFromMarshalUtil(marshalUtil *marshalutil.MarshalUtil) (result *Approver) {
    result = &amp;Approver{}
    result.referencedMessageID = MessageIDFromMarshalUtil(marshalUtil)
    result.approverType = ApproverTypeFromMarshalUtil(marshalUtil)
    result.approverMessageID = MessageIDFromMarshalUtil(marshalUtil)
    return
}
// Marshalling
func (a *Approver) ObjectStorageApprover() []byte {
    return marshalutil.New().
    Write(a.referencedMessageID).
    Write(a.approverType).
    Write(a.approverMessageID).
    Bytes()
}
</code></pre>
<p>We continue to decompose our object into smaller pieces with help of <code>MarshalUtil</code> struct that keeps track of bytes, and a read offset.
Then we use <code>marshalutil</code> build in methods on the appropriate parts of the byte stream with its length defined by the data
type of the struct field. This way, we are able to parse bytes to the correct Go data structure.</p>
<h3 id="objectstorage-methods"><a class="header" href="#objectstorage-methods">ObjectStorage methods</a></h3>
<p>After defining marshalling and unmarshalling mechanism for<code>objectStorage</code> bytes conversion, 
we can start using it for its sole purpose, to actually store and read the particular parts of the project elements. </p>
<ul>
<li>
<p><code>Load</code> allows retrieving the corresponding object based on the provided id. For example, the method on the message <code>objectStorage</code><br />
is getting the cached object. </p>
</li>
<li>
<p>To convert an object retrieved in the form of a cache to its own corresponding type, we can use <code>Unwrap</code>.
In the code below it will return the message wrapped by the cached object.</p>
</li>
<li>
<p><code>Exists</code> - checks weather the object has been deleted. If so it is released from memory with the <code>Release</code> method.</p>
<pre><code class="language-Go">func (s *Storage) Message(messageID MessageID) *CachedMessage {
    return &amp;CachedMessage{CachedObject: s.messageStorage.Load(messageID[:])}
}

cachedMessage := messagelayer.Tangle().Storage.Message(msgID)
if !cachedMessage.Exists() {
    msgObject.Release()
    }
message := cachedMessage.Unwrap()
</code></pre>
</li>
<li>
<p><code>Consume</code> will be useful when we want to apply a function on the cached object. <code>Consume</code> unwraps the <code>CachedObject</code> and passes a type-casted version to the consumer function.
Right after the object is consumed and when the callback is finished, the object is released.</p>
<pre><code class="language-Go">cachedMessage.Consume(func(message *tangle.Message) {
            doSomething(message)
        })
</code></pre>
</li>
<li>
<p><code>ForEach</code> - allows to apply a <code>Consumer</code> function for every object residing within the cache and the underlying persistence layer.
For example, this is how we can count the number of messages.</p>
<pre><code class="language-Go">messageCount := 0
messageStorage.ForEach(func(key []byte, cachedObject objectstorage.CachedObject) bool {
  	cachedObject.Consume(func(object objectstorage.StorableObject) {
  		messageCount++
      })
}
</code></pre>
</li>
<li>
<p><code>Store</code> - storing an object in the objectStorage. An extended version is method <code>StoreIfAbsent</code> 
that stores an object only if it was not stored before and returns boolean indication if the object was stored. 
<code>ComputeIfAbsent</code> works similarly but does not access the value log. </p>
<pre><code class="language-Go">cachedMessage := messageStorage.Store(newMessage)
cachedMessage, stored := messageStorage.StoreIfAbsent(newMessage)
cachedMessage := messageStorage.ComputeIfAbsent(newMessage, remappingFunction)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-specification"><a class="header" href="#protocol-specification">Protocol specification</a></h1>
<blockquote>
<p>DISCLAIMER: The following sections describe how things are implemented in GoShimmer. They might not reflect the final IOTA 2.0 specification or implementation.</p>
</blockquote>
<p>In this chapter we provide an overview of the various protocol components.</p>
<p>We start with a <a href="./protocol_specification/protocol.html">high level overview</a> of the protocol, followed by sections explaining the various implemented components.</p>
<p>Note, this chapter is still work in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-high-level-overview"><a class="header" href="#protocol-high-level-overview">Protocol high-level overview</a></h1>
<p>To orientate the reader, we provide a high-level overview of the protocol, following the natural life cycle of a message. The first module used—while the message is still being created—, is the <strong>Tip Selection</strong> module. 
Here, the node must choose a certain number (from two to eight) of other messages to reference, meaning that the newly created message will be cryptographically attached to these referenced messages. 
An honest node must always choose tips uniformly at random from a tip pool, i.e., from a set of still unreferenced messages that satisfy a certain set of conditions, as discussed on the <a href="protocol_specification/./tangle.html">Tangle</a> component. 
In the diagram below, the issuance process being described now is represented in the context of the complete protocol. </p>
<p><img src="protocol_specification/Protocol_overview_own_message.png" alt="title" /></p>
<p>Each node in the network has limited bandwidth, CPU, and memory. In order to avoid any node from being overloaded, the right to write in everybody else's Tangle is regulated by the <strong>Rate and Congestion Control Modules</strong>. 
The first one dictates the maximum rate of issuance of messages by the introduction of a small amount of proof of work. 
However, if an attacker accelerates the message issuance—effectively flooding the network—, the difficulty of the proof of work for that node will increase exponentially. Eventually, the attacker will be incapable of issuing new messages. </p>
<p>Later, the Congestion control module fairly allocates the network resources accordingly to a quantity called <strong>Access Mana</strong>, which acts as a <a href="https://en.wikipedia.org/wiki/Sybil_attack">Sybil protection</a> mechanism. 
We can summarize Access Mana as a scarce resource, that makes an effective Sybil protection mechanism. Thus, each node has the right to issue messages at a rate proportional to their Access Mana. 
This fair rate is not constant (since the utilization of the network may fluctuate), and to correctly set its own individual rate of issuance of messages, each node uses a mechanism called the <strong>Rate Setter</strong>, that makes the average issuance rate of the node converge to the fair rate guaranteed by Access Mana. 
Nodes that do not use the rate Setter will be punished by either the Rate Control or the Congestion Control Module.</p>
<p>Between the Rate Setter and the actual gossip of the message, several steps will take place, but—for the sake of clearness—we ignore these steps for now and return to this subject later. 
Then, assuming that the message was properly created, it will be propagated to the rest of the network. 
Since we deal with a large number of nodes, the communication graph cannot be <a href="https://en.wikipedia.org/wiki/Complete_graph">complete</a>. 
Thus, the <a href="https://en.wikipedia.org/wiki/Network_topology">network topology</a> will be dictated by the <a href="protocol_specification/./autopeering.html"><strong>Neighbor Selection</strong></a> (aka Autopeering) module. </p>
<p><img src="protocol_specification/Protocol_overview_received_message.png" alt="title" /></p>
<p>We turn our attention now to another point of view: the one of the nodes receiving new messages, represented in the diagram above. 
After receiving a message, the node will perform several <strong>syntactical verifications</strong>, that will act as a filter to the messages. Additionally, the message has to be <strong>solidified</strong>, meaning that the node must know all the past cone of the message (i.e., the set of all messages directly or indirectly referenced by the message in question). 
After this step, the node places all the messages left into an inbox. At a fixed global rate (meaning that all nodes use the same rate), the node uses a <strong>scheduler</strong> to choose a message from the inbox. 
This scheduler—that, technically, is part of the aforementioned congestion control mechanism—works as a gatekeeper, effectively regulating the use of the most scarce resources of the nodes. 
Since the scheduler works at a fixed rate, the network cannot be overwhelmed. The scheduler is designed to ensure—even in the presence of attackers—the following properties:</p>
<ol>
<li><strong>Consistency</strong>: all honest nodes will schedule the same messages</li>
<li><strong>Fair access</strong>: the nodes' messages will be scheduled at a fair rate according to their Access Mana</li>
<li><strong>Bounded latency</strong>: the processing time of all messages will be bounded</li>
</ol>
<p>Only after passing the scheduler the messages can be written into the local Tangle. To do that, the nodes perform most of the <strong>semantic validation</strong>, such as the search for irreconcilable conflicts in the message's past cone or (in the case of value transfers) unlock condition checks. 
At this point (if the message passes these checks), the message will be <strong>booked</strong> into the <strong>local Tangle</strong> of the node and be gossiped to the rest of the network. 
Additionally, in the case of a value transfer, the <strong>ledger state</strong> and two vectors called Access Mana Vector and <strong>Consensus Mana</strong> Vector are updated accordingly. 
The Consensus Mana is another Sybil protection mechanism which—since it is applied to different modules than Access Mana—has the need of a different calculation. </p>
<p><img src="protocol_specification/Protocol_overview_booking.png" alt="title" /></p>
<p>After having the message booked, the node is free to <strong>gossip</strong> it, but a crucial step of the protocol is still missing: the <strong>Opinion Setter</strong> and the voting protocol, that deal with the most subjective parts of the consensus mechanism (notice that, until now, the protocol has mostly dealt with objective checks). 
The voting protocol used here is the FPC (or <strong>Fast Probabilistic Consensus</strong>), which is a binary voting protocol that allows a large group of nodes to come to a consensus on the value of a single bit. 
The FPC begins with each node having an initial opinion, set using the node's local time perception and ordering of the messages. The nodes must set opinions about two subjects: </p>
<ol>
<li><strong>The legitimacy of the timestamp of the message</strong>: Whenever a node issues a message, it adds a timestamp to it, which should represent the local time of issuance (as seen by the issuer node). The other nodes will judge if this timestamp is reasonable, by checking if it is too far away from their own local clock.</li>
<li>In the case of a value transfer, <strong>whether it is a conflict</strong>: We use the <a href="protocol_specification/./consensus_mechanism.html#fcob"><strong>FCoB Rule</strong></a>. Roughly, the node will have a positive opinion about a transaction A if and only if all its conflicts arrived later than a certain time interval after A's arrival. </li>
</ol>
<p>In each round, nodes randomly choose other nodes to query about their opinions about one of the subjects above. 
The querying node changes its own opinion if the number of responses with a different opinion than it is greater than a certain threshold. 
In order to prevent liveness attacks, this threshold is determined by a random number issued by a committee of high Consensus Mana nodes via the <strong>dRNG</strong> application. 
Without the random threshold, an attacker could lie about its responses in a way that could prevent the protocol from terminating. Finally, a node will finalize on a certain opinion after holding it for a certain number of rounds. </p>
<p>When selecting which other nodes to query, a node must weight the list of all nodes by Consensus Mana. 
Thus, high Consensus Mana nodes are queried more often than low Consensus Mana nodes. This makes it difficult for an attacker to manipulate the outcome of the voting. 
Unless the attacker controls more than 1/3 of the Consensus Mana in the system, with high probability, we know that FPC has the following properties:</p>
<ol>
<li><strong>Termination</strong>: every honest node will finalize on some opinion before a maximum round number.</li>
<li><strong>Agreement</strong>: all honest nodes will finalize on the same opinion.</li>
<li><strong>Integrity</strong>: if a super majority of nodes—e.g. more than 90% weighted by Consensus Mana—, have the same initial opinion, then FPC will terminate with that value.</li>
</ol>
<p><img src="protocol_specification/Protocol_overview_consensus.png" alt="title" /></p>
<p>Analogously to Bitcoin's <a href="https://en.bitcoin.it/wiki/Confirmation">six blocks rule</a>, our protocol has certain measures of the probability of a certain message being considered valid permanently by all nodes. 
This is achieved by the use of the <a href="protocol_specification/./consensus_mechanism.html#approval-weight-aw"><strong>Approval Weight</strong></a>. 
The Approval weight represents the <em>weight</em> of branches (and messages). 
Different to the classical Nakamoto consensus, instead of selecting a leader based on a puzzle (PoW) or stake (PoS), it allows every node to express its opinion by simply issuing any message and attaching it in a part of the Tangle it <em>likes</em> (based on FCoB/FPC). 
This process is also known as virtual voting, and has been previously described in <a href="https://medium.com/@hans_94488/a-new-consensus-the-tangle-multiverse-part-1-da4cb2a69772">On Tangle Voting</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-of-the-protocol"><a class="header" href="#components-of-the-protocol">Components of the Protocol</a></h1>
<p>This section provides a high-level description of the interaction between components of the currently implemented GoShimmer protocol. The protocol can be divided into three main elements: a P2P overlay network, an immutable data structure, and a consensus mechanism. We abstract these three elements into layers, where—similarly to other architectures—upper layers build on the functionality provided by the layers below them. The definition of the different layers is merely about the convenience of creating a clear separation of concerns.</p>
<p><img src="protocol_specification/layers.png" alt="" /></p>
<h2 id="network-layer"><a class="header" href="#network-layer">Network Layer</a></h2>
<p>The network is maintained by the network layer modules, which can be characterized as a pure P2P overlay network, meaning that it is a system that runs on top of another network (e.g., the internet), and where all nodes have the same roles and perform the same actions (in contrast to client-server systems). GoShimmer's Network Layer consists of three basic modules: the <a href="protocol_specification/./autopeering.html#peer-discovery">peer discovery</a> module (which provides a list of nodes actively using the network), and the <a href="protocol_specification/./autopeering.html#neighbor-selection">neighbor selection</a> module (also known as autopeering), which actually selects peers. Finally, the P2P Communication manages a node's neighbors, either selected via <a href="protocol_specification/autopeering.html">autopeering</a> or <a href="protocol_specification/../tutorials/manual_peering.html">manual peering</a>.</p>
<h2 id="communication-layer"><a class="header" href="#communication-layer">Communication Layer</a></h2>
<p>The communication layer concerns the information propagated through the network layer, which is contained in objects called messages. This layer forms a DAG with messages as vertices called the <a href="protocol_specification/./tangle.html">Tangle</a>: a replicated, shared and distributed data structure that emerges—through a combination of deterministic rules, cooperation, and (either direct or virtual) voting—as FPC and approval weight based finality.
Since nodes have finite capabilities, the number of messages that the network can process is limited. Thus, the network might become overloaded, either simply because of honest heavy usage or because of malicious (spam) attacks. To protect the network from halting or even from getting inconsistent, the rate control (currently a static PoW) and <a href="protocol_specification/./congestion_control.html">congestion control</a> modules control when and how many messages can be gossiped.</p>
<h2 id="decentralized-application-layer"><a class="header" href="#decentralized-application-layer">(Decentralized) Application Layer</a></h2>
<p>On top of the communication layer lives the application layer. Anybody can develop applications that run on this layer, and nodes can choose which applications to run. Of course, these applications can also be dependent on each other.
There are several core applications that must be run by all nodes, as the value transfer applications, which maintains the <a href="protocol_specification/./ledgerstate.html">ledger state</a> (including  advanced <a href="protocol_specification/./advanced_outputs.html">output types</a>), and a quantity called <a href="protocol_specification/./mana.html">Mana</a>, that serves as a scarce resource as our Sybil protection mechanism.
Additionally, all nodes must run what we call the consensus applications, which regulate timestamps in the messages and resolve conflicts.
The consensus mechanism implemented in GoShimmer is leaderless and consists out of multiple components:</p>
<ol>
<li>The <a href="protocol_specification/./consensus_mechanism.html#fpc">Fast Probabilistic Consensus (FPC)</a> provides pre-consensus in form of a binary voting protocol that produces consensus on a bit and uses a <a href="protocol_specification/./consensus_mechanism.html#drng">distributed Random Number Generator (dRNG)</a> to be resilient against metastable states.</li>
<li>A virtual <a href="protocol_specification/./consensus_mechanism.html#approval-weight-aw">voting protocol (Approval Weight)</a> that provides finality similarly to the longest chain rule in Nakamoto consensus (i.e., heaviest branch) for branches and messages.</li>
</ol>
<h2 id="data-flow---overview"><a class="header" href="#data-flow---overview">Data Flow - Overview</a></h2>
<p>The diagram below represents the interaction between the different modules in the protocol (<a href="protocol_specification/../implementation_design/event_driven_model.html">event driven</a>). Each blue box represents a component of the <a href="https://github.com/iotaledger/goshimmer/tree/develop/packages/tangle">Tangle codebase</a>, which has events (in yellow boxes) that belong to it. Those events will trigger methods (the green boxes), that can also trigger other methods. This triggering is represented by the arrows in the diagram. Finally, the purple boxes represent events that do not belong to the component that triggered them.</p>
<p>As an example, take the Parser component. The function <code>ProcessGossipMessage</code> will trigger the method <code>Parse</code>, which is the only entry to the component. There are three possible outcomes to the <code>Parser</code>: triggering a <code>ParsingFailed</code> event, a <code>MessageRejected</code> event, or a <code>MessageParsed</code> event. In the last case, the event will trigger the <code>StoreMessage</code> method (which is the entry to the Storage component), whereas the first two events do not trigger any other component.</p>
<p><img src="protocol_specification/data-flow.png" alt="" /></p>
<p>We call this the data flow, i.e., the <a href="protocol_specification/../protocol_specification/protocol.html">life cycle of a message</a>, from message reception (meaning that we focus here on the point of view of a node receiving a message issued by another node) up until acceptance in the Tangle. Notice that any message, either created locally by the node or received from a neighbor needs to pass through the data flow.</p>
<h3 id="message-factory"><a class="header" href="#message-factory">Message Factory</a></h3>
<p>The IssuePayload function creates a valid payload which is provided to the <code>CreateMessage</code> method, along with a set of parents chosen with the Tip Selection Algorithm. Then, the Message Factory component is responsible to find a nonce compatible with the PoW requirements defined by the rate control module. Finally, the message is signed. Notice that the message generation should follow the rates imposed by the rate setter, as defined in <a href="protocol_specification/./congestion_control.html#rate-setting">rate setting</a>.</p>
<h3 id="parser"><a class="header" href="#parser">Parser</a></h3>
<p>The first step after the arrival of the message to the message inbox is the parsing, which consists of the following different filtering processes (meaning that the messages that don't pass these steps will not be stored):</p>
<p><strong>Bytes filter</strong>:</p>
<ol>
<li>Recently Seen Bytes: it compares the incoming messages with a pool of recently seen bytes to filter duplicates.</li>
<li>PoW check: it checks if the PoW requirements are met, currently set to the message hash starting with 22 zeroes.</li>
</ol>
<p>Followed by the bytes filters, the received bytes are parsed into a message and its corresponding payload and <a href="protocol_specification/./tangle.html#syntactical-validation">syntactically validated</a>. From now on, the filters operate on message objects rather than just bytes.</p>
<p><strong>Message filter</strong>:</p>
<ol>
<li>Signature check: it checks if the message signature is valid.</li>
<li><a href="protocol_specification/./tangle.html#message-timestamp-vs-transaction-timestamp">Timestamp Difference Check for transactions</a>: it checks if the timestamps of the payload, and the message are consistent with each other</li>
</ol>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>Only messages that pass the Parser are stored, along with their metadata. Additionally, new messages are stored as approvers of their parents, i.e., a reverse mapping that enables us to walk the Tangle into the future cone of a message.</p>
<h3 id="solidifier"><a class="header" href="#solidifier">Solidifier</a></h3>
<p><a href="protocol_specification/./tangle.html#solidification">Solidification</a> is the process of requesting missing messages. In this step, the node checks if all the past cone of the message is known; in the case that the node realizes that a message in the past cone is missing, it sends a request to its neighbors asking for that missing message. This process is recursively repeated until all of a message's past cone up to the genesis (or snapshot) becomes known to the node. 
This way, the protocol enables any node to retrieve the entire message history, even for nodes that have just joined the network.</p>
<h3 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h3>
<p>The scheduler makes sure that the network as a whole can operate with maximum throughput and minimum delays while providing consistency, fairness (according to aMana), and security. It, therefore, regulates the allowed influx of messages to the network as a <a href="protocol_specification/./congestion_control.html">congestion-control mechanism</a>.</p>
<h3 id="booker"><a class="header" href="#booker">Booker</a></h3>
<p>After scheduling, the message goes to the booker. This step is different between messages that contain a transaction payload and messages that do not contain it.</p>
<p>In the case of a non-transaction payload, booking into the Tangle occurs after the conflicting parents branches check, i.e., after checking if the parents' branches contain sets of (two or more) transactions that belong to the same conflict set. In the case of this check not being successful, the message is marked as <code>invalid</code> and not booked.</p>
<p>In the case of a transaction as payload, initially, the following check is done:</p>
<ol>
<li>UTXO check: it checks if the inputs of the transaction were already booked. If the message does not pass this check, the message is not booked. If it passes the check, it goes to the next block of steps.</li>
<li>Balances check: it checks if the sum of the values of the generated outputs equals the sum of the values of the consumed inputs. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step.</li>
<li>Unlock conditions: checks if the unlock conditions are valid. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step.</li>
<li>Inputs' branches validity check: it checks if all the consumed inputs belong to a valid branch. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step.</li>
</ol>
<p>After the objective checks, the following subjective checks are done:</p>
<ol start="5">
<li>Inputs' branches rejection check: it checks if all the consumed inputs belong to a non-rejected branch. Notice that this is not an objective check, so the node is susceptible (even if with a small probability) to have its opinion about rejected branches changed by a reorganization. For that reason, if the message does not pass this check, the message is booked into the Tangle and ledger state (even though the balances are not altered by this message, since it will be booked to a rejected branch). This is what we call &quot;lazy booking&quot;, which is done to avoid huge re-calculations in case of a reorganization of the ledger. If it passes the check, it goes to the next step.</li>
<li>Double spend check: it checks if any of the inputs is conflicting with a transaction that was already confirmed. As in the last step, this check is not objective and, thus, if the message does not pass this check, it is lazy booked into the Tangle and ledger state, into an invalid branch. If it passes the check, it goes to the next step.</li>
</ol>
<p>At this point, the missing steps are the most computationally expensive:</p>
<ol start="7">
<li>Inputs' conflicting branches check: it checks if the branches of the inputs are conflicting. As in the last step, if the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step.</li>
<li>Conflict check: it checks if the inputs are conflicting with an unconfirmed transaction. In this step, the branch to which the message belongs is computed. In both cases (passing the check or not), the transaction is booked into the ledger state and the message is booked into the Tangle, but its branch ID will be different depending on the outcome of the check.</li>
</ol>
<p><img src="https://i.imgur.com/ra09bbl.png" alt="" /></p>
<p>Finally, after a message is booked, it might become a <a href="protocol_specification/./markers.html">marker</a> (depending on the marker policy) and can be gossiped.</p>
<h3 id="consensus-mechanism"><a class="header" href="#consensus-mechanism">Consensus Mechanism</a></h3>
<p>Before we form a local opinion on a message we add its weight to its branch and past markers. In that way we always keep track of the <a href="protocol_specification/./consensus_mechanism.html#approval-weight-aw">approval weight</a>, and an incoming message might trigger the confirmation of branches and/or messages in its past cone.</p>
<p>Afterwards, we form opinions in two independent processes, that can be done in parallel: the payload opinion setting, and the message timestamp opinion setting. The message timestamp opinion setting is currently not integrated, and we simply like all timestamps.</p>
<p>In parallel to the message timestamp opinion setting, a payload evaluation is also done. If the message does not contain a transaction payload, the payload opinion is automatically set to <code>liked</code>. Otherwise, it has to pass the FCoB rule (and possibly, an FPC voting) in order to be <code>liked</code>, as described <a href="protocol_specification/./consensus_mechanism.html#fpc">here</a>.</p>
<p><img src="https://i.imgur.com/biQIikd.png" alt="" /></p>
<h3 id="tip-manager"><a class="header" href="#tip-manager">Tip Manager</a></h3>
<p>The first check done in the tip manager is the eligibility check (i.e., subjective timestamp is ok), after passing it, a message is said to be <code>eligible</code> for tip selection (otherwise, it's <code>not eligible</code>). 
If a message is eligible for <a href="protocol_specification/./tangle.html#tsa">tip selection</a> and its payload is <code>liked</code>, along with all its weak past cone, the message is added to the strong tip pool and its parents are removed from the strong tip pool. If a message is eligible for tip selection, its payload is <code>liked</code> but its branch is not liked it is added to the weak tip pool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tangle"><a class="header" href="#tangle">Tangle</a></h1>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>uint8</td><td>An unsigned 8 bit integer encoded in Little Endian.</td></tr>
<tr><td>uint16</td><td>An unsigned 16 bit integer encoded in Little Endian.</td></tr>
<tr><td>uint32</td><td>An unsigned 32 bit integer encoded in Little Endian.</td></tr>
<tr><td>uint64</td><td>An unsigned 64 bit integer encoded in Little Endian.</td></tr>
<tr><td>ByteArray[N]</td><td>A static size array of size N.</td></tr>
<tr><td>ByteArray</td><td>A dynamically sized array. A uint32 denotes its length.</td></tr>
<tr><td>string</td><td>A dynamically sized array of an UTF-8 encoded string. A uint16 denotes its length.</td></tr>
<tr><td>time</td><td>Unix time in nanoseconds stored as <code>int64</code>, i.e., the number of nanoseconds elapsed since January 1, 1970 UTC.</td></tr>
</tbody></table>
<h2 id="subschema-notation"><a class="header" href="#subschema-notation">Subschema Notation</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left">oneOf</td><td align="left">One of the listed subschemas.</td></tr>
<tr><td align="left">optOneOf</td><td align="left">Optionally one of the listed subschemas.</td></tr>
<tr><td align="left">anyOf</td><td align="left">Any (one or more) of the listed subschemas.</td></tr>
<tr><td align="left"><code>between(x,y)</code></td><td align="left">Between (but including) x and y of the listed subschemas.</td></tr>
</tbody></table>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><code>MAX_MESSAGE_SIZE=64 KB</code> The maximum allowed message size.</li>
<li><code>MAX_PAYLOAD_SIZE=65157 B</code> The maximum allowed payload size.</li>
<li><code>MIN_STRONG_PARENTS=1</code> The minimum amount of strong parents a message needs to reference.</li>
<li><code>MAX_PARENTS=8</code> The maximum amount of parents a message can reference.</li>
</ul>
<h2 id="general-concept"><a class="header" href="#general-concept">General concept</a></h2>
<p><img src="https://i.ibb.co/RyqbZzN/tangle.png" alt="Tangle" /></p>
<p>The Tangle represents a growing partially-ordered set of messages, linked with each other through cryptographic primitives, and replicated to all nodes in the peer-to-peer network. The Tangle enables the ledger state (i.e., the UTXO-DAG formed by transactions contained in messages), and the possibility to store data.</p>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<ul>
<li><strong>Genesis</strong>: The genesis message is used to bootstrap the Tangle and  creates the entire token supply and no other tokens will ever be created. It is the first message and does not have parents. It is marked as solid, eligible and confirmed.</li>
<li><strong>Past cone</strong>: All messages that are directly or indirectly referenced by a message are called its past cone.</li>
<li><strong>Future cone</strong>: All messages that directly or indirectly reference a message are called its future cone.</li>
<li><strong>Solidity</strong>: A message is marked as solid if its entire past cone until the Genesis (or the latest snapshot) is known.</li>
<li><strong>Parents</strong>: A message directly references between 1-8 previous messages that we call its <strong>parents</strong>. A parent can be either <strong>strong</strong> or <strong>weak</strong> (see <a href="protocol_specification/tangle.html#orphanage--approval-switch">approval switch</a>).</li>
<li><strong>Approvers</strong>: Parents are approved by their referencing messages called <strong>approvers</strong>. It is thus a reverse mapping of parents. As in the parents' definition, an approver might be either <strong>strong</strong> or <strong>weak</strong>.</li>
<li><strong>Branch</strong>: A version of the ledger that temporarily coexists with other versions, each spawned by conflicting transactions. </li>
</ul>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>Messages are created and signed by nodes. Next to several fields of metadata, they carry a <strong>payload</strong>. The maximum message size is <code>MAX_MESSAGE_SIZE</code>.</p>
<h3 id="message-id"><a class="header" href="#message-id">Message ID</a></h3>
<p>BLAKE2b-256 hash of the byte contents of the message. It should be used by the nodes to index the messages and by external APIs.</p>
<h3 id="message-structure"><a class="header" href="#message-structure">Message structure</a></h3>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The message version. The schema specified in this RFC is for version <strong>1</strong> only. </td>
    </tr>
    <tr>
        <td>Parents count</td>
        <td>uint8</td>
        <td>The amount of parents preceding the current message.</td>
    </tr>
    <tr>
        <td>Parents type</td>
        <td>uint8</td>
        <td>Bitwise encoding of parent type matching the order of preceding parents starting at <code>least significant bit</code>. <code>1</code> indicates a strong parent, while <code>0</code> signals a weak parent. At least <code>MIN_STRONG_PARENTS</code> parent type must be strong.</td>
    </tr>
    <tr>
        <td colspan="1">
            Parents <code>between(1,8)</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Parents, ordered by hash ASC</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Parent</td>
                        <td>ByteArray[32]</td>
                        <td>The Message ID of the <i>parent Message</i>.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Issuer public key (Ed25519)</td>
        <td>ByteArray[32]</td>
        <td>The public key of the node issuing the message.</td>
    </tr>
    <tr>
        <td>Issuing time</td>
        <td>time</td>
        <td>The time the message was issued.</td>
    </tr>
    <tr>
        <td>Sequence number</td>
        <td>uint64</td>
        <td>The always increasing number of issued messages of the issuing node.</td>
    </tr>
    <tr>
        <td>Payload length</td>
        <td>uint32</td>
        <td>The length of the Payload. Since its type may be unknown to the node, it must be declared in advance. 0 length means no payload will be attached.</td>
    </tr>
    <tr>
        <td colspan="1">
            Payload
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Generic Payload</summary>
                <blockquote>
                An outline of a general payload
                </blockquote>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Payload Type</td>
                        <td>uint32</td>
                        <td>
                            The type of the payload. It will instruct the node how to parse the fields that follow. Types in the range of 0-127 are "core types", that all nodes are expected to know.
                        </td>
                    </tr>
                    <tr>
                        <td>Data Fields</td>
                        <td>ANY</td>
                        <td>A sequence of fields, where the structure depends on <code>payload type</code>.</td>
                    </tr>
                </table>
            </details>
            </td>
    </tr>
    <tr>
        <td>Nonce</td>
        <td>uint64</td>
        <td>The nonce which lets this message fulfill the adaptive Proof-of-Work requirement.</td>
    </tr>
    <tr>
        <td>Signature (Ed25519)</td>
        <td>ByteArray[64]</td>
        <td>Signature of the issuing node's private key signing the entire message bytes.</td>
    </tr>
</table>
<h3 id="syntactical-validation"><a class="header" href="#syntactical-validation">Syntactical Validation</a></h3>
<p>Messages that do no pass the Syntactical Validation are discarded. Only syntactically valid messages continue in the data flow, i.e., pass to the Semantic Validation.</p>
<p>A message is syntactically valid if:</p>
<ol>
<li>The message length does not exceed <code>MAX_MESSAGE_SIZE</code> bytes.</li>
<li>When the message parsing is complete, there are not any trailing bytes left that were not parsed.</li>
<li>At least 1 and at most 8 distinct parents are given, ordered ASC and at least <code>MIN_STRONG_PARENTS</code> are strong parents.</li>
</ol>
<h3 id="semantic-validation"><a class="header" href="#semantic-validation">Semantic Validation</a></h3>
<p>Messages that do not pass the Semantic Validation are discarded. Only semantically valid messages continue in the data flow.</p>
<p>A message is semantically valid if:</p>
<ol>
<li>The Message PoW Hash contains at least the number of leading 0 defined as required by the PoW.</li>
<li>The signature of the issuing node is valid.</li>
<li>It passes <a href="protocol_specification/tangle.html#age-of-parents">parents age checks</a>.</li>
</ol>
<h2 id="payloads"><a class="header" href="#payloads">Payloads</a></h2>
<p>Payloads can contain arbitrary data up to <code>MAX_PAYLOAD_SIZE</code>, which allows building additional protocols on top of the base protocol in the same way as TCP/IP allows to define additional protocols on top of its generic data segment.</p>
<p>Payloads can recursively contain other payloads, which enables the creation of higher level protocols based on the same concepts of layers, as in traditional software and network architecture.</p>
<p>Payloads other than transactions are always liked with level of knowledge 3.</p>
<h3 id="user-defined-payloads"><a class="header" href="#user-defined-payloads">User-defined payloads</a></h3>
<p>A node can choose to interpret user-defined payloads by listenting to its specific <strong>payload type</strong> (possibly via third-party code/software). If a node does not know a certain <strong>payload type</strong>, it simply treats it as arbitrary data.</p>
<h3 id="core-payloads"><a class="header" href="#core-payloads">Core payloads</a></h3>
<p>The core protocol defines a number of payloads that every node needs to interpret and process in order to participate in the network.</p>
<ul>
<li><strong>Transactions:</strong> Value transfers that constitute the ledger state.</li>
<li><strong>Data:</strong>  Pure data payloads allow to send unsigned messages.</li>
<li><strong>dRNG:</strong> Messages that contain randomness or committee declarations.</li>
<li><strong>FPC:</strong> Opinions on conflicts of transactions and timestamps of the messages, mainly issued by high mana nodes.</li>
</ul>
<h2 id="solidification"><a class="header" href="#solidification">Solidification</a></h2>
<p>Due to the asynchronicity of the network, we may receive messages for which their past cone is not known yet. We refer to these messages as unsolid messages. It is not possible neither to approve nor to gossip unsolid messages. The actions required to obtain such missing messages is called solidification.
<strong>Solidification</strong> is the process of requesting missing referenced messages. It may be recursively repeated until all of a message's past cone up to the genesis (or snapshot) becomes solid.</p>
<p>In that way, the Tangle enables all nodes to retrieve all of a message's history, even the ones joining the network at a point later in time.</p>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<ul>
<li><strong>valid</strong>: A message is considered valid if it passes the following filters from the solidifier and from the message booker:
<ul>
<li>solidifier: it checks if parents are valid,</li>
<li>booker: it checks if the contained transaction is valid. Notice that only messages containing a transaction are required to perform this check.</li>
</ul>
</li>
<li><strong>parents age check</strong>: A check that ensures the timestamps of parents and child are valid, following the details defined in the <a href="protocol_specification/tangle.html#age-of-parents">Timestamp specification</a>.</li>
<li><strong>solid</strong>: A message is solid if it passes parents age check and all its parents are stored in the storage, solid and valid.</li>
</ul>
<h3 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h3>
<p>During solidification, if a node is missing a referenced message, the corresponding message ID is stored in the <code>solidification buffer</code>. A node asks its neighbors for the missing message by sending a <code>solidification request</code> containing the message ID. Once the requested message is received from its neighbors, its message ID shall be removed from the <code>solidification buffer</code>. The requested message is marked as solid after it passes the standard solidification checks. If any of the checks fails, the message remains unsolid.</p>
<p>If a message gets solid, it shall walk through the rest of the data flow, then propagate the solid status to its future cone by performing the solidification checks on each of the messages in its future cone again.</p>
<p><img src="https://user-images.githubusercontent.com/11289354/117009286-28333200-ad1e-11eb-8d0d-186c8d8ce373.png" alt="GoShimmer-flow-solidification_spec" /></p>
<h2 id="orphanage--approval-switch"><a class="header" href="#orphanage--approval-switch">Orphanage &amp; Approval Switch</a></h2>
<p>The Tangle builds approval of a given message by directly or indirectly attaching other messages in its future cone. Due to different reasons, such as the TSA not picking up a given message before its timestamp is still <em>fresh</em> or because its past cone has been rejected, a message can become orphan. This implies that the message cannot be included in the Tangle history since all the recent tips do not contain it in their past cone and thus, it cannot be retrieved during solidification. As a result, it might happen that honest messages and transactions would need to be reissued or reattached.
To overcome this limitation, we propose the <code>approval switch</code>. The idea is to minimize honest messages along with transactions getting orphaned, by assigning a different meaning to the parents of a message.</p>
<h3 id="detailed-design-1"><a class="header" href="#detailed-design-1">Detailed design</a></h3>
<p>Each message can express two levels of approval with respect to its parents:</p>
<ul>
<li><strong>Strong</strong>: it defines approval for both the referenced message along with its entire past cone.</li>
<li><strong>Weak</strong>: it defines approval for the referenced message but not for its past cone.</li>
</ul>
<p>Let's consider the following example:</p>
<p><img src="https://i.imgur.com/rfpnkcg.png" alt="" /></p>
<p>Message <em>D</em> contains a transaction that has been rejected, thus, due to the monotonicity rule, its future cone must be orphaned. Both messages <em>F</em> (transaction) and <em>E</em> (data) directly reference <em>D</em> and, traditionally, they should not be considered for tip selection. However, by introducing the approval switch, these messages can be picked up via a <strong>weak</strong> reference as messages <em>G</em> and <em>H</em> show.</p>
<p>We define two categories of eligible messages:</p>
<ul>
<li><strong>Strong message</strong>:
<ul>
<li>It is eligible</li>
<li>Its payload is liked with level of knowledge &gt;=2</li>
<li>Its branch is <strong>liked</strong> with level of knowledge &gt;= 2</li>
</ul>
</li>
<li><strong>Weak message</strong>:
<ul>
<li>It is eligible</li>
<li>Its payload is liked with level of knowledge &gt;=2</li>
<li>Its branch is <strong>not liked</strong> with level of knowledge &gt;= 2</li>
</ul>
</li>
</ul>
<p>We call <em>strong approver of x</em> (or <em>strong child of x</em>) any strong message <em>y</em> approving <em>x</em> via a strong reference. Similarly, we call <em>weak approver of x</em> (or <em>weak child of x</em>) any strong message <em>y</em> approving <em>x</em> via a weak reference.</p>
<h3 id="tsa"><a class="header" href="#tsa">TSA</a></h3>
<p>We define two separate tip types:</p>
<ul>
<li><strong>Strong tip</strong>:
<ul>
<li>It is a strong message</li>
<li>It is not directly referenced by any strong message via strong parent</li>
</ul>
</li>
<li><strong>Weak tip</strong>:
<ul>
<li>It is a weak message</li>
<li>It is not directly referenced by any strong message via weak parent</li>
</ul>
</li>
</ul>
<p>Consequently, a node keeps track of the tips by using two distinct tips sets:</p>
<ul>
<li><strong>Strong tips set</strong>: contains the strong tips</li>
<li><strong>Weak tips set</strong>: contains the weak tips</li>
</ul>
<p>Tips of both sets must be managed according to the local perception of the node. Hence, a strong tip loses its tip status if it gets referenced (via strong parent) by a strong message. Similarly, a weak tip loses its tip status if it gets referenced (via weak parent) by a strong message. This means that weak messages approving via either strong or weak parents, do not have an impact on the tip status of the messages they reference.</p>
<h3 id="branch-management"><a class="header" href="#branch-management">Branch management</a></h3>
<p>A message inherits the branch of its strong parents, while it does not inherit the branch of its weak parents.</p>
<h4 id="approval-weight"><a class="header" href="#approval-weight">Approval weight</a></h4>
<p>The approval weight of a given message takes into account all of its future cone built over all its strong approvers.
Let's consider the following example:</p>
<p><img src="https://i.imgur.com/a9FTyyg.png" alt="" /></p>
<p><em>E</em> is a weak message strongly approving <em>B</em> and <em>D</em>. When considering the approval weight of <em>B</em>, only the strong approvers of its future cone are used, thus, <em>D, E, F</em>. Note that, the approval weight of <em>E</em> would instead be built over <em>G, H, I</em>. Therefore, its approval weight does not add up to its own weight (for instance, when looking at the approval weight of <em>B</em>).</p>
<h3 id="solidification-1"><a class="header" href="#solidification-1">Solidification</a></h3>
<p>The solidification process does not change, both parent types are used to progress.</p>
<h3 id="test-cases"><a class="header" href="#test-cases">Test cases</a></h3>
<ul>
<li>message <em>x</em> strongly approves a strong message <em>y</em>: ok</li>
<li>message <em>x</em> weakly approves a strong message <em>y</em>: it's weird, counts for approval weight of <em>y</em> but does not affect the tip status of <em>y</em></li>
<li>message <em>x</em> strongly approves a weak message <em>y</em>: <em>x</em> becomes a weak message</li>
<li>message <em>x</em> weakly approves a weak message <em>y</em>: ok</li>
</ul>
<h2 id="finality"><a class="header" href="#finality">Finality</a></h2>
<p>Users need to know whether their information will not be orphaned. However, finality is inherently probabilistic. For instance, consider the following scenario: an attacker can trivially maintain a chain of messages that do not approve any other message. At any given point in time, it is possible that all messages will be orphaned except this chain. This is incredibly unlikely, but yet still possible.</p>
<p>Therefore, we introduce <a href="protocol_specification/./consensus_mechanism.html#approval-weight-aw">Approval Weight</a> to measure the finality of any given message. Similarly to Bitcoin's 6 block rule, AW describes how deeply buried a message in the Tangle is. If a message reaches &gt;50% of active consensus mana approving it, i.e., its future cone contains messages of nodes that together assert &gt;50% of active consensus mana, it as finalized and, thus, confirmed. Specifically, in GoShimmer we use <a href="protocol_specification/./markers.html">markers</a> to optimize AW calculations and approximate AW instead of tracking it for each message individually.</p>
<h2 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h2>
<p>In order to enable snapshotting based on time constraints rather than special messages in the Tangle (e.g. checkpoints), nodes need to share the same perception of time. Specifically, they need to have consensus on the <em>age of messages</em>. This is one of the reasons that messages must contain a field <code>timestamp</code> which represents the creation time of the message and is signed by the issuing node.</p>
<p>Having consensus on the creation time of messages enables not only total ordering but also new applications that require certain guarantees regarding time. Specifically, we use message timestamps to enforce timestamps in transactions, which may also be used in computing the Mana associated to a particular node ID.</p>
<p>In this document, we propose a mechanism to achieve consensus on message timestamps by combining a synchronous and an asynchronous approach. While online nodes may leverage FPC to vote on timestamps, nodes that join the network at a later time use an approach based on the <em>approval weight</em> (described in section X.X) to determine the validity of timestamps.</p>
<h3 id="clock-synchronization"><a class="header" href="#clock-synchronization">Clock synchronization</a></h3>
<p>Nodes need to share a reasonably similar perception of time in order to effectively judge the accuracy of timestamps. Therefore, we propose that nodes synchronize their clock on startup and resynchronize periodically every <code>30min</code> to counter <a href="https://en.wikipedia.org/wiki/Clock_drift">drift</a> of local clocks. Instead of changing a nodes' system clock, we introduce an <code>offset</code> parameter to adjust for differences between <em>network time</em> and local time of a node. Initially, the <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">Network Time Protocol (NTP)</a> (<a href="https://github.com/beevik/ntp">Go implementation</a>) is used to achieve this task.</p>
<h3 id="general-timestamp-rules"><a class="header" href="#general-timestamp-rules">General Timestamp rules</a></h3>
<p>Every message contains a timestamp, which is signed by the issuing node. Thus, the timestamp itself is objective and immutable.  Furthermore, transactions also contain a timestamp, which is also signed by the sender of the transaction (user) and thus immutable. We first discuss the rules regarding message timestamps.</p>
<p>In order for a message to be eligible for tip selection, the timestamp of every message in its past cone (both weak and strong) must satisfy certain requirements. These requirements fall into two categories: objective and subjective. The objective criteria only depend on information written directly in the Tangle and are applied immediately upon solidification.  Thus, all nodes immediately have consensus on the objective criteria.  In this section, we will discuss these objective criteria.</p>
<p>The quality of the timestamp is a subjective criterion since it is based on the solidification time of the message.  Thus, nodes must use a consensus algorithm, e.g. FPC, to decide which messages should be rejected based on subjective criteria. However, currently this feature is not yet implemented in GoShimmer, and we assume all timestamps to be good.</p>
<h3 id="age-of-parents"><a class="header" href="#age-of-parents">Age of parents</a></h3>
<p>It is problematic when incoming messages reference extremely old messages. If any new message may reference any message in the Tangle, then a node will need to keep all messages readily available, precluding snapshotting. For this reason, we require that the difference between the timestamp of a message, and the timestamp of its parents must be at most <code>30min</code>. Additionally, we require that timestamps are monotonic, i.e., parents must have a timestamp smaller than their children's timestamps.</p>
<h3 id="message-timestamp-vs-transaction-timestamp"><a class="header" href="#message-timestamp-vs-transaction-timestamp">Message timestamp vs transaction timestamp</a></h3>
<p>Transactions contain a timestamp that is signed by the user when creating the transaction. It is thus different from the timestamp in the message which is created and signed by the node. We require</p>
<pre><code>transaction.timestamp+TW &gt;= message.timestamp &gt;= transaction.timestamp
</code></pre>
<p>where <code>TW</code> defines the maximum allowed difference between both timestamps, currently set to <code>10min</code>.</p>
<p>If a node receives a transaction from a user with an invalid timestamp it does not create a message but discards the transaction with a corresponding error message to the user. To prevent a user's local clock differences causing issues the node should offer an API endpoint to retrieve its <code>SyncedTime</code> according to the network time.</p>
<h3 id="reattachments"><a class="header" href="#reattachments">Reattachments</a></h3>
<p>Reattachments of a transaction are possible during the time window <code>TW</code>. Specifically, a transaction may be reattached in a new message as long as the condition <code>message.timestamp-TW &gt;= transaction.timestamp</code> is fulfilled. If for some reason a transaction is not <em>picked up</em> (even after reattachment) and thus being orphaned, the user needs to create a new transaction with a current timestamp.</p>
<h3 id="age-of-utxo"><a class="header" href="#age-of-utxo">Age of UTXO</a></h3>
<p>Inputs to a transaction (unspent outputs) inherit their spent time from the transaction timestamp. Similarly, unspent outputs inherit their creation time from the transaction timestamp as well. For a transaction to be considered valid we require</p>
<pre><code>transaction.timestamp &gt;= inputs.timestamp
</code></pre>
<p>In other words, all inputs to a transaction need to have a smaller or equal timestamp than the transaction. In turn, all created unspent outputs will have a greater or equal timestamp than all inputs.</p>
<h2 id="tangle-time"><a class="header" href="#tangle-time">Tangle Time</a></h2>
<p>For a variety of reasons, a node needs to be able to determine if it is in sync with the rest of the network, including the following:</p>
<ul>
<li>to signal to clients that its perception is healthy,</li>
<li>to know when to issue messages (nodes out of sync should not issue messages, lest they are added to the wrong part of the Tangle),</li>
<li>to schedule messages at the correct rate: out of sync nodes should schedule faster in order to catch up with the network,</li>
<li>and to optimize FPC: nodes should not query while syncing, but instead rely on the approval weight.</li>
</ul>
<p>Every DLT is a clock, or more specifically a network of synchronized clocks. This clock has a natural correspondence with &quot;real time&quot;. If the DLT clock differs significantly from local time, then we can conclude that our DLT clock is off from all the other clocks, and thus the node is out of sync.</p>
<p>Tangle time is the timestamp of the last confirmed message. It cannot be attacked without controlling enough mana to accept incorrect timestamps, making it a reliable, attack-resistant quantity.</p>
<p>Typically speaking, <code>CurrentTime - TangleTime</code> is, on average, the  approximate confirmation time of messages.  Thus, if this difference is too far off, then we can conclude that we do not know which messages are confirmed and thus we are out of sync.  In this spirit, we are able to define the following function.</p>
<pre><code class="language-go">func Synced() bool {
  if CurrentTime - TangleTime &lt;= SYNC_THRESHOLD {
    return true
  }
  
  return false
}
</code></pre>
<p>The following figure displays the Tangle Time visually: 
<img src="https://i.imgur.com/rndN8qc.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autopeering"><a class="header" href="#autopeering">Autopeering</a></h1>
<p>In order to establish connections, an IOTA node needs to discover and maintain a list of the reachable IP addresses of other peers. Nodes to be kept up-to-date about the ledger state, thus they exchange information with each other. Each node establishes a communication channel with a small subset of nodes (i.e., neighbors) via a process called <code>peering</code>. Such a process must be resilient against eclipse attacks: if all of a node’s neighbors are controlled by an attacker, then the attacker has complete control over the node’s view of the Tangle. Moreover, to prevent or limitate sybil-based attacks, the neighbor selection protocol makes use of a scarce resource dubbed Consensus Mana: arbitrary nodes can be created, but it is difficult to produce high mana nodes.</p>
<p>Throughout this section the terms <code>Node</code> and <code>Peer</code> are used interchangeably to refer to a <code>Node</code> device.</p>
<p>The usage of the <em>Ping</em> and <em>Pong</em> mechanism is to be considered as a bidirectional exchange similarly to how described by other standards such as <a href="https://core-wg.github.io/coap-sig/">CoAP</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">WebSocket</a>.</p>
<h2 id="node-identities"><a class="header" href="#node-identities">Node identities</a></h2>
<p>Every node has a cryptographic identity, a key on the ed25519 elliptic curve. The <code>blake2b</code> hash of the public key of the peer serves as its identifier or <code>node ID</code>.</p>
<h2 id="peer-discovery"><a class="header" href="#peer-discovery">Peer Discovery</a></h2>
<p>The main goal of the <em>Peer Discovery</em> protocol is to expose an interface providing a list of all the verified peers.
To bootstrap the peer discovery, a node <em>must</em> be able to reach one or more entry nodes. To achieve this, the implementation of the protocol <em>shall</em> provide a hard-coded list of trusted <strong>entry nodes</strong> run by the IF or by trusted community members that answer to peer discovery packets coming from new nodes joining the IOTA network. This approach is a common practice of many distributed networks <a href="https://ieeexplore.ieee.org/iel7/9739/8649699/08456488.pdf">[Neudecker 2018]</a>. 
Public Key-based Cryptography (PKC) <em>shall</em> be used for uniquely <a href="protocol_specification/autopeering.html#Node_identities">identifying</a> peers and for authenticating each packet. 
The usage of the Ping and Pong protocols is that <em>Ping</em> are sent to verify a given peer and, upon reception of a valid <em>Pong</em> as a response from that peer, the peer is verified.
Once a peer has been verified, it can be queried to discover new peers by sending a <em>DiscoveryRequest</em>. As a response, a <em>DiscoveryResponse</em> <em>shall</em> be returned, containing a list of new peers. The new peer nodes in this list <em>shall</em> be verified by the receiving application.</p>
<p>This process is summarized in the following figure and detailed in the following subsections:</p>
<p><img src="https://i.imgur.com/U51tPeK.png" alt="" /></p>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>The verification process aims at both verifying peer identities and checking their online status. Each peer <em>shall</em> maintain a list of all the known peers. This list <em>shall</em> be called <code>known_peer_list</code>. Elements of any known peer list <em>shall</em> contain a reference to a <a href="protocol_specification/autopeering.html#Peer">Peer</a> and a time at which it <em>shall</em> be verified/re-verified. 
As such, the <code>known_peer_list</code> can be seen as a time-priority queue. A newly discovered peer gets added to the list at the current time. Whenever a peer is verified, its time value on the <code>known_peer_list</code> gets updated to the time at which that peer <em>shall</em> be re-verified. 
The intent of this arrangement is to allow the node application to first verify newly discovered (and thus still unverified) peers and then to re-verify older peers (to confirm their online status) by iterating over the <code>known_peer_list</code>.
It is worthwhile to note that the order in which the <code>known_peer_list</code> is worked through is important. For example, if the peer is added to the front ('head') of the <code>known_peer_list</code>, it is possible for an adversary to front-fill the <code>known_peer_list</code> with a selection of its own nodes. This is resolved by the use of the time-priority queue.</p>
<p>The verification process always initiates from a <em>Ping</em>. Upon reception of a <em>Ping</em>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <em>Ping</em> is valid and discarding the request otherwise;</li>
<li>checking that the <code>version</code> and <code>network_id</code> fields match its configuration and discarding the <em>Ping</em> otherwise;</li>
<li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the packet otherwise;</li>
<li>checking that the <code>dest_addr</code> matches its IP address and discarding the <em>Ping</em> otherwise.</li>
</ul>
<p>Upon successful validation of a received <em>Ping</em>, a peer <em>shall</em> respond with a <em>Pong</em>. In case the sender of the <em>Ping</em> is a new peer from the perspective of the receiving node, the receiver peer <em>shall</em> add it to its <code>known_peer_list</code>. This enables the verification process to also occur in the reverse direction. </p>
<p>Upon reception of a <em>Pong</em>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <em>Pong</em> is valid and discarding it otherwise;</li>
<li>checking that the <code>req_hash</code> field matches a request (i.e. <em>Ping</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>Ping</em> and <em>Pong</em> is not greater than a given threshold) and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise;</li>
<li>checking that the <code>dest_addr</code> matches its IP address and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise.</li>
</ul>
<p>Upon successful validation of a received <em>Pong</em>, a peer <em>shall</em>:</p>
<ul>
<li>add the peer sender of the <em>Pong</em> to a list of verified peers called <code>verified_peer_list</code>;</li>
<li>move the peer entry of the <code>known_peer_list</code> to the tail.</li>
</ul>
<h3 id="removal"><a class="header" href="#removal">Removal</a></h3>
<p>While verifying a new peer, if no or an invalid <em>Pong</em> is received after <code>max_verify_attempts</code> attempts, that node <em>shall</em> be removed from the <code>known_peer_list</code>. Each expected reply should have a timeout such that if no answer is received after that, an attempt is considered concluded and counted as failed. </p>
<p>Each peer on the <code>verified_peer_list</code> <em>shall</em> be re-verified after <code>verification_lifetime</code> hours; while re-verifying a peer, if no or invalid <em>Pong</em> is received after <code>max_reverify_attempts</code> attempts, the peer <em>shall</em> be removed from the <code>verified_peer_list</code>.</p>
<h3 id="discovery"><a class="header" href="#discovery">Discovery</a></h3>
<p>Each peer entry of the <code>verified_peer_list</code> may be used to discover new peers. This process is initiated by sending a <em>DiscoveryRequest</em>.</p>
<p>Upon reception of a <em>DiscoveryRequest</em>, a peer node <em>shall</em> check its validity by:</p>
<ul>
<li>checking that the sender of the <em>DiscoveryRequest</em> is a verified peer (i.e. is stored in the <code>verified_peer_list</code>) and discarding the request otherwise;</li>
<li>verifying that the signature of the <em>DiscoveryRequest</em> is valid and discarding the request otherwise;</li>
<li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the request otherwise.</li>
</ul>
<p>Upon successful validation of a received <em>DiscoveryRequest</em>, a peer <em>shall</em> reply with a <em>DiscoveryResponse</em>.</p>
<p>Upon reception of a <em>DiscoveryResponse</em>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <em>DiscoveryResponse</em> is valid and discarding the response otherwise;</li>
<li>checking that the <code>req_hash</code> field matches a discovery request (i.e. <em>DiscoveryRequest</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>DiscoveryRequest</em> and <em>DiscoveryResponse</em> is not greater than a given threshold) and discarding the response otherwise.</li>
</ul>
<p>Upon successful validation of a received <em>DiscoveryResponse</em>, a node <em>shall</em> add the nodes contained in the <code>peers</code> field to the <code>known_peer_list</code>.</p>
<h2 id="neighbor-selection"><a class="header" href="#neighbor-selection">Neighbor Selection</a></h2>
<p>The goal of the neighbor selection is to build a node's neighborhood (to be used by the gossip protocol) while preventing attackers from “tricking” other nodes into becoming neighbors. Neighbors are established when one node sends a peering request to another node, which in turn accepts or rejects the request with a peering response. </p>
<p>To prevent attacks, the protocol makes the peering request <em>verifiably random</em> such that attackers cannot create nodes to which the target node will send requests. At its core, the neighbor selection protocol uses both a screening process called <em>Consensus Mana rank</em> and a <em>score function</em> that takes into account some randomness dubbed <em>private salt</em> and <em>public salt</em>. 
Half of the neighbors will be constituted from nodes that accepted the peering request, while half will be constituted of nodes that will request for the peering. The two distinct groups of neighbors are consequently called:
+ Chosen neighbors (outbound). The peers that the node proactively selected through the neighbor selection mechanism.
+ Accepted neighbors (inbound). The peers that sent the peering request to the node and were accepted as a neighbor.</p>
<h3 id="local-variables"><a class="header" href="#local-variables">Local variables</a></h3>
<p>Local variables defined here are included to help in understanding the protocol described in this section. The node application shall handle those variables in some form.</p>
<ul>
<li><code>saltUpdateInterval</code>: The time interval at which nodes shall update their salts.</li>
<li><code>responseTimeout</code>: The time that node waits for a response during one peering attempt.</li>
<li><code>requestExpirationTime</code>: The time used for the request timestamp validation, if the timestamp is older than this threshold the request is dropped</li>
<li><code>maxPeeringAttempts</code>: The maximum number of peering requests retries sent to the selected node before the next salt update.</li>
</ul>
<h3 id="mana-rank-interval"><a class="header" href="#mana-rank-interval">Mana rank interval</a></h3>
<p>Each peer discovered and verified via the <em>Peer Discovery</em> protocol <em>shall</em> have a consensus mana value associated with it. The peer running the <em>Neighbor Selection</em> protocol <em>shall</em> keep this information up-to-date and use it to update a data structure called <code>manaRank</code> containing the list of the nodes' identities for each mana value. The aim of this ranking is to select a subset of peers having similar mana to the node preparing the ranking. More specifically, let's define <code>potentialNeighbors</code> to be such a subset, that is divided into a <code>lower</code> and an <code>upper</code> set with respect to a <code>targetMana</code> value (i.e., the mana value of the node performing the ranking). By iterating over the <code>manaRank</code>, each node <em>shall</em> fill both the <code>lower</code> and  <code>upper</code> sets with nodes' identities having a similar rank to itself, not less/greater than a given threshold <code>rho</code> respectively, except when each subset does not reach the minimal size <code>r</code>.</p>
<p>The following pseudocode describes a reference implementation of this process:</p>
<pre><code>Inputs: 
    manaRank: mapping between mana values and the list of nodes' identities with that mana; 
    targetMana: the mana value of the node performing the ranking;
    rho: the ratio determining the length of the rank to consider;
    r: the minimum number of nodes' identities to return for both lower and upper sets;
    Largest(r, targetMana): the set of r largest cMana holders less than targetMana;
    Smallest(r, targetMana): the set of r smallest cMana holders greater than targetMana;

Outputs:
    potentialNeighbors: the set of nodes' identities to consider for neighbor selection;
</code></pre>
<pre><code class="language-vbnet">FOR mana IN manaRank
    nodeID = manaRank[mana]
    IF mana &gt; targetMana
        IF mana / targetMana &lt; rho
            Append(upperSet, nodeID)
    ELSE IF mana == 0 || mana == targetMana
        BREAK
    ELSE IF targetMana / mana &lt; rho
        Append(lowerSet, nodeID)

IF Len(lowerSet) &lt; r
	// set lowerSet with the r largest mana holders less than targetMana
	lowerSet = Largest(r, targetMana)
	
IF Len(upperSet) &lt; r
    // set upperSet with the r smallest mana holders greater than targetMana
	upperSet = Smallest(r, targetMana)

potentialNeighbors = Append(upperSet, lowerSet)
RETURN potentialNeighbors

</code></pre>
<h3 id="selection"><a class="header" href="#selection">Selection</a></h3>
<p>The maximum number of neighbors is a parameter of the gossip protocol. This section proposes to use a size of 8 equally divided into 4 chosen (outbound) and 4 accepted (inbound) neighbors. It is crucial to decide on a fixed number of neighbors, as the constant number decreases an eclipse probability exponentially. The chosen <em>k</em> is a compromise between having more connections resulting in lower performance and increased protection from an eclipse attack.</p>
<p>The operations involved during neighbor selection are listed in the following:</p>
<ol>
<li>Get an up-to-date list of verified and known peers from the <em>Peer Discovery</em> protocol. </li>
<li>Use <a href="protocol_specification/autopeering.html#Mana_rank">mana rank</a> to filter the previous list to obtain a list of peers to be potential neighbors.</li>
<li>Use the score function to request/accept neighbors.</li>
</ol>
<p>The score between two nodes is measured through the score function <em>s</em>, defined by:</p>
<p>s(nodeID1, nodeID2, salt) = hash(nodeID1 || nodeID2 || salt), where:</p>
<ul>
<li><code>nodeID1</code> and <code>nodeID2</code> are the identities of the considered nodes.</li>
<li><code>salt</code> is the salt value that can be private or public depending on the peering direction (inbound/outbound).</li>
<li><code>hash</code> is the <code>blake2b</code> hash function.</li>
<li><code>||</code> is the concatanation operation.</li>
</ul>
<p>Note that the value used as the score is an unsigned integer derived from the first 4 bytes of the byte array after the <code>hash</code> function.</p>
<p>In order to connect to new neighbors, each node with ID <code>ownID</code> and public salt <code>pubSalt</code> keeps a list of potential neighbors derived via <a href="protocol_specification/autopeering.html#Mana_rank">Mana rank</a> that is sorted by their score <code>d(ownID, ·, pubSalt)</code>. Then, the node shall send peering requests in <em>ascending order</em>, containing its own current public salt and a timestamp representing the issuance time of the request. 
The connecting node shall repeat this process until it has established connections to enough neighbors or it finds closer peers. Those neighbors make up its list of chosen neighbors. This entire process is also illustrated in the following pseudocode:</p>
<pre><code>Inputs: 
    k: desired amount of neighbors; 
    c: current list of chosen neighbors; 
    p: list of potential peers;
    localID: local nodeID 
    pubSalt: local public salt;
</code></pre>
<pre><code class="language-vbnet">pSorted = SortByScoreAsc(P, localID, pubSalt)
FOR p IN pSorted
    peeringRequest = SendPeeringRequest(p)
    IF peeringRequest.accepted 
        Append(c, p)
        IF Len(c) == Ceil(k/2) 
            RETURN
</code></pre>
<p>More specifically, after sending a peering request a node <em>shall</em>:</p>
<ul>
<li>wait to get a <em>Peering Response</em> that could be positive or negative. 
<ul>
<li>If positive, add the peer to its chosen neighbor list</li>
<li>If negative, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li>
<li>If after <code>responseTimeout</code> no response is received, try again for a fixed <code>maxPeeringAttempts</code>. If not successful, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li>
</ul>
</li>
</ul>
<p>Similar to the previous case, in order to accept neighbors, every node with ID ownID <em>shall</em> generate a private salt <code>privSalt</code>.</p>
<p>Upon reception of a <em>Peering Request</em>, a peer <em>shall</em> make a decision to accept, reject or discard the request by:</p>
<ul>
<li>verifying that the signature of the <em>Peering Request</em> is valid and discard the request otherwise;</li>
<li>checking that the <code>timestamp</code> field is valid (i.e., not older than a given threshold <code>requestExpirationTime</code> specified by the node) and discard the request otherwise;</li>
<li>checking that the <em>mana</em> of the requester peer is within the own <a href="protocol_specification/autopeering.html#Mana_rank">Mana rank</a> and send back a <em>negative</em> <em>Peering Response</em> otherwise;</li>
<li>checking that the requestor salt matches its hash chain by:
<ul>
<li>taking the difference between the timestamp of the peering request and the time the initial salt was set, and then dividing this number by <code>saltUpdateInterval</code>, rounding down;</li>
<li>hashing the requester public salt as many times as the number of salt changes;</li>
<li>finally, if the result does not match the initial salt, discard the peering request;</li>
</ul>
</li>
<li>applying a statistical test to the request defined as <em>s(remoteID, ownID, ζ_remote) &lt; θ</em> for a fixed threshold θ, and discard it otherwise. 
<ul>
<li>this test determines the effectiveness of the brute force attack when an attacker tries to establish a connection with a desired peer;</li>
<li>with θ set to 0.01 an attacker has only 1% of chance of being successful;</li>
</ul>
</li>
<li>accept the peering request by sending back a <em>positive</em> <em>Peering Response</em> if either one of the following conditions is satisfied, and send back a <em>negative</em> <em>Peering Response</em> otherwise:
<ul>
<li>the current size of the accepted neighbors list is smaller than <em>Floor(k/2)</em>; </li>
<li>the score defined as <em>s(ownID, remoteID, privSalt)</em> is lower than the current highest score among accepted neighbors. In this case, send a <em>Peering Drop</em> to drop the accepted neighbor with the highest score replaced by the requester peer. </li>
</ul>
</li>
</ul>
<h3 id="neighbor-removal"><a class="header" href="#neighbor-removal">Neighbor Removal</a></h3>
<p>Neighbor removal can occur for several reasons:</p>
<ul>
<li>A node is replacing a neighbor with a better (in terms of score function) one;</li>
<li>From the gossip layer, the connection with a neighbor is lost;</li>
<li>If some form of reputation or bad behavior is being monitored, a neighbor could be dropped in case of misbehavior. For example, a node could respond to the peering request but choose not to gossip received messages.</li>
</ul>
<p>Independently from the reason, when a peer drops a neighbor <em>shall</em> send a <em>Peering Drop</em> and remove the neighbor from its requested/accepted neighbor list. Upon reception of a <em>Peering Drop</em>, the peer <em>shall</em> remove the dropping neighbor from its requested/accepted neighbor list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mana-implementation"><a class="header" href="#mana-implementation">Mana Implementation</a></h1>
<p>This document provides a high level overview of how mana is implemented in GoShimmer.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Mana is a reputation system for nodes within the IOTA network.</p>
<p>Reputation is gained by contributing to the network, i.e. creating value transfers.
As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The scope of the first implementation of mana into GoShimmer is to verify that mana calculations work,
study base mana calculations 1 &amp; 2, and mana distribution in the test network, furthermore to verify that nodes have
similar view on the network.</p>
<h2 id="mana-calculation"><a class="header" href="#mana-calculation">Mana Calculation</a></h2>
<p>Mana is essentially the reputation score of a node in the IOTA network. Mana is calculated locally in each node, as a
function that takes value transactions as input and produces the Base Mana Vector as output.</p>
<p>Each transaction has an <code>accessMana</code> and <code>consensusMana</code> field that determine which node to pledge these two types
of mana to. Both of these fields denote a <code>nodeID</code>, the receiver of mana. <code>accessMana</code> and <code>consensusMana</code> do not have
to be pledged to the same node, but for simplicity, in the first implementation, they will be.</p>
<p>In addition to the mana fields, a <code>timestamp</code> field is also added to the transactions that will be utilized for calculating
decay and effective mana.</p>
<p>From the pledged mana of a transaction, a node can calculate locally the <code>Base Mana Vector</code> for both <code>Access Mana</code> and
<code>Consensus Mana</code>.</p>
<p>A <code>Base Mana Vector</code> consists of Base Mana 1 and Base Mana 2 and their respective <code>Effective Base Mana</code>.
Given a value transaction, Base Mana 1 and Base Mana 2 are determined as follows:</p>
<ol>
<li>Base Mana 1 is revoked from the node that created the output(s) used as input(s) in the transaction, and is pledged to
the node creating the new output(s). The amount of <code>Base Mana 1</code> revoked and pledged is equal to the balance of the
input.</li>
<li>Base Mana 2 is freshly created at the issuance time of the transaction, awarded to the node, but decays with time.
The amount of <code>Base Mana 2</code> pledged is determined with <code>Pending Mana</code> concept: funds sitting at an address generate
<code>pending mana</code> that grows over time, but bounded.
<ul>
<li><code>Mana_pending = (alpha*S)/gamma*(1-e^(-gamma*t))</code>, where <code>alpha</code> and <code>gamma</code> are chosen parameters, <code>S</code> is the amount
of funds an output transfers to the address, and <code>t</code> is the time since the funds are on that address.</li>
</ul>
</li>
</ol>
<p>An example <code>Base Mana Vector</code> for <code>Access Mana</code> could look like this:</p>
<p>| 		    | Node 1 | Node 2 | ... | Node k |
|  ------- | --------- | ---------- | ------ | --- |
| Base Mana 1 			|0	| 1 	|...|  100.54 |
| Effective Base Mana 1	|0	| 0.5 	|...|  120.7 |
| Base Mana 2 			|0	| 1.2	|...|  0.01 |
| Effective Base Mana 2	|0	| 0.6 	|...|  0.015 |</p>
<p><code>Base Mana</code> is pledged or revoked at discrete times, which results in <code>Base Mana</code> being discontinuous function over time.
In order to make mana &quot;smoother&quot; and continuous, an exponential moving average is applied to the <code>Base Mana</code> values,
resulting in <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code>.</p>
<p>It is important to note, that consuming a new transaction and pledging its mana happens when the transaction is
confirmed on the node. At the same time, entries of the nodes whose mana is being modified during pledging in the
<code>Base Mana Vector(s)</code> are updated with respect to time. In general, updates due to time happen whenever a node's mana is
being accessed. Except for the aforementioned case, this could be for example a mana related query from an external
module (FPC, Autopeering, DRNG, Rate Control, tools, etc.).</p>
<p>Following figure summarizes how <code>Access Mana</code> and <code>Consensus Mana</code> is derived from a transaction:</p>
<p><img src="https://i.imgur.com/LjfCTm9.png" alt="" /></p>
<p>The reason for having two separate <code>Base Mana Vectors</code> is the fact, that <code>accessMana</code> and <code>consensusMana</code> can be pledged
to different nodes.</p>
<p>The exact mathematical formulas, and their respective parameters will be determined later.</p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<h3 id="dependency-on-tangle"><a class="header" href="#dependency-on-tangle">Dependency on Tangle</a></h3>
<p>Since mana is awarded to nodes submitting value transfers, the tangle is needed as input for mana calculation.
Each node calculates mana locally, therefore, it is essential to determine when to consider transactions in the
tangle &quot;final enough&quot; (so that they will not be orphaned).</p>
<p>When a transaction is <code>confirmed</code>, it is a sufficient indicator that it will not be orphaned. However, in current
GoShimmer implementation, confirmation is not yet a properly defined concept. This issue will be addressed in a separate
module.</p>
<p>The Mana module assumes, that the (value) tangle's <code>TransactionConfirmed</code> event is the trigger condition to update the
mana state machine (base mana vectors for access and consensus mana). Once the concept of transaction finality is
introduced for the tangle, the trigger conditions for access and consensus mana calculations can be adjusted.</p>
<h3 id="transaction-layout"><a class="header" href="#transaction-layout">Transaction Layout</a></h3>
<p>A new field should be added to <code>Transaction</code> denoting <code>PledgedNodeID</code> for <code>Access Mana</code> and <code>Consensus Mana</code>.
This is also beneficial to implement mana donation feature, that is, to donate the mana of a certain transaction to an
arbitrary node.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The first implementation of mana in GoShimmer will:</p>
<ul>
<li>not have voted timestamps on value transactions,</li>
<li>lack proper <code>TransactionConfirmed</code> mechanism to trigger mana update,</li>
<li>lack integration into rate control/autopeering/fpc/etc.</li>
</ul>
<h2 id="detailed-design-2"><a class="header" href="#detailed-design-2">Detailed Design</a></h2>
<p>In this section, detailed GoShimmer implementation design considerations will be outlined about the mana module.
In short, changes can be classified into 3 categories:</p>
<ol>
<li>Transaction related changes,</li>
<li>Mana module functionality,</li>
<li>and related tools/utilities, such as API, visualization, analytics.</li>
</ol>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>As described above, 3 new fields will be added to the transaction layout:</p>
<ol>
<li><code>Timestamp</code> time.time</li>
<li><code>AccessManaNodeID</code> []bytes</li>
<li><code>ConsensusManaNodeID</code> []bytes</li>
</ol>
<p>By adding these fields to the signed transaction, <code>valuetransfers/packages/transaction</code> should be modified.</p>
<ul>
<li>The three new fields should be added to the transaction essence.</li>
<li>Marshalling and unmarshalling of a transaction should be modified.</li>
<li>For calculating <code>Base Mana 1</code> values, <code>mana module</code> should be able to derive from a transaction the nodes which received
pledged <code>Base Mana 1</code> as a consequence of the consumed inputs of the transaction. Therefore, a lookup function should
be exposed from the value tangle that given an <code>input</code>, returns the <code>pledgedNodeID</code> of the transaction creating the input.</li>
</ul>
<p><code>Timestamp</code> is part of the signed transaction, therefore, a client sending a transaction to the node should already
define it. In this case, this <code>Timestamp</code> will not be the same as the timestamp of the message containing the
transaction and value payload, since the message is created on the node.
A solution to this is that upon receiving a <code>transaction</code> from a client, the node checks if the timestamp is within
a predefined time window, for example <code>t_current - delta</code>, where <code>delta</code> could be couple seconds. If true, then the node
constructs the message, which must have a greater timestamp, than the transaction.</p>
<p><code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are also part of the signed transaction, so a client should fill them out.
Node owners are free to choose to whom they pledge mana to with the transaction, so there should be a mechanism that
lets the client know, what <code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are allowed. This could be a new API endpoint
that works like this:</p>
<ol>
<li>Client asks node what nodeIDs can be included for pledging  a certain type (access, consensus) mana.</li>
<li>Node answers with either:</li>
</ol>
<ul>
<li>Don't care. Any node IDs are valid.</li>
<li>List of nodeIDs that are allowed for each type.</li>
</ul>
<ol start="3">
<li>If a client sends back the transaction with invalid or empty mana fields, the transaction is considered invalid.</li>
</ol>
<p>This way node owners can decide who their transactions are pledging mana to. It could be only their node, or they could
provide mana pledging as a service. They could delegate access mana to others, but hold own to consensus mana, or the
other way around.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception
of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together
with the ledger state, base mana vectors are also saved, since a certain ledger state reflects a certain mana distribution
in the network. In future, when snapshotting is implemented in GoShimmer, nodes joining the network will be able to query
for snapshot files that will contain initial base mana vectors as well.</p>
<p>Until this functionality is implemented, mana calculation solely relies on transactions getting confirmed. That is, when
a node joins the network and starts gathering messages and transactions from peers, it builds its own ledger state through
solidification process. Essentially, the node requests all messages down to the genesis from the current tips of its neighbors.
Once the genesis is found, messages are solidified bottom up. For the value tangle, this means that for each solidified
and liked transaction, <code>TransactionConfirmed</code> event is triggered, updating the base mana vectors.</p>
<p>In case of a large database, initial synching and solidification is a computationally heavy task due to the sheer amount
of messages in the tangle. Mana calculation only adds to this burden. It will be determined through testing if additional
&quot;weight lifting&quot; mechanism is needed (for example delaying mana calculation).</p>
<p>In the GoShimmer test network, all funds are initially held by the faucet node, therefore all mana present at bootstrap belong
to this node. Whenever a transaction is requested from the faucet, it pledges mana to the requesting node, helping other
nodes to increase their mana.</p>
<h3 id="mana-package"><a class="header" href="#mana-package">Mana Package</a></h3>
<p>The functionality of the mana module should be implemented in a <code>mana</code> package. Then, a <code>mana plugin</code> can use the package
structs and methods to connect the dots, for example execute <code>BookMana</code> when <code>TransactionConfirmed</code> event is triggered
in the value tangle.</p>
<p><code>BaseMana</code> is a struct that holds the different mana values for a given node.
Note that except for <code>Base Mana 1</code> calculation, we need the time when <code>BaseMana</code> values were updated, so we store it in the struct:</p>
<pre><code class="language-go">type BaseMana struct {
 BaseMana1 float
 EffectiveBaseMana1 float
 BaseMana2 float
 EffectiveBaseMana2 float
 LastUpdated time
}
</code></pre>
<p><code>BaseManaVector</code> is a data structure that maps <code>nodeID</code>s to <code>BaseMana</code>. It also has a <code>Type</code> that denotes the type
of mana this vector deals with (Access, Consensus, etc.).</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p><code>BaseManaVector</code> should have the following methods:</p>
<ul>
<li><code>BookMana(transaction)</code>: Book mana of a transaction. Trigger <code>ManaBooked</code> event. Note, that this method updates
<code>BaseMana</code> with respect to time and to new <code>Base Mana 1</code> and <code>Base Mana 2</code> values.</li>
<li><code>GetWeightedMana(nodeID, weight) mana</code>: Return <code>weight</code> *<code> Effective Base Mana 1</code> + (1-<code>weight</code>)+<code>Effective Base Mana 2</code>.
<code>weight</code> is a number in [0,1] interval. Notice, that <code>weight</code> = 1  results in only returning <code>Effective Base Mana 1</code>,
and the other way around. Note, that this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>GetMana(nodeID) mana</code>: Return 0.5*<code>Effective Base Mana 1</code> + 0.5*<code>Effective Base Mana 2</code> of a particular node. Note, that
this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>update(nodeID, time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of a node with respect <code>time</code>.</li>
<li><code>updateAll(time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of all nodes with respect to <code>time</code>.</li>
</ul>
<p><code>BaseMana</code> should have the following methods:</p>
<ul>
<li><code>pledgeAndUpdate(transaction)</code>: update <code>BaseMana</code> fields and pledge mana with respect to <code>transaction</code>.</li>
<li><code>revokeBaseMana1(amount, time)</code>:  update <code>BaseMana</code> values with respect to <code>time</code> and revoke <code>amount</code> <code>BaseMana1</code>.</li>
<li><code>update(time)</code>: update all <code>BaseMana</code> fields with respect to <code>time</code>.</li>
<li><code>updateEBM1(time)</code>: update <code>Effective Base Mana 1</code> wrt to <code>time</code>.</li>
<li><code>updateBM2(time)</code>: update <code>Base Mana 2</code> wrt to <code>time</code>.</li>
<li><code>updateEBM2(time)</code>: update <code>Effective Base Mana 2</code> wrt to <code>time</code>.</li>
</ul>
<h4 id="base-mana-calculation"><a class="header" href="#base-mana-calculation">Base Mana Calculation</a></h4>
<p>There are two cases when the values within <code>Base Mana Vector</code> are updated:</p>
<ol>
<li>A confirmed transaction pledges mana.</li>
<li>Any module accesses the <code>Base Mana Vector</code>, and hence its values are updated with respect to <code>access time</code>.</li>
</ol>
<p>First, let's explore the former.</p>
<h5 id="a-confirmed-transaction-pledges-mana"><a class="header" href="#a-confirmed-transaction-pledges-mana">A confirmed transaction pledges mana</a></h5>
<p>For simplicity, we only describe mana calculation for one of the Base Mana Vectors, namely, the Base Access Mana Vector.</p>
<p>First, a <code>TransactionConfirmed</code> event is triggered, therefore <code>BaseManaVector.BookMana(transaction)</code> is executed:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) BookMana(tx *transaction) {
    pledgedNodeID := tx.accessMana

    for input := range tx.inputs {
        // search for the nodeID that the input's tx pledged its mana to
        inputNodeID := loadPledgedNodeIDFromInput(input)
        // save it for proper event trigger
        oldMana := bmv[inputNodeID]
        // revoke BM1
        bmv[inputNodeID].revokeBaseMana1(input.balance, tx.timestamp)

        // trigger events
        Events.ManaRevoked.Trigger(&amp;ManaRevokedEvent{inputNodeID, input.balance, tx.timestamp, AccessManaType})
        Events.ManaUpdated.Tigger(&amp;ManaUpdatedEvent{inputNodeID, oldMana, bmv[inputNodeID], AccessManaType})
    }

    // save it for proper event trigger
    oldMana :=  bmv[pledgedNodeID]
    // actually pledge and update
    bm1Pledged, bm2Pledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)

    // trigger events
    Events.ManaPledged.Trigger(&amp;ManaPledgedEvent{pledgedNodeID, bm1Pledged, bm2Pledged, tx.timestamp, AccessManaType})
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{pledgedNodeID, oldMana, bmv[pledgedNodeID], AccessManaType})
}
</code></pre>
<p><code>Base Mana 1</code> is being revoked from the nodes that pledged mana for inputs that the current transaction consumes.
Then, the appropriate node is located in <code>Base Mana Vector</code>, and mana is pledged to its <code>BaseMana</code>.
<code>Events</code> are essential to study what happens within the module from the outside.</p>
<p>Note, that <code>revokeBaseMana1</code> accesses the mana entry of the nodes within <code>Base Mana Vector</code>, therefore all values are
updated with respect to <code>t</code>. Notice the two branches after the condition. When <code>Base Mana</code> values had been updated before
the transaction's timestamp, a regular update is carried out. However, if <code>t</code> is older, than the transaction timestamp,
an update in the &quot;past&quot; is carried out and values are updated up to <code>LastUpdated</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) revokeBaseMana1(amount float64, t time.Time) {
	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)

		bm.LastUpdated = t
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
	} else {
		// update in past
		n := bm.LastUpdated.Sub(t)
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
		// update EBM1 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
	}
}
</code></pre>
<p>The same regular and past update scheme is applied to pledging mana too:</p>
<pre><code class="language-go">func (bm *BaseMana) pledgeAndUpdate(tx *transaction) (bm1Pledged int, bm2Pledged int){
	t := tx.timestamp
	bm1Pledged = sum_balance(tx.inputs)

	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)
		bm.LastUpdated = t
		bm.BaseMana1 += bm1Pledged
		// pending mana awarded, need to see how long funds sat
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
	} else {
		// past update
		n := bm.LastUpdated.Sub(t)
		// update BM1 and BM2 at `t`
		bm.BaseMana1 += bm1Pledged
		oldMana2 = bm.BaseMana2
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
		// update EBM1 and EBM2 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
		if EMA_coeff_2 != decay {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-
                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)
		} else {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) * decay * n
		}
}
	return bm1Pledged, bm2Pledged
}
</code></pre>
<p>Notice, that in case of <code>EMA_coeff_2 = decay</code>, a simplified formula can be used to calculate <code>EffectiveBaseMana2</code>.
The same approach is applied in <code>updateEBM2()</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) updateEBM1(n time.Duration) {
    bm.EffectiveBaseMana1 = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectiveBaseMana1 +
                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BaseMana1
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateBM2(n time.Duration) {
    bm.BaseMana2 = bm.BaseMana2 * math.Pow(math.E, -decay*n)
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateEBM2(n time.Duration) {
	if EMA_coeff_2 != decay {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveBaseMana2 +
			(math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /
				(EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseMana2
	} else {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -decay * n)*bm.EffectiveBaseMana2 +
			decay * n * bm.BaseMana2
	}
}
</code></pre>
<h5 id="any-module-accesses-the-base-mana-vector"><a class="header" href="#any-module-accesses-the-base-mana-vector">Any module accesses the Base Mana Vector</a></h5>
<p>In this case, the accessed entries within <code>Base Mana Vector</code> are updated via the method:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) update(nodeID ID, t time.Time ) {
    oldMana :=  bmv[nodeID]
    bmv[nodeID].update(t)
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{nodeID, oldMana, bmv[nodeID], AccessManaType})
}
</code></pre>
<p>where <code>t</code> is the access time.</p>
<pre><code class="language-go">func (bm *BaseMana) update(t time.Time ) {
    n := t - bm.LastUpdated
    bm.updateEBM1(n)
    bm.updateBM2(n)
    bm.updateEBM2(n)

    bm.LastUpdated = t
}
</code></pre>
<h4 id="events"><a class="header" href="#events">Events</a></h4>
<p>The mana package should have the following events:</p>
<ul>
<li><code>Pledged</code> when mana (<code>BM1</code> and <code>BM2</code>) was pledged for a node due to new transactions being confirmed.</li>
</ul>
<pre><code class="language-go">type PledgedEvent struct {
    NodeID []bytes
    AmountBM1 int
    AmountBM2 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Revoked</code> when mana (<code>BM1</code>) was revoked from a node.</li>
</ul>
<pre><code class="language-go">type RevokedEvent struct {
    NodeID []bytes
    AmountBM1 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Updated</code> when mana was updated for a node due to it being accessed.</li>
</ul>
<pre><code class="language-go">type UpdatedEvent struct {
    NodeID []bytes
    OldMana BaseMana
    NewMana BaseMana
    Type    ManaType // access or consensus
}
</code></pre>
<h4 id="testing"><a class="header" href="#testing">Testing</a></h4>
<ul>
<li>Write unit tests for all methods.</li>
<li>Test all events and if they are correctly triggered.</li>
<li>Benchmark calculations in tests to see how heavy it is to calculate EMAs and decays.</li>
</ul>
<h3 id="mana-plugin"><a class="header" href="#mana-plugin">Mana Plugin</a></h3>
<p>The <code>mana plugin</code> is responsible for:</p>
<ul>
<li>calculating mana from value transactions,</li>
<li>keeping a log of the different mana values of all nodes,</li>
<li>updating mana values,</li>
<li>responding to mana related queries from other modules,</li>
<li>saving base mana vectors in database when shutting down the node,</li>
<li>trying to load base mana vectors from database when starting the node.</li>
</ul>
<p>The proposed mana plugin should keep track of the different mana values of nodes and handle calculation
updates. Mana values are mapped to <code>nodeID</code>s and stored in a <code>map</code> data structure. The vector also stores information on
what <code>Type</code> of mana it handles.</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<p><code>Access Mana</code> and <code>Consensus Mana</code> should have their own respective <code>BaseManaVector</code>.</p>
<pre><code class="language-go">accessManaVector := BaseManaVector{vectorType: AccesMana}
consensusManaVector :=  BaseManaVector{vectorType: ConsensusMana}
</code></pre>
<p>In the future, it should be possible to combine <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> from a <code>BaseManaVector</code>
in arbitrary proportions to arrive at a final mana value that other modules use. The <code>mana package</code> has these methods
in place. Additionally, a parameter could be passed to the <code>getMana</code> type of exposed functions to set the proportions.</p>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<p>The mana plugin should expose utility functions to other modules:</p>
<ul>
<li><code>GetHighestManaNodes(type, n) [n]NodeIdManaTuple</code>: return the <code>n</code> highest <code>type</code> mana nodes (<code>nodeID</code>,<code>manaValue</code>) in
ascending order. Should also update their mana value.</li>
<li><code>GetManaMap(type) map[nodeID]manaValue</code>: return <code>type</code> mana perception of the node.</li>
<li><code>GetAccessMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Access Mana</code>, update its values with respect to time,
and return the amount of <code>Access Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetConsensusMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Consensus Mana</code>, update its values with respect to time,
and returns the amount of <code>Consensus Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetNeighborsMana(type)</code>: returns the <code>type</code> mana of the nodes neighbors</li>
<li><code>GetAllManaVectors()</code> Obtaining the full mana maps for comparison with the perception of other nodes.</li>
<li><code>GetWeightedRandomNodes(n)</code>: returns a weighted random selection of <code>n</code> nodes. <code>Consensus Mana</code> is used for the weights.</li>
<li>Obtaining a list of currently known peers + their mana, sorted. Useful for knowing which high mana nodes are online.</li>
<li><code>OverrideMana(nodeID, baseManaVector)</code>: Sets the nodes mana to a specific value. Can be useful for debugging, setting faucet mana, initialization, etc.. Triggers <code>ManaUpdated</code></li>
</ul>
<p>Such utility functions could be used for example to visualize mana distribution in node dashboard, or send neighbor
mana data to the analysis server for further processing.</p>
<h4 id="booking-mana"><a class="header" href="#booking-mana">Booking Mana</a></h4>
<p>Mana is booked when a transaction is confirmed.</p>
<pre><code class="language-go">on TransactionConfirmed (tx):
 bookAccessMana()
 bookConsensusMana()
</code></pre>
<h4 id="synchronization-and-mana-calculation"><a class="header" href="#synchronization-and-mana-calculation">Synchronization and Mana Calculation</a></h4>
<p>The mana plugin is responsible to determine when to start calculating mana locally.
Since mana state is an extension to ledger state, it can only depict realistic mana values once the node is in sync.
During syncing, ledger state is constructed from messages coming from neighbors as described further above.</p>
<p>In this first iteration, mana plugin relies on <code>TransactionConfirmed</code> event of the value transfers plugin, and has no
explicit rules on when to start and stop mana calculation.</p>
<p>In future, initial mana state (together with the initial ledger state) will be derived from a snapshot file.</p>
<h3 id="mana-toolkit"><a class="header" href="#mana-toolkit">Mana Toolkit</a></h3>
<p>In this section, all tools and utility functions for mana will be outlined.</p>
<h4 id="mana-related-api-endpoints"><a class="header" href="#mana-related-api-endpoints">Mana Related API endpoints</a></h4>
<ul>
<li><code>/info</code>: Add own mana in node info response.</li>
<li><code>value/allowedManaPledge</code>: Endpoint that clients can query to determine which nodeIDs are allowed as part of
<code>accessMana</code> and <code>consensusMana</code> fields in a transaction.</li>
<li><code>value/sendTransactionByJson</code>: Add <code>accessMana</code>, <code>consensusMana</code> and <code>timestamp</code> fields to the JSON request.</li>
</ul>
<p>Add a new <code>mana</code> endpoint route:</p>
<ul>
<li><code>/mana</code>: Return access and consensus mana of the node.</li>
<li><code>/mana/all</code>: Return whole mana map (mana perception of the node).</li>
<li><code>/mana/access/nhighest</code>: Return <code>n</code> highest access mana holder <code>nodeIDs</code> and their access mana values.</li>
<li><code>/mana/consensus/nhighest</code>: Return <code>n</code> highest consensus mana holder <code>nodeIDs</code> and their consensus mana values.</li>
<li><code>/mana/percentile</code>: Return the top percentile the node belongs to relative to the network. For example, if there are 100 nodes in the
network owning mana, and a node is the 13th richest, it means that is part of the top 13% of mana holders, but not the
top 12%.</li>
</ul>
<h4 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics collection</a></h4>
<p>To study the mana module, following metrics could be gathered:</p>
<ul>
<li>Amount of consensus and access mana present in the network. (amount varies because of <code>Base Mana 2</code>).</li>
<li>Amount of mana each node holds.</li>
<li>Number of (and amount of mana) a node was pledged with mana in the last <code>t</code> interval.</li>
<li>Mana development of a particular node over time.</li>
<li>Mana percentile development of a node over time.</li>
<li>Average pledge amount of a node. (how much mana it receives on average with one pledge)</li>
<li>Mean and median mana holdings of nodes in the network. Shows how even mana distribution is.</li>
<li>Average mana of neighbors.</li>
</ul>
<h4 id="visualization"><a class="header" href="#visualization">Visualization</a></h4>
<p>Each node calculates mana locally, not only for themselves, but for all nodes in the network that it knows. As a result,
mana perception of nodes may not be exactly the same at all times (due to network delay, processing capabilities), but
should converge to the same state. A big question for visualization is which node's viewpoint to base mana visualization on? </p>
<p>When running a node, operators will be shown the mana perception of their own node, but it also makes sense to
display the perception of high mana nodes as the global mana perception. First, let's look at how local mana perception
is visualized for a node:</p>
<h5 id="local-perception"><a class="header" href="#local-perception">Local Perception</a></h5>
<p>There are two ways to visualize mana in GoShimmer:</p>
<ol>
<li>Node Local Dashboard</li>
<li>Grafana Dashboard</li>
</ol>
<p>While <code>Local Dashboard</code> gives flexibility in what and how to visualize, <code>Grafana Dashboard</code> is better at storing historic
data but can only visualize time series. Therefore, both of these ways will be utilized, depending on which suits the best.</p>
<p><code>Local Dashboard</code> visualization:</p>
<ul>
<li>Histogram of mana distribution within the network.</li>
<li>List of <code>n</code> richest mana nodes, ordered.</li>
<li>Mana rank of node.</li>
</ul>
<p><code>Grafana Dashboard</code> visualization:</p>
<ul>
<li>Mana of a particular node with respect to time.</li>
<li>Amount of mana in the network.</li>
<li>Average pledge amount of a node.</li>
<li>Mean and median mana holdings of nodes.</li>
<li>Mana rank of the node over time.</li>
<li>Average mana of neighbors.</li>
</ul>
<h5 id="global-perception"><a class="header" href="#global-perception">Global Perception</a></h5>
<p>Additionally, the GoShimmer Analyzer (analysis server) could be updated:</p>
<ul>
<li>Autopeering node graph, where size of a node corresponds to its mana value.</li>
<li>Some previously described metrics could be visualized here as well, to give the chance to people without
a node to take a look. As an input, a high mana node's perception should be used.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="congestion-control"><a class="header" href="#congestion-control">Congestion Control</a></h1>
<p>Every network has to deal with its intrinsic limited resources in terms of bandwidth and node capabilities (CPU and storage). In this document, we present a congestion control algorithm to regulate the influx of messages in the network with the goal of maximizing throughput (messages/bytes per second) and minimizing delays. Furthermore, the following requirements must be satisfied:</p>
<ul>
<li><em>Consistency</em>. If a message is written by one honest node, it shall be written by all honest nodes within some delay bound.</li>
<li><em>Fairness</em>. Nodes can obtain a share of the available throughput depending on their access Mana. Throughput is shared in such a way that an attempt to increase the allocation of any node necessarily results in the decrease in the allocation of some other node with an equal or smaller allocation (max-min fairness).</li>
<li><em>Security</em>. Malicious nodes shall be unable to interfere with either of the above requirements.</li>
</ul>
<p><img src="protocol_specification/./congestion_control_algorithm_infographic.png" alt="Congestion Control" /></p>
<p>Further information can be found in the paper <a href="https://arxiv.org/abs/2005.07778">Access Control for Distributed Ledgers in the Internet of Things: A Networking Approach</a>.</p>
<h2 id="detailed-design-3"><a class="header" href="#detailed-design-3">Detailed design</a></h2>
<p>Our algorithm has three core components: </p>
<ul>
<li>A scheduling algorithm which ensures fair access for all nodes according to their access Mana.</li>
<li>A TCP-inspired algorithm for decentralized rate setting to efficiently utilize the available bandwidth while preventing large delays.</li>
<li>A blacklisting policy to ban malicious nodes.</li>
</ul>
<h3 id="prerequirements"><a class="header" href="#prerequirements">Prerequirements</a></h3>
<ul>
<li>
<p><em>Node identity</em>. We require node accountability where each message is associated with the node ID of its issuing node.</p>
</li>
<li>
<p><em>Access mana</em>. The congestion control module has knowledge of the access Mana of the nodes in the network in order to fairly share the available throughput. Without access Mana the network would be subject to Sybil attacks, which would incentivise even honest actors to artificially increase its own number of nodes.</p>
</li>
<li>
<p><em>Timestamp</em>. Before scheduling a new message, the scheduler verifies whether the message timestamp is valid or not.</p>
</li>
<li>
<p><em>Message weight</em>. Weight of a message is used to priority messages over the others and it is calculated depending on the type of message and of the message length.</p>
</li>
</ul>
<h3 id="outbox-management"><a class="header" href="#outbox-management">Outbox management</a></h3>
<p>Once the message has successfully passed the message parser checks and is solid, it is enqueued into the outbox for scheduling. The outbox is logically split into several queues, each one corresponding to a different node issuing messages. In this section, we describe the operations of message enqueuing (and dequeuing) into (from) the outbox.</p>
<p>The enqueuing mechanism includes the following components:</p>
<ul>
<li><em>Classification</em>. The mechanism identifies the queue where the message belongs to according to the node ID of the message issuer.</li>
<li><em>Message enqueuing</em>. The message is actually enqueued, queue is sorted by message timestamps in increasing order and counters are updated (e.g., counters for the total number of bytes in the queue).</li>
<li><em>Message drop</em>. In some circumstances, due to network congestion or to ongoing attacks, some messages shall be dropped to guarantee bounded delays and isolate attacker's messages. Specifically, a node shall drop messages in two situations:
<ul>
<li>since buffers are of a limited size, if the total number of bytes in all queues exceeds a certain threshold, new incoming messages are dropped;</li>
<li>to guarantee the security of the network, if a certain queue exceeds a given threshold, new incoming packets from that specific node ID will be dropped.</li>
</ul>
</li>
</ul>
<p>The dequeue mechanism includes the following components:</p>
<ul>
<li><em>Queue selection</em>. A queue is selected according to round robin scheduling algorithm. In particular, we use a modified version of the deficit round robin (DRR) algorithm.</li>
<li><em>Message dequeuing</em>. The first message of the queue is dequeued, and list of active nodes is updated.</li>
<li><em>Scheduler management</em>. Scheduler counters and pointers are updated.</li>
</ul>
<h3 id="scheduler-1"><a class="header" href="#scheduler-1">Scheduler</a></h3>
<p>The most critical task is the scheduling algorithm which must guarantee that, for an honest node <code>node</code>, the following requirements will be met:</p>
<ul>
<li><code>node</code>'s messages will not accumulate indefinitely at any node (i.e., starvation is avoided), so the <em>consistency</em> requirement will be ensured.</li>
<li><code>node</code>'s fair share (according to its access Mana) of the network resources are allocated to it, guaranteeing the <em>fairness</em> requirement.</li>
<li>Malicious nodes sending above their allowed rate will not interrupt <code>node</code>'s throughput, fulfilling the <em>security</em> requirement.</li>
</ul>
<p>Although nodes in our setting are capable of more complex and customised behaviour than a typical router in a packet-switched network, our scheduler must still be lightweight and scalable due to the potentially large number of nodes requiring differentiated treatment. It is estimated that over 10,000 nodes operate on the Bitcoin network, and we expect that an even greater number of nodes are likely to be present in the IoT setting. For this reason, we adopt a scheduler based on <a href="https://ieeexplore.ieee.org/document/502236">Deficit Round Robin</a> (DRR) (the Linux implementation of the <a href="https://tools.ietf.org/html/rfc8290">FQ-CoDel packet scheduler</a>, which is based on DRR, supports anywhere up to 65535 separate queues).</p>
<p>The DRR scans all non-empty queues in sequence. When a non-empty queue is selected, its priority counter (called <em>deficit</em>) is incremented by a certain value (called <em>quantum</em>). Then, the value of the deficit counter is a maximal amount of bytes that can be sent at this turn: if the deficit counter is greater than the weight of the message at the head of the queue, this message can be scheduled and the value of the counter is decremented by this weight. In our implementation, the quantum is proportional to node's access Mana and we add a cap on the maximum deficit that a node can achieve to keep the network latency low. It is also important to mention that the weight of the message can be assigned in such a way that specific messages can be prioritized (low weight) or penalized (large weight); by default, in our mechanism the weight is proportional to the message size measured in bytes. The weight of a message is set by the function <code>WorkCalculator()</code>.</p>
<p>Here a fundamental remark: <em>the network manager sets up a desired maximum (fixed) rate</em> <code>SCHEDULING_RATE</code> <em>at which messages will be scheduled</em>, computed in weight (see above) per second. This implies that every message is scheduled after a delay which is equal to the weight (size as default) of the latest scheduled message times the parameter <code>SCHEDULING_RATE</code>. This rate mostly depends on the degree of decentralization desired: e.g., a larger rate leads to higher throughput but would leave behind slower devices which will fall out of sync.</p>
<h3 id="rate-setting"><a class="header" href="#rate-setting">Rate setting</a></h3>
<p>If all nodes always had messages to issue, i.e., if nodes were continuously willing to issue new messages, the problem of rate setting would be very straightforward: nodes could simply operate at a fixed, assured rate, sharing the total throughput according to the percentage of access Mana owned. The scheduling algorithm would ensure that this rate is enforceable, and that increasing delays or dropped messages are only experienced by misbehaving node. However, it is unrealistic that all nodes will always have messages to issue, and we would like nodes to better utilise network resources, without causing excessive congestion and violating any requirement.</p>
<p>We propose a rate setting algorithm inspired by TCP — each node employs <a href="https://https://epubs.siam.org/doi/book/10.1137/1.9781611974225">additive increase, multiplicative decrease</a> (AIMD) rules to update their issuance rate in response to congestion events. In the case of distributed ledgers, all message traffic passes through all nodes, contrary to the case of traffic typically found in packet switched networks and other traditional network architectures. Under these conditions, local congestion at a node is all that is required to indicate congestion elsewhere in the network. This observation is crucial, as it presents an opportunity for a congestion control algorithm based entirely on local traffic.</p>
<p>Our rate setting algorithm outlines the AIMD rules employed by each node to set their issuance rate. Rate updates for a node <code>node</code> take place each time a new message is scheduled if the <code>node</code> has a non-empty set of its own messages not yet scheduled. Node <code>node</code> sets its own local additive-increase variable <code>localIncrease(node)</code> based on its access Mana and on a global increase rate parameter <code>RATE_SETTING_INCREASE</code>. An appropriate choice of <code>RATE_SETTING_INCREASE</code> ensures a conservative global increase rate which does not cause problems even when many nodes increase their rate simultaneously. Nodes wait <code>RATE_SETTING_PAUSE</code> seconds after a global multiplicative decrease parameter <code>RATE_SETTING_DECREASE</code>, during which there are no further updates made, to allow the reduced rate to take effect and prevent multiple successive decreases. At each update, <code>node</code> checks how many of its own messages are in its outbox queue, and responds with a multiplicative decrease if this number is above a threshold, <code>backoff(node)</code>, which is proportional to <code>node</code>'s access Mana. If the number of <code>node</code>'s messages in the outbox is below the threshold, <code>node</code>'s issuance rate is incremented by its local increase variable <code>localIncrease(node)</code>.</p>
<h3 id="message-blocking-and-blacklisting"><a class="header" href="#message-blocking-and-blacklisting">Message blocking and blacklisting</a></h3>
<p>If an incoming message made the outbox total buffer size to exceed its maximum capacity <code>MAX_BUFFER</code>, the same message would be dropped. In our analysis, we set buffers to be large enough to accommodate traffic from all honest nodes.</p>
<p>Furthermore, to mitigate spamming actions from malicious nodes, we add an additional constraint: if <code>node</code>'s access Mana-scaled queue length (i.e., queue length divided by node's access Mana) exceeds a given threshold <code>MAX_QUEUE</code>, any new incoming packet from <code>node</code> will be dropped, hence the node is blacklisted. The attacker is blacklisted for a certain time <code>BLACKLIST_TIME</code> during which no messages issued by <code>node</code> can be added to the outbox. Please note that it is still possible to receive message from the attacker through solidification requests, which is important in order to guarantee the consistency requirement. Finally, when a node is blacklisted, the blacklister does not increase its own rate for a time <code>RATE_SETTING_QUARANTINE</code>, to avoid errors in the perception of the current congestion level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consensus-mechanism-1"><a class="header" href="#consensus-mechanism-1">Consensus Mechanism</a></h1>
<p>The consensus mechanism is necessary to achieve agreement among the nodes of the network. In case of a double spend, one way to decide which transaction should be considered valid would be to order them and pick the oldest one. However, the Tangle is only partially ordered. To tackle this problem in the context of the Tangle, we have designed an open and leaderless consensus mechanism. It combines a binary voting protocol (FPC) used as a pre-consensus to prevent metastable states, and a virtual voting protocol (Approval Weight) that provides finality similarly to the longest chain rule in Nakamoto consensus (i.e., heaviest branch).</p>
<h2 id="fpc"><a class="header" href="#fpc">FPC</a></h2>
<p>The <a href="https://arxiv.org/abs/1905.10895">Fast Probabilistic Consensus</a> (FPC) protocol is a binary voting protocol where each node starts with an initial opinion (a nulled boolean) on an object.  Nodes then exchange queries and responses about their opinions during several rounds, until each node terminates with a final boolean value.</p>
<p>FPC votes on two specific objects types: messages, in order to enforce timestamps (currently not yet enabled in GoShimmer), and transactions, in order to decide double spends. Additionally, applications can use FPC to query opinions about their opinion on other object types, although there is no guarantee that they will get a response.</p>
<p>The FPC is agnostic about the rest of the protocol, particularly when FPC should run and how the initial opinions are set. Deciding when FPC should run is a delicate question for two reasons.</p>
<ol>
<li>It is inefficient for FPC to vote on every single transaction.</li>
<li>If only a sub set of nodes participate in FPC, they are more vulnerable to attack since the consensus mana held by this collection of nodes is potentially much smaller.
Thus, since it cannot vote on everything, it must use subjective criterion to trigger voting which does not leave any group vulnerable to attack.</li>
</ol>
<p>For these reasons, we use <a href="protocol_specification/consensus_mechanism.html#fcob">FCoB</a> to manage FPC.</p>
<h3 id="fcob"><a class="header" href="#fcob">FCoB</a></h3>
<p>The following flow diagram shows the current implemention of the FCoB protocol.</p>
<p><img src="protocol_specification/FCOB.png" alt="FCoB" /></p>
<p>Each opinion is associated to a <em>Level of Knowledge</em> (LoK) that defines how confident a node is with respect to the value of the opinion. We can distinguish 3 levels:</p>
<ul>
<li>Level 1 means that the node only knows that it holds this opinion.</li>
<li>Level 2 means that the node knows that all nodes have this opinion too (with high probability).</li>
<li>Level 3 means that the node knows that all nodes have level 2 knowledge (with high probability).</li>
</ul>
<p>Within FCoB, there are three cases which are treated:</p>
<ol>
<li>No conflicts have been detected</li>
<li>Conflicts have been detected but have been rejected</li>
<li>Conflicts have been detected are either pending or have been confirmed</li>
</ol>
<p>In Case 1 is the most common because conflicts will never arrive for most transactions. Without conflicts, the opinion can be only set provisionally since it might change if a conflict arrives later. The opinion is set to true, but the level is set as if a conflict arrived at that time.   For example, after a given <code>Quarantine</code> time has elapsed since arrival time, if a conflict does arrive the opinion will remain true with level at least 2.</p>
<p>Case 2 is an important special case of the FCoB rule. To see the need for this modification consider the following example.  Suppose someone issues a pair of conflicting transactions where both transactions are rejected by FPC. Then, if someone ever issues a new transaction consuming those funds, FCoB, strictly speaking would reject the new transaction, since it would conflict with a previous transaction.  Thus, if a pair of double spends are rejected, the funds would be locked.  This is undesirable and impractical behavior: an honest but malfunctioning wallet can issue double spends.  Moreover, tracking the locked funds would be onerous. </p>
<p>Case 3 is the simplest case: since conflicts have been detected, we set the opinion according to the FCOB rule.  Then level is set according to the difference of <code>transaction.arrivalTime + Quarantine</code> and  <code>conflictTime</code>, the oldest arrival time of a conflicting transaction.  Essentially, the level measures how many network delays there are between these two values.</p>
<p>To prevent the FCoB rule from locking funds, we modify it to the following: a transaction <code>X</code> satisfied the FCoB rule if all transactions <code>Y</code> conflicting with <code>X</code>  before <code>arrivalTime(X)+Quarantine</code> has been rejected, i.e. has has opinion false and level 2 or 3.  With this rule, any conflicts which are rejected will not affect the opinion on future conflicts.  For simplicity case, all transactions falling under this case are treated as level 1.</p>
<h3 id="fpc-statements"><a class="header" href="#fpc-statements">FPC statements</a></h3>
<p>The FPC protocol requires nodes to directly query randomly selected nodes for conflict resolution. However, the information produced during such a voting mechanism is not stored in the Tangle, rather only lives within the node's local metadata. This can be a problem for nodes joining the network at a later stage, specifically when a conflict is considered marked as level of knowledge 3 by the majority of the network, a new node cannot query it anymore. 
Moreover, since the quorum to query is randomly formed proportionally to cMana, the highest cMana nodes would need to reply to too many queries, as their probability to be included in the quorum of each node is high. 
We propose an optimization of the protocol that, in turn, should solve both of the above issues. The idea is to let each node be free to choose whether writing its opinion on a given conflict and a given FPC round on the Tangle. </p>
<h4 id="payload"><a class="header" href="#payload">Payload</a></h4>
<p>We need to first define the FPC Statement payload:</p>
<pre><code class="language-go">type Statement struct {
   ConflictsCount  uint32
	Conflicts       Conflicts
	TimestampsCount uint32
	Timestamps      Timestamps
}
type Conflict struct {
	ID transaction.ID
	Opinion
}
type Timestamp struct {
	ID tangle.MessageID
	Opinion
}
</code></pre>
<h4 id="registry"><a class="header" href="#registry">Registry</a></h4>
<p>We also define an Opinion Registry where nodes can store and keep track of the opinions from each node after parsing FPC Statements.</p>
<pre><code class="language-go">type Registry struct {
    nodesView map[identity.ID]*View
}
type View struct {
	NodeID     identity.ID
	Conflicts  map[transaction.ID]Opinions
	Timestamps map[tangle.MessageID]Opinions
}
</code></pre>
<p>Given a nodeID and a ConflictID (or a messageID for timestamps), a node can check if it has the required opinion in its registry, and thus use that during its FPC round, or if not, send a traditional query to the node.</p>
<h4 id="broadcasting-an-fpc-statement"><a class="header" href="#broadcasting-an-fpc-statement">Broadcasting an FPC Statement</a></h4>
<p>A node, after forming its opinion for 1 or more conflicts during an FPC round, can prepare an FPC statement containing the result of that round and issue it on the Tangle.
Currently, any node that belongs to the top 70% cMana issues FPC statements. This parameter is local to the node and can be changed by the node operator.</p>
<h2 id="drng"><a class="header" href="#drng">dRNG</a></h2>
<p>At its core, the Fast Probabilistic Consensus (FPC) runs to resolve potential conflicting transactions by voting on them. FPC requires a random number generator (RNG) to be more resilient to an attack aiming at creating a meta-stable state, where nodes in the network are constantly toggling their opinion on a given transaction and thus are unable to finalize it. Such a RNG can be provided by either a trusted and centralized entity or be decentralized and distributed. Clearly, the fully decentralized nature of IOTA 2.0 mandates the latter option, and this option is referred to a distributed RNG (dRNG).</p>
<p>A dRNG can be implemented in very different ways, for instance by leveraging on cryptographic primitives such as verifiable secret sharing and threshold signatures, 
by using cryptographic sortition or also with verifiable delay functions. 
After reviewing some existing solutions, we decided to use a variant of the <a href="https://github.com/drand/drand">drand</a> protocol, 
originally developed within the <a href="https://github.com/dedis">DEDIS organization</a>, and as of December 2019, is now under the drand organization.
This protocol has been already used by other projects such as <a href="https://www.cloudflare.com/leagueofentropy/">The League of Entropy</a>.</p>
<h3 id="drand---a-distributed-randomness-beacon-daemon"><a class="header" href="#drand---a-distributed-randomness-beacon-daemon">Drand - A Distributed Randomness Beacon Daemon</a></h3>
<p>Drand (pronounced &quot;dee-rand&quot;) is a distributed randomness beacon daemon written
in <a href="https://golang.org/">Golang</a>. Servers running drand can be linked with each
other to produce collective, publicly verifiable, unbiased, unpredictable
random values at fixed intervals using bilinear pairings and threshold
cryptography. Drand nodes can also serve locally-generated private randomness
to clients.</p>
<p>In a nutshell, drand works in two phases: <strong>setup</strong> and <strong>generation</strong>.
In the setup phase, a set of nodes (hereafter referred as “committee”) run a distributed key generation (DKG) protocol 
to create a collective private and public key pair shared among the members of the committee. 
More specifically, at the end of this phase, each member obtains a copy of the public key as well as a private key share of the collective private key, 
such that no individual member knows the entire collective private key. 
These private key shares will then be used by the committee members to sign their contributions during the next phase.
The generation phase works in discrete rounds. 
In every round, the committee produces a new random value by leveraging on a deterministic threshold signature scheme such as BLS. 
Each member of the committee creates in round <em>r</em> the partial BLS signature <em>σ_r</em> on the message <em>m=H(r || ς_r-1)</em> 
where <em>ς_r-1</em> denotes the full BLS threshold signature from the previous round <em>r−1</em> and <em>H</em> is a cryptographic hash function. 
Once at least <em>t</em> members have broadcasted their partial signatures <em>σ_r</em> on <em>m</em>, 
anyone can recover the full BLS threshold signature <em>ς_r</em> (via Lagrange interpolation) which corresponds to the random value of round <em>r</em>. 
Then, the committee moves to the next round and reiterates the above process. For the first round, each member signs a seed fixed during the setup phase. 
This process ensures that every new random value depends on all previously generated signatures. 
If you are interested in knowing more about drand, we recommend you to check out their <a href="https://github.com/drand/drand">Github repository</a>.</p>
<h2 id="approval-weight-aw"><a class="header" href="#approval-weight-aw">Approval Weight (AW)</a></h2>
<p>Approval weight represents the <a href="protocol_specification/consensus_mechanism.html#active-consensus-mana">weight</a> of branches (and messages), similar to the longest chain rule in Nakamoto consensus. However, instead of selecting a leader based on a puzzle (PoW) or stake (PoS), it allows every node to express its opinion by simply issuing any message and attaching it in a part of the Tangle it <em>likes</em> (based on FCoB/FPC). This process is also known as virtual voting, and has been previously described in <a href="https://medium.com/@hans_94488/a-new-consensus-the-tangle-multiverse-part-1-da4cb2a69772">On Tangle Voting</a>. </p>
<p>If a node realizes its opinion according to FCoB/FPC differs from that of the majority of weight, it has to do a reorg of its perception according to the heavier branch. In that way, all nodes will eventually converge to the heaviest branches, and, thus, come to consensus efficiently. </p>
<p>AW also serves as a probabilistic finality tool for individual messages and their payloads, i.e., transactions.</p>
<h3 id="finalization"><a class="header" href="#finalization">Finalization</a></h3>
<p>Finality must always be considered as a probabilistic finality in the sense that a message is included in the ledger with a very high probability. Two qualities desired from a finality criteria are fast confirmation rate and a high probability of non-reversibility. </p>
<p>A branch is considered finalized/confirmed if one of the following holds:</p>
<ol>
<li>It is the <em>MasterBranch</em>.</li>
<li>Its approval weight is at least <em>0.5</em> higher than any of its conflicting branches. </li>
</ol>
<p>A message is considered finalized/confirmed if the following holds:</p>
<ol>
<li>Its approval weight is higher than <em>0.5</em>, and its branch is confirmed.</li>
</ol>
<p>Conversely, a message that does not gather enough AW will not be finalized, and, thus, will be pending until it might be orphaned if not reachable via current tips anymore.</p>
<h3 id="detailed-design-4"><a class="header" href="#detailed-design-4">Detailed Design</a></h3>
<p>Approval weight is tracked with the help of supporters that cast votes for branches and messages by means of making statements. This is necessary due to the changing nature of cMana over time, which prevents simply counting the AW per branch or message. </p>
<h4 id="definitions-1"><a class="header" href="#definitions-1">Definitions</a></h4>
<ul>
<li><strong>Statement</strong>: A statement is any message issued by a <em>node</em>, expressing its opinion and casting a (virtual) vote. It can be objectively ordered by its timestamp, and, if equal, its message ID.</li>
<li><strong>Branch supporter</strong>: A branch supporter is a <em>node</em> that issued a statement attaching to a branch, and, thus, voting for it.</li>
<li><strong>Marker/message supporter</strong>: A marker/message's supporter is a <em>node</em> that issued a statement directly or indirectly referencing a marker/message, including its issuer.</li>
</ul>
<h4 id="branches"><a class="header" href="#branches">Branches</a></h4>
<p>Tracking supporters of branches and following the heavier branch effectively is On Tangle Voting. It allows nodes to express their opinion simply by attaching a statement to a branch they like. This statement needs to propagate down the branch DAG, adding support to each of the branch parents. In case a supporter changes their opinion, support needs to be revoked from all conflicting branches and their children. Thus, a node can only support one branch of a conflict set. </p>
<p>To make this more clear consider the following example:
<img src="https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png" alt="Branch Supporter" /></p>
<p>The green node issued <strong>statement 1</strong> and attached it to the aggregated branch <code>Branch 1.1 + Branch 4.1.1</code>. Thus, the green node is a supporter of all the aggregated branch's parent branches, which are (from top to bottom) <code>Branch 4.1.1</code>, <code>Branch 1.1</code>, <code>Branch 4.1</code>, <code>Branch 1</code>, and <code>Branch 4</code>.</p>
<p>Then, the green node issued <strong>statement 2</strong> and attached it to <code>Branch 4.1.2</code>. This makes the green node a supporter of <code>Branch 4.1.2</code>, however, <code>Branch 4.1.1</code> is its conflict branch and thus support for <code>Branch 4.1.1</code> has to be revoked.</p>
<p><code>Branch 4.1</code>, <code>Branch 4</code> are parent branches of <code>Branch 4.1.2</code>, which the green node is still supporting. Since <code>Branch 1.1</code>, <code>Branch 1</code> are not conflicting to either of <code>Branch 4.1.2</code>'s parents, the green node remains their supporter.</p>
<p>Finally, the green nodes issued <strong>statement 3</strong>, which is in <code>Branch 2</code>. Now the green node is a supporter of <code>Branch 2</code>, and no longer a supporter of <code>Branch 1</code>, since <code>Branch 1</code> is conflicting to <code>Branch 2</code>. Note that, this supporter removal will propagate to child branches. Thus, the green node is removed from <code>Branch 1.1</code> as well.
<code>Branch 3</code>, <code>4</code> and both of their child branches have nothing to do with this attachement, the supporter status remains.</p>
<p>It is important to notice that the arrival order of the statements does not make a difference on the final outcome. Due to the fact that statements can be ordered objectively, every node in the network eventually comes to the same conclusion as to who is supporting which branch, even when nodes change their opinion.</p>
<h5 id="calculation-of-approval-weight"><a class="header" href="#calculation-of-approval-weight">Calculation of Approval Weight</a></h5>
<p>The approval weight itself is calculated every time a new supporter is added to a branch. The AW for a branch <em>B</em> is calculated as follows:</p>
<pre><code>AW(B) = supporters(B) dot 'active cMana nodes' / 'total active cMana'
</code></pre>
<p>It is then evaluated whether it fulfills the <a href="protocol_specification/consensus_mechanism.html#finalization">finalization</a> criterion. If so, the branch is set to <em>confirmed</em>, while all its conflicts are set to <em>rejected</em>.</p>
<p><strong>Reorg</strong>: In case the node confirmed another branch of the conflict set first, e.g., because of a difference in perception of the ledger state, it will have to do reorg. This means, the node needs to adjust its perception of the ledger state, so that, eventually, all nodes converge and follow the heaviest branch by active cMana.</p>
<h4 id="markers"><a class="header" href="#markers">Markers</a></h4>
<p>It would be computationally expensive to track the AW for each message individually. Instead, we approximate the AW with the help of <a href="protocol_specification/./markers.html">markers</a>. Once a marker fulfills the <a href="protocol_specification/consensus_mechanism.html#finalization">finalization</a> criterion, the confirmation is propagated into its past cone until all the messages are confirmed.</p>
<p>Rather than keeping a list of supporters for each marker and collecting supporters for each marker (which would also be expensive), we keep a list of supporters along with its approved marker index for each marker sequence. This approach provides a simple and fast look-up for marker supporters making use of the Tangle structure as mapped by the markers.</p>
<p>For each marker sequence, we keep a map of supporter to marker index, meaning a supporter supports a marker index <code>i</code>. This implies that the supporter supports all markers with index <code>&lt;= i</code>.</p>
<p>Take the figure below as an example:
<img src="https://user-images.githubusercontent.com/11289354/112416694-21012780-8d61-11eb-8089-cb9f5b236f30.png" alt="MarkersApprovalWeight SequenceSupporters-Page-2" /></p>
<p>The purple circles represent markers of the same sequence, the numbers are marker indices.</p>
<p>Four nodes (A to D) issue statements with past markers of the purple sequence. Node A and D issue messages having past marker with index 6, thus node A and D are the supporters of marker 6 and all markers before, which is 1 to 5. On the other hand, node B issues a message having past marker with index 3, which implies node B is a supporter for marker 1 and 2 as well.</p>
<p>This is a fast look-up and avoids walking through a marker's future cone when it comes to retrieving supporters for approval weight calculation.</p>
<p>For example, to find all supporter of marker 2, we iterate through the map and filter out those support marker with <code>index &gt;= 2</code>. In this case, all nodes are its supporters. As for marker 5, it has supporters node A and D, which fulfill the check: <code>index &gt;= 5</code>.</p>
<p>Here is another more complicated example with parent sequences:
<img src="https://user-images.githubusercontent.com/11289354/112433680-8cf18900-8d7d-11eb-8944-54030581a033.png" alt="MarkersApprovalWeight SequenceSupporters-Page-2(1)" /></p>
<p>The supporter will be propagated to the parent sequence.</p>
<p>Node A issues message A2 having past markers <code>[1,4], [3,5]</code>, which implies node A is a supporter for marker <code>[1,1]</code> to <code>[1,4]</code>, <code>[2,1]</code> to <code>[2,3]</code>, and <code>[3,4], [3,5]</code> as well.</p>
<h5 id="calculation-of-approval-weight-1"><a class="header" href="#calculation-of-approval-weight-1">Calculation of Approval Weight</a></h5>
<p>The approval weight itself is calculated every time a new supporter is added to a marker, and the marker's branch <em>B</em> has reached its finality criterion. The AW for a marker <em>M</em> is calculated as follows:</p>
<pre><code>AW(M) = supporters(B) dot supporters(M) dot 'active cMana nodes' / 'total active cMana'
</code></pre>
<p>It is then evaluated whether it fulfills the <a href="protocol_specification/consensus_mechanism.html#finalization">finalization</a> criterion. If so, the marker's message is set to <em>confirmed</em> as well as all messages in its past cone.</p>
<h2 id="active-consensus-mana"><a class="header" href="#active-consensus-mana">Active Consensus Mana</a></h2>
<p>It is important to track the currently <em>active</em> consensus mana in the system, such that the AW of a given message and/or branch reflects an up-to-date measure of cumulative weight. Specifically, the system must be resilient against a long-range attack.</p>
<p>The active consensus mana tracks the set of the active nodes with some conensus mana. A node is considered to be active if it has issued any message in the last 30 minutes with respect to the TangleTime. The total active consensus mana is, therefore, the sum of all the consensus mana of each active node.  </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="utxo-model"><a class="header" href="#utxo-model">UTXO model</a></h2>
<p>The unspent transaction output (UTXO) model defines a ledger state where balances are not directly associated with addresses but with the outputs of transactions. In this model, transactions specify the outputs of previous transactions as inputs, which are consumed in order to create new outputs. 
A transaction must consume the entirety of the specified inputs. The section unlocking the inputs is called an <em>unlock block</em>. An unlock block may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="https://i.imgur.com/3TdENBW.png" alt="" /></p>
<h2 id="transaction-layout-1"><a class="header" href="#transaction-layout-1">Transaction Layout</a></h2>
<p>A <i>Transaction</i> payload is made up of two parts:</p>
<ol>
<li>The <i>Transaction Essence</i> part contains: version, timestamp, nodeID of the aMana pledge, nodeID of the cMana pledge, inputs, outputs and an optional data payload.</li>
<li>The <i>Unlock Blocks</i> which unlock the <i>Transaction Essence</i>'s inputs. In case the unlock block contains a signature, it signs the entire <i>Transaction Essence</i> part.</li>
</ol>
<p>All values are serialized in little-endian encoding (it stores the most significant byte of a word at the largest address and the smallest byte at the smallest address). The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence.</p>
<h3 id="transaction-essence-1"><a class="header" href="#transaction-essence-1">Transaction Essence</a></h3>
<p>The <i>Transaction Essence</i> of a <i>Transaction</i> carries a version, timestamp, nodeID of the aMana pledge, nodeID of the cMana pledge, inputs, outputs and an optional data payload.</p>
<h3 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h3>
<p>The <i>Inputs</i> part holds the inputs to consume, that in turn fund the outputs of the <i>Transaction Essence</i>. There is only one supported type of input as of now, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each defined input must be accompanied by a corresponding <i>Unlock Block</i> at the same index in the <i>Unlock Blocks</i> part of the <i>Transaction</i>. 
If multiple inputs may be unlocked through the same <i>Unlock Block</i>, the given <i>Unlock Block</i> only needs to be specified at the index of the first input that gets unlocked by it. 
Subsequent inputs that are unlocked through the same data must have a <i>Reference Unlock Block</i> pointing to the previous <i>Unlock Block</i>. 
This ensures that no duplicate data needs to occur in the same transaction.</p>
<h4 id="utxo-input"><a class="header" href="#utxo-input">UTXO Input</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Input Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
            </td>
        </tr>
        <tr>
            <td>Transaction ID</td>
            <td>ByteArray[32]</td>
            <td>The BLAKE2b-256 hash of the transaction from which the UTXO comes from.</td>
        </tr>
        <tr>
            <td>Transaction Output Index</td>
            <td>uint16</td>
            <td>The index of the output on the referenced transaction to consume.</td>
        </tr>
</table>
<p>A <i>UTXO Input</i> is an input which references an output of a previous transaction by using the given transaction's BLAKE2b-256 hash + the index of the output on that transaction. 
A <i>UTXO Input</i> must be accompanied by an <i>Unlock Block</i> for the corresponding type of output the <i>UTXO Input</i> is referencing.</p>
<p>Example: If the input references outputs to an Ed25519 address, then the corresponding unlock block must be of type <i>Signature Unlock Block</i> holding an Ed25519 signature.</p>
<h3 id="outputs-1"><a class="header" href="#outputs-1">Outputs</a></h3>
<p>The <i>Outputs</i> part holds the outputs to create with this <i>Transaction Payload</i>. There are different types of output: </p>
<ul>
<li><i>SigLockedSingleOutput</i></li>
<li><i>SigLockedAssetOutput</i></li>
</ul>
<h4 id="siglockedsingleoutput"><a class="header" href="#siglockedsingleoutput">SigLockedSingleOutput</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Output Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
                 <details>
                    <summary>Ed25519 Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                        </tr>
                    </table>
                </details>
                <details>
                    <summary>BLS Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote a <i>BLS Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[49]</td>
                              <td>The raw bytes of the BLS address which is a BLAKE2b-256 hash of the BLS public key.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
        <tr>
            <td>Balance</td>
            <td>uint64</td>
            <td>The balance of IOTA tokens to deposit with this <i>SigLockedSingleOutput</i> output.</td>
        </tr>
</table>
<p>The <i>SigLockedSingleOutput</i> defines an output holding an IOTA balance linked to a single address; it is unlocked via a valid signature proving ownership over the given address. Such output may hold an address of different types.</p>
<h4 id="siglockedassetoutput"><a class="header" href="#siglockedassetoutput">SigLockedAssetOutput</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Output Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 1</strong> to denote a <i>SigLockedAssetOutput</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
                <details>
                    <summary>Ed25519 Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                        </tr>
                    </table>
                </details>
                <details>
                    <summary>BLS Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote a <i>BLS Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[49]</td>
                              <td>The raw bytes of the BLS address which is a BLAKE2b-256 hash of the BLS public key.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
        <tr>
            <td>Balances count</td>
            <td>uint32</td>
            <td>The number of individual balances.</td>
            <tr>
                <td valign="top">AssetBalance <code>anyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Asset Balance</summary>
                        <blockquote>
                        The balance of the tokenized asset.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>AssetID</td>
                                <td>ByteArray[32]</td>
                                <td>The ID of the tokenized asset</td>
                            </tr>
                            <tr>
                                <td>Balance</td>
                                <td>uint64</td>
                                <td>The balance of the tokenized asset.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </tr>
</table>
<p>The <i>SigLockedAssetOutput</i> defines an output holding a balance for each specified tokenized asset linked to a single address; it is unlocked via a valid signature proving ownership over the given address. Such output may hold an address of different types.
The ID of any tokenized asset is defined by the BLAKE2b-256 hash of the OutputID that created the asset.</p>
<h3 id="payload-1"><a class="header" href="#payload-1">Payload</a></h3>
<p>The payload part of a <i>Transaction Essence</i> may hold an optional payload. This payload does not affect the validity of the <i>Transaction Essence</i>. If the transaction is not valid, then the payload <em>shall</em> be discarded.</p>
<h3 id="unlock-blocks"><a class="header" href="#unlock-blocks">Unlock Blocks</a></h3>
<p>The <i>Unlock Blocks</i> part holds the unlock blocks unlocking inputs within a <i>Transaction Essence</i>.</p>
<p>There are different types of <i>Unlock Blocks</i>:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Unlock Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Signature Unlock Block</td>
        <td>0</td>
        <td>An unlock block holding one or more signatures unlocking one or more inputs.</td>
    </tr>
<tr>
        <td>Reference Unlock Block</td>
        <td>1</td>
        <td>An unlock block which must reference a previous unlock block which unlocks also the input at the same index as this <i>Reference Unlock Block</i>.</td>
    </tr>
</table>
<h4 id="signature-unlock-block"><a class="header" href="#signature-unlock-block">Signature Unlock Block</a></h4>
<table>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Signature <code>oneOf</code></td>
            <td colspan="2">
                <details>
                    <summary>BLS Signature</summary>
                    <table>
                        <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Signature Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote a <i>BLS Signature</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Signature</td>
                            <td>ByteArray</td>
                            <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                        </tr>
                    </table>
                </details>
                 <details>
                    <summary>Ed25519 Signature</summary>
                    <table>
                        <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Signature Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote an <i>Ed25519 Signature</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Public key</td>
                            <td>ByteArray[32]</td>
                            <td>The public key of the Ed25519 keypair which is used to verify the signature.</td>
                        </tr>
                        <tr>
                            <td>Signature</td>
                            <td>ByteArray[64]</td>
                            <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
</table>
<p>A <i>Signature Unlock Block</i> defines an <i>Unlock Block</i> which holds one or more signatures unlocking one or more inputs.
Such a block signs the entire <i>Transaction Essence</i> part of a <i>Transaction Payload</i> including the optional payload.</p>
<h4 id="reference-unlock-block"><a class="header" href="#reference-unlock-block">Reference Unlock block</a></h4>
<table>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
            </td>
        </tr>
        <tr>
            <td>Reference</td>
            <td>uint16</td>
            <td>Represents the index of a previous unlock block.</td>
        </tr>
</table>
<p>A <i>Reference Unlock Block</i> defines an <i>Unlock Block</i> that references a previous <i>Unlock Block</i> (that must not be another <i>Reference Unlock Block</i>). It must be used if multiple inputs can be unlocked through the same origin <i>Unlock Block</i>.</p>
<p>Example:
Consider a <i>Transaction Essence</i> containing <i>UTXO Inputs</i> A, B and C, where A and C are both spending the UTXOs originating from the same Ed25519 address. The <i>Unlock Block</i> part must thereby have the following structure:</p>
<table><thead><tr><th>Index</th><th>Must Contain</th></tr></thead><tbody>
<tr><td>0</td><td>A <i>Signature Unlock Block</i> holding the corresponding Ed25519 signature to unlock A and C.</td></tr>
<tr><td>1</td><td>A <i>Signature Unlock Block</i> that unlocks B.</td></tr>
<tr><td>2</td><td>A <i>Reference Unlock Block</i> that references index 0, since C also gets unlocked by the same signature as A.</td></tr>
</tbody></table>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>A <i>Transaction</i> payload has different validation stages since some validation steps can only be executed at the point when certain information has (or has not) been received. We, therefore, distinguish between syntactical and semantic validation.</p>
<h3 id="transaction-syntactical-validation"><a class="header" href="#transaction-syntactical-validation">Transaction Syntactical Validation</a></h3>
<p>This validation can commence as soon as the transaction data has been received in its entirety. It validates the structure but not the signatures of the transaction. A transaction must be discarded right away if it does not pass this stage.</p>
<p>The following criteria define whether the transaction passes the syntactical validation:</p>
<ul>
<li>Transaction Essence:
<ul>
<li><code>Transaction Essence Version</code> value must be 0.</li>
<li>The <code>timestamp</code> of the <i>Transaction Essence</i> must be older than (or equal to) the <code>timestamp</code> of the message
containing the transaction by at most 10 minutes.</li>
<li>A <i>Transaction Essence</i> must contain at least one input and output.</li>
</ul>
</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x &lt; 128.</li>
<li>At least one input must be specified.</li>
<li><code>Input Type</code> value must be 0, denoting an <code>UTXO Input</code>.</li>
<li><code>UTXO Input</code>:
<ul>
<li><code>Transaction Output Index</code> must be 0 ≤ x &lt; 128.</li>
<li>Every combination of <code>Transaction ID</code> + <code>Transaction Output Index</code> must be unique in the inputs set.</li>
</ul>
</li>
<li>Inputs must be in lexicographical order of their serialized form.<sup>1</sup></li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x &lt; 128.</li>
<li>At least one output must be specified.</li>
<li><code>Output Type</code> must be 0, denoting a <code>SigLockedSingleOutput</code>.</li>
<li><code>SigLockedSingleOutput</code>:
<ul>
<li><code>Address Type</code> must either be 0 or 1, denoting an <code>Ed25519</code> - or <code>BLS</code> address .</li>
<li>The <code>Address</code> must be unique in the set of <code>SigLockedSingleOutputs</code>.</li>
<li><code>Amount</code> must be &gt; 0.</li>
</ul>
</li>
<li>Outputs must be in lexicographical order by their serialized form.<sup>1</sup></li>
<li>Accumulated output balance must not exceed the total supply of tokens <code>2,779,530,283,277,761</code>.</li>
</ul>
</li>
<li><code>Payload Length</code> must be 0 (to indicate that there's no payload) or be valid for the specified payload type.</li>
<li><code>Payload Type</code> must be one of the supported payload types if <code>Payload Length</code> is not 0.</li>
<li><code>Unlock Blocks Count</code> must match the number of inputs. Must be 0 &lt; x &lt; 128.</li>
<li><code>Unlock Block Type</code> must either be 0 or 1, denoting a <code>Signature Unlock Block</code> or <code>Reference Unlock block</code>.</li>
<li><code>Signature Unlock Blocks</code> must define either an <code>Ed25519</code>- or <code>BLS Signature</code>.</li>
<li>A <code>Signature Unlock Block</code> unlocking multiple inputs must only appear once (be unique) and be positioned at the same index of the first input it unlocks. All other inputs unlocked by the same <code>Signature Unlock Block</code> must have a companion <code>Reference Unlock Block</code> at the same index as the corresponding input that points to the origin <code>Signature Unlock Block</code>.</li>
<li><code>Reference Unlock Blocks</code> must specify a previous <code>Unlock Block</code> that is not of type <code>Reference Unlock Block</code>. The referenced index must therefore be smaller than the index of the <code>Reference Unlock Block</code>.</li>
<li>Given the type and length information, the <i>Transaction</i> must consume the entire byte array the <code>Payload Length</code> field in the <i>Message</i> defines.</li>
</ul>
<p><sup>1</sup> ensures that serialization of the transaction becomes deterministic, meaning that libraries always produce the same bytes given the logical transaction.</p>
<h3 id="transaction-semantic-validation"><a class="header" href="#transaction-semantic-validation">Transaction Semantic Validation</a></h3>
<p>The following criteria define whether the transaction passes the semantic validation:</p>
<ol>
<li>All the UTXOs the transaction references are known (booked) and unspent.</li>
<li>The transaction is spending the entirety of the funds of the referenced UTXOs to the outputs.</li>
<li>The address type of the referenced UTXO must match the signature type contained in the corresponding <i>Signature Unlock Block</i>.</li>
<li>The <i>Signature Unlock Blocks</i> are valid, i.e. the signatures prove ownership over the addresses of the referenced UTXOs.</li>
</ol>
<p>If a transaction passes the semantic validation, its referenced UTXOs <em>shall</em> be marked as spent and the corresponding new outputs <em>shall</em> be booked/specified in the ledger. </p>
<p>Transactions that do not pass semantic validation <em>shall</em> be discarded. Their UTXOs are not marked as spent and neither are their outputs booked into the ledger. Moreover, their messages <em>shall</em> be considered invalid.</p>
<h1 id="ledger-state"><a class="header" href="#ledger-state">Ledger State</a></h1>
<p>The introduction of a voting-based consensus requires a fast and easy way to determine a node's initial opinion for every received transaction. This includes the ability to both detect double spends and transactions that try to spend non-existing funds. 
These conditions are fulfilled by the introduction of an Unspent Transaction Output (UTXO) model for record-keeping, which enables the validation of transactions in real time.</p>
<p>The concept of UTXO style transactions is directly linked to the creation of a directed acyclic graph (DAG), in which the vertices are transactions and the links between these are determined by the outputs and inputs of transactions. </p>
<p>To deal with double spends and leverage on certain properties of UTXO, we introduce the Realities Ledger State. </p>
<h2 id="realities-ledger-state"><a class="header" href="#realities-ledger-state">Realities Ledger State</a></h2>
<p>In the Realities Ledger State, we model the different perceptions of the ledger state that exist in the Tangle. In each “reality” on its own there are zero conflicting transactions. 
Each reality thus forms an in itself consistent UTXO sub-DAG, where every transaction references any other transaction correctly.</p>
<p>Since outputs of transactions can only be consumed once, a transaction that double spends outputs creates a persistent branch in a corresponding UTXO DAG. Each branch receives a unique identifier <code>branchID</code>. These branches cannot be merged by any vertices (transactions). 
A transaction that attempts to merge incompatible branches fails to pass a validity check and is marked as invalid.</p>
<p>The composition of all realities defines the Realities Ledger State. </p>
<p>From this composition nodes are able to know which possible outcomes for the Tangle exist, where they split, how they relate to each other, if they can be merged and which messages are valid tips. All of this information can be retrieved in a fast and efficient way without having to walk the Tangle. </p>
<p>Ultimately, for a set of competing realities, only one reality can survive. It is then up to the consensus protocol to determine which branch is part of the eventually accepted reality.</p>
<p>In total the ledger state thus involves three different layers:</p>
<ul>
<li>the UTXO DAG,</li>
<li>its extension to the corresponding branch DAG,</li>
<li>the Tangle which maps the parent relations between messages and thus also transactions.</li>
</ul>
<h2 id="the-utxo-dag"><a class="header" href="#the-utxo-dag">The UTXO DAG</a></h2>
<p>The UTXO DAG models the relationship between transactions, by tracking which outputs have been spent by what transaction. Since outputs can only be spent once, we use this property to detect double spends. </p>
<p>Instead of permitting immediately only one transaction into to the ledger state, we allow for different versions of the ledger to coexist temporarily. 
This is enabled by extending the UTXO DAG by the introduction of branches, see the following section. We can then determine which conflicting versions of the ledger state exist in the presence of conflicts.</p>
<h3 id="conflict-sets-and-detection-of-double-spends"><a class="header" href="#conflict-sets-and-detection-of-double-spends">Conflict sets and detection of double spends</a></h3>
<p>We maintain a list of consumers <code>consumerList</code> associated with every output, that keeps track of which transactions have spent that particular output. Outputs without consumers are considered to be unspent outputs. Transactions that consume an output that have more than one consumer are considered to be double spends. </p>
<p>If there is more than one consumer in the consumer list we <em>shall</em> create a conflict set list <code>conflictSet</code>, which is identical to the consumer list. The <code>conflictSet</code> is uniquely identified by the unique identifier <code>conflictSetID</code>. Since the <code>outputID</code> is directly and uniquely linked to the conflict set, we set <code>conflictSetID=outputID</code>.</p>
<h2 id="branches-1"><a class="header" href="#branches-1">Branches</a></h2>
<p>The UTXO model and the concept of solidification, makes all non-conflicting transactions converge to the same ledger state no matter in which order the transactions are received. Messages containing these transactions could always reference each other in the Tangle without limitations.</p>
<p>However, every double spend creates a new possible version of the ledger state that will no longer converge. Whenever a double spend is detected, see the previous section, we track the outputs created by the conflicting transactions and all of the transactions that spend these outputs, by creating a container for them in the ledger which we call a branch. </p>
<p>More specifically a container <code>branch</code> <em>shall</em> be created for each transaction that double spends one or several outputs, or if transactions aggregated those branches.
Every transaction that spends directly or indirectly from a transaction in a given <code>branch</code>, i.e. is in the future cone in the UTXO DAG of the double-spending transaction that created <code>branch</code>, is also contained in this <code>branch</code> or one of the child branches.
A branch that was created by a transaction that spends multiple outputs can be part of multiple conflict sets.</p>
<p>Every branch <em>shall</em> be identified by the unique identifier <code>branchID</code>. We consider two kinds of branches: conflict branches and aggregated branches, which are explained in the following sections.</p>
<h3 id="conflict-branches"><a class="header" href="#conflict-branches">Conflict branches</a></h3>
<p>A conflict branch is created by a corresponding double spend transaction. Since the transaction identifier is unique, we choose the transaction id <code>transactionID</code> of the double spending transaction as the <code>branchID</code>.</p>
<p>Outputs inside a branch can be double spent again, recursively forming sub-branches. </p>
<p>On solidification of a message, we <em>shall</em> store the corresponding branch identifier together with every output, as well as the transaction metadata to enable instant lookups of this information. Thus, on solidification, a transaction can be immediately associated with a branch. </p>
<h3 id="aggregated-branches"><a class="header" href="#aggregated-branches">Aggregated branches</a></h3>
<p>A transaction that does not create a double spend inherits the branches of the input's branches. In the simplest case, where there is only one input branch the transaction inherits that branch. </p>
<p>If outputs from multiple non-conflicting branches are spent in the same transaction, then the transaction and its resulting outputs are part of an aggregated branch. This type of branch is not part of any conflict set. Rather it simply combines the perception that the individual conflict branches associated to the transaction's inputs are the ones that will be accepted by the network. Each aggregated branch <em>shall</em> have a unique identifier <code>branchID</code>, which is the same type as for conflict branches. Furthermore the container for an aggregated branch is also of type <code>branch</code>. </p>
<p>To calculate the unique identifier of a new aggregated branch, we take the identifiers of the branches that were aggregated, sort them lexicographically and hash the concatenated identifiers once</p>
<p>An aggregated branch can't aggregate other aggregated branches. However, it can aggregate the conflict branches that are part of the referenced aggregated branch. 
Thus aggregated branches have no further branches as their children and they remain tips in the branch DAG. Furthermore, the sortation of the <code>branchID</code>s in the function <code>AggregatedBranchID()</code> ensures that even though messages can attach at different points in the Tangle and aggregate different aggregated branches they are treated as if they are in the same aggregated branch <strong>if</strong> the referenced conflict branches are the same. </p>
<p>These properties allow for an efficient reduction of a set of branches. In the following we will require the following fields as part of the branch data: </p>
<ul>
<li><code>isConflictBranch</code> is a boolean flat that is <code>TRUE</code> if the branch is a conflict branch or <code>FALSE</code> if its an aggregated branch.</li>
<li><code>parentBranches</code> contains the list of parent conflict branches of the branch, i.e. the conflict branches that are directly referenced by this branch.</li>
</ul>
<p>Then the following function takes a list of branches (which can be either conflict or aggregated branches) and returns a unique set of conflict branches that these branches represent. This is done by replacing duplicates and extracting the parent conflict branches from aggregated branches. </p>
<pre><code class="language-vbnet">FUNCTION reducedBranches = ReduceBranches(branches)
    FOR branch IN branches
        IF branch.isConflictBranch
            Append(reducedBranches,branch)
        ELSE
            FOR parentBranch IN branch.parentBranches
                IF NOT (parentBranch IN reducedBranches)
                    Append(reducedBranches,parentBranch)
    
    RETURN reducedBranches
</code></pre>
<h3 id="the-branch-dag"><a class="header" href="#the-branch-dag">The branch DAG</a></h3>
<p>A new branch is created for each transaction that is part of a conflict set, or if a transaction aggregates branches.
In the branch DAG, branches constitute the vertices of the DAG. A branch that is created by a transaction that is spending outputs from other branches has edges pointing to those branches.
The branch DAG maps the UTXO DAG to a simpler structure that ignores details about relations between transactions inside the branches and instead retains only details about the interrelations of conflicts.
The set of all non-conflicting transactions form the master branch. Thus, at its root the branch DAG has the master branch, which consists of non-conflicting transaction and resolved transactions. From this root of the branch DAG the various branches emerge. 
In other words the conflict branches and the aggregated branches appear as the children of the master branch. </p>
<h3 id="detecting-conflicting-branches"><a class="header" href="#detecting-conflicting-branches">Detecting conflicting branches</a></h3>
<p>Branches are conflicting if they, or any of their ancestors, are part of the same conflict set.
The branch DAG can be used to check if branches are conflicting, by applying an operation called normalization, to a set of input branches.
From this information we can identify messages or transactions that are trying to combine branches belonging to conflicting double spends, and thus introduce an invalid perception of the ledger state.</p>
<p>Since branches represent the ledger state associated with a double spend and sub-branches implicitly share the perception of their parents, we define an operation to normalize a list of branches that gets rid of all branches that are referenced by other branches in that list. The function returns <code>NULL</code> if the branches are conflicting and can not be merged.</p>
<h3 id="merging-of-branches-into-the-master-branch"><a class="header" href="#merging-of-branches-into-the-master-branch">Merging of branches into the master branch</a></h3>
<p>A branch gains approval weight when messages from (previously non-attached) <code>nodeID</code>s attach to messages in the future cone of that branch. Once the approval weight exceeds a certain threshold we consider the branch as confirmed.
Once a conflict branch is confirmed, it can be merged back into the master branch. Since the approval weight is monotonically increasing for branches from the past to the future, branches are only merged into the master branch.
The loosing branches and all their children branches are booked into the container <code>rejectedBranch</code> that has the identifier <code>rejectedBranchID</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo-output-types"><a class="header" href="#utxo-output-types">UTXO Output Types</a></h1>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>In the previous <a href="protocol_specification/ledgerstate.html">section</a> two basic output types were introduced that enable the use of the UTXO ledger
as a payment application between addresses. Each <code>SigLockedSingleOutput</code> and <code>SigLockedAssetOutput</code> encodes a list of
balances and an address in the output. The output can be unlocked by providing a valid signature for the address, hence
only the owner of the address can initiate a payment.</p>
<p>While these two output types provide the basic functionality for a cryptocurrency application, IOTA aims to strive
for more. The first and foremost application the UTXO ledger should support besides payments is the IOTA Smart Contract
Protocol (ISCP). Due to the lack of total ordering of the Tangle (that is a direct result of the scalable, parallel
architecture), it is not possible to implement Turing-complete smart contracts directly on layer 1. Therefore,
IOTA aims to develop a layer 2 protocol called ISCP for smart contracts.</p>
<p>After carefully evaluating the proposed architecture of ISCP and the required properties of the layer 2 protocol, we
came up with special types of outputs for layer 1 UTXO support: <code>AliasOutput</code> and <code>ExtendedLockedOutput</code>.
These output types are experimental: the IOTA 2.0 DevNet serves as their testing ground. Bear in mind that there is no
guarantee that they will not change as the protocol evolves.</p>
<p>It will be demonstrated later that these outputs can also be used for enhanced cryptocurrency payment application, such
as conditional payments or time locked sending, but also open up the world of native non-fungible tokens (NFTs).</p>
<h2 id="functional-requirements-of-iscp"><a class="header" href="#functional-requirements-of-iscp">Functional Requirements of ISCP</a></h2>
<p>Designing the output types starts with a proper requirement analysis. Below you can read the summary of the functional
requirements imposed by the layer 2 smart contract protocol. You can read more about ISCP
<a href="https://blog.iota.org/an-introduction-to-iota-smart-contracts-16ea6f247936/">here</a>,
<a href="https://blog.iota.org/iota-smart-contracts-protocol-alpha-release/">here</a>
or check out this <a href="https://youtu.be/T1CJFr6gz8I">presentation</a>.</p>
<ul>
<li>Smart contract chains need a globally unique account in the UTXO ledger, that does not change if the controlling entities changes.</li>
<li>An account state is identified by balances and state metadata.</li>
<li>Two levels of control: <strong>state controller</strong> and <strong>governance controller</strong>.</li>
<li>State controller can change state metadata (state transition) and balance (min required).</li>
<li>Governance controller can change state controller and governance controller.</li>
<li>An account shall have only one valid state in the ledger.</li>
<li>Smart contract chain state transitions are triggered by requests in the ledger.</li>
<li>A request is a ledger entity belonging to the account with tokens and data.</li>
<li>The account can identify and control requests.</li>
<li>Fallback mechanism needs to be in place in case the requests are not picked up.</li>
<li>When request is completed in a state transition, it should be atomically removed from the ledger.</li>
</ul>
<h2 id="output-design"><a class="header" href="#output-design">Output Design</a></h2>
<h3 id="introducing-alias-account"><a class="header" href="#introducing-alias-account">Introducing Alias Account</a></h3>
<p>Previously, the account concept in the ledger was realized with cryptographic entities called addresses, that are backed
by public and private key pairs. Addresses are present in the ledger through outputs and define who can spend this
output by providing a digital signature.</p>
<p>Addresses are not able to provide the necessary functionality needed for smart contract chain accounts, because:</p>
<ul>
<li>addresses change with the rotation of the controlling body (committee),</li>
<li>and there is no notion of separate control levels for an address account.</li>
</ul>
<p>We define a new account type in the ledger, called <strong>Alias</strong>, to represent smart contract chain accounts. An alias
account can hold token balances, but also has state metadata, which stores the state of the smart contract chain. 
The alias account defines two to controlling entities: a state controller and a governance controller. The state 
controller can transition the account into a new state, and can manipulate account balances. The governance controller
can change the state controller or the governance controller.</p>
<p>An alias is not a cryptographic entity, but it is controlled via either regular addresses or other aliases.</p>
<h3 id="representing-a-smart-contract-chain-account-in-ledger"><a class="header" href="#representing-a-smart-contract-chain-account-in-ledger">Representing a Smart Contract Chain Account in Ledger</a></h3>
<p>An alias is translated into the ledger as a distinct output type, called <strong>AliasOutput</strong>. The output contains:</p>
<ul>
<li>the unique identifier of the alias, called <strong>AliasID</strong>,</li>
<li>the <strong>State Controller</strong> entity,</li>
<li><strong>State Metadata</strong>,</li>
<li>the <strong>Governance Controller</strong>,</li>
<li><strong>Governance Metadata</strong>,</li>
<li><strong>Immutable Metadata</strong>,</li>
<li>and token <strong>balances</strong>.</li>
</ul>
<p>The state controller and governance controller entities can either be private key backed addresses (cryptographic 
entities) or <code>AliasAddress</code>, that is the unique identifier of another alias. Note, that an alias cannot be controlled by
its own <code>aliasID</code>.</p>
<p>An alias output itself can be regarded as a non-fungible token with a unique identifier <code>aliasID</code>, metadata and token
balances. An NFT that can hold tokens, can control its metadata and has a governance model.</p>
<p>Alias output can be created in a transaction that spends the minimum required amount of tokens into a freshly created
alias output. The new transaction output specifies the state and governance controller next to the balances, but aliasID
is assigned by the protocol once the transaction is processed. Once the output is booked, aliasID becomes the hash of
the outputID that created it.</p>
<p>An alias output can only be destroyed by the governance controller by simply consuming it as an input but not creating
a corresponding output in the transaction.</p>
<p>The alias account is transitioned into a new state by spending its alias output in a transaction and creating an
updated alias output with the same aliasID. Depending on what unlocking conditions are met, there are certain
restrictions on how the newly created alias output can look like.</p>
<h3 id="consuming-an-alias-output"><a class="header" href="#consuming-an-alias-output">Consuming an Alias Output</a></h3>
<p>As mentioned above, an alias output can be unlocked by both the state controller and the governance controller.</p>
<h4 id="unlocking-via-state-controller"><a class="header" href="#unlocking-via-state-controller">Unlocking via State Controller</a></h4>
<p>When the state controller is an address, the alias output is unlocked by providing a signature of the state controller
address in the output that signs the essence of the transaction. When state controller is another alias, unlocking is
done by providing a reference to the state controller unlocked other alias within the transaction.</p>
<p>When an alias output is unlocked as input in a transaction by the state controller, the transaction must contain a
corresponding alias output. Only the state metadata and the token balances of the alias output are allowed to change,
and token balances must be at least a protocol defined constant.</p>
<h4 id="unlocking-via-governance-controller"><a class="header" href="#unlocking-via-governance-controller">Unlocking via Governance Controller</a></h4>
<p>The governance controller is either an address, or another alias. In the former case, unlocking is done via the regular
signature. In the latter case, unlocking is done by providing a reference to the unlocked governance alias within the
transaction.</p>
<p>When an alias output is unlocked as input by the governance controller, the transaction doesn't need to have a
corresponding output. If there is no such output in the transaction, the alias is destroyed. If however the output
is present, only the state and governance controller fields are allowed to be changed.</p>
<p>A governance controller therefore can:</p>
<ul>
<li>destroy the alias all together,</li>
<li>assign the state controller of the alias,</li>
<li>assign the governance controller of the alias.</li>
</ul>
<h2 id="locking-funds-into-aliases"><a class="header" href="#locking-funds-into-aliases">Locking Funds Into Aliases</a></h2>
<p>Address accounts in the ledger can receive funds by the means of signature locking. Outputs specify an address field,
which essentially gives the control of the funds of the output to the owner of the address account, the holder of the
corresponding private key.</p>
<p>In order to make alias accounts (smart contract chains) able to receive funds, we need to define a new fund locking
mechanism, called alias locking. An alias locked output can be unlocked by unlocking the given alias output for
state transition in the very same transaction.</p>
<p>An alias account (smart contract chain) can receive funds now, but there are additional requirements to be satisfied 
for smart contracts:</p>
<ul>
<li>Alias locked outputs represent smart contract requests, and hence, need to contain metadata that is interpreted on
layer 2.</li>
<li>A dormant smart contract chain might never consume alias locked outputs, therefore, there needs to be a fallback
mechanism for the user to reclaim the funds locked into the request.</li>
<li>Requests might be scheduled by the user by specifying a time locking condition on the output. The output can not be
spent before the time locking period expires.</li>
</ul>
<p>As we can see, there are couple new concepts regarding outputs that we need to support for the smart contract use case:</p>
<ul>
<li><strong>alias locking</strong></li>
<li><strong>metadata tied to output</strong></li>
<li><strong>fallback unlocking mechanism</strong></li>
<li><strong>time locking</strong></li>
</ul>
<p>In the next section, we are going to design an <strong>Extended Output</strong> model that can support these concepts.</p>
<h2 id="extended-output"><a class="header" href="#extended-output">Extended Output</a></h2>
<p>An extended output is an output that supports alias locking, output metadata, fallback unlocking mechanisms and time
locking. The structure of an extended output is as follows:</p>
<p>Extended Output:</p>
<ul>
<li><strong>AliasID</strong>: the alias account that is allowed to unlock this output.</li>
<li><strong>Token Balances</strong>: tokens locked by the output.</li>
<li><strong>Metadata</strong>: optional, bounded size binary data.</li>
<li><strong>FallbackAccount</strong>: an alias or address that can unlock the output after <strong>FallbackDeadline</strong>.</li>
<li><strong>FallbackDeadline</strong>: a point in time after which the output might be unlocked by <strong>FallbackAccount</strong>.</li>
<li><strong>Timelock</strong> (Optional): a point in time. When present, the output can not be unlocked before.</li>
</ul>
<h3 id="unlocking-via-aliasid"><a class="header" href="#unlocking-via-aliasid">Unlocking via AliasID</a></h3>
<p>The extended output can be unlocked by unlocking the alias output with aliasID by the state controller within the same
transaction. The unlock block of an extended output then references the unlock block of the corresponding alias output.</p>
<p>Aliases abstract away the underlying address of a smart contract committee, so when a committee is rotated, <code>aliasID</code>
stays the same, but the address where the alias points to can be changed.</p>
<p>It is trivial then to define the unique account of a smart contract on layer 1 as the <code>aliasID</code>, however, a new locking
mechanism is needed on the UTXO layer to be able to tie funds to an alias.</p>
<p>Previously, only addresses defined accounts in the protocol. Funds can be locked into addresses, and a signature of the
respective address has to be provided in the transaction to spend funds the account.</p>
<p>With the help of aliases, it is possible to extend the capabilities of the protocol to support locking funds into
aliases. This is what we call alias locking. An alias locked output specifies an <code>aliasID</code> that can spend the funds
from this output. The owner of the alias account can spend aforementioned alias locked outputs by unlocking/moving the
alias in the very same transaction. We will use the term <code>ExtendedLockedOutput</code> for outputs that support alias locking.</p>
<p>Let's illustrate this through a simple example. Alice wants to send 10 Mi to Bob's alias account. Bob then wants to
spend the 10 Mi from his alias account to his address account.</p>
<ol>
<li>Bob creates an alias where <code>aliasID=BobAliasID</code> with Transaction A.</li>
</ol>
<p><img src="https://i.imgur.com/FqVB0aY.png" alt="" /></p>
<ol start="2">
<li>Bob shares <code>BobAliasID</code> with Alice.</li>
<li>Alice sends 10 Mi to Bob by sending Transaction B that creates an <code>ExtendedLockedOutput</code>, specifying the balance,
and <code>aliasID=BobAliasID</code>.</li>
</ol>
<p><img src="https://i.imgur.com/HOxUhlp.png" alt="" /></p>
<ol start="4">
<li>Bob can spend the outputs created by Alice by creating Transaction C that moves his <code>BobAlias</code> (to the very same
address), and including the  <code>ExtendedLockedOutput</code> with <code>aliasID=BobAliasID</code>.</li>
</ol>
<p><img src="https://i.imgur.com/PdjXVKG.png" alt="" /></p>
<p>In a simple scenario, a user wishing to send a request to a smart contract creates an extended output. The output
contains the AliasID of the smart contract chain account, the layer 2 request as metadata, and some tokens to pay
for the request. Once the transaction is confirmed, the smart contract chain account &quot;receives&quot; the output. It
interprets the request metadata, carries out the requested operation in its chain, and submits a transaction that
contains the updated smart contract chain state (alias output), and also spends the extended output to increase
the balance of its alias output.</p>
<p>What happens when the smart contract chain goes offline or dies completely? How do we prevent the extended output to
be lost forever?</p>
<h3 id="unlocking-via-fallback"><a class="header" href="#unlocking-via-fallback">Unlocking via Fallback</a></h3>
<p>Extended outputs can also define a fallback account and a fallback deadline. After the fallback deadline, only the
fallback account is authorized to unlock the extended output. Fallback deadline cannot be smaller than a protocol
wide constant to give enough time to the smart contract chain to pick up the request.</p>
<p>Fallback unlocking can either be done via signature unlocking or alias unlocking, depending on the type  of account
specified.</p>
<h3 id="timelock"><a class="header" href="#timelock">Timelock</a></h3>
<p>Timelocking outputs is a desired operation not only for smart contracts, but for other use cases as well. A user might
for example scheduled a request to a smart contract chain at a later point in time by timelocking the extended output
for a certain period.</p>
<p>Timelocks can be implemented quite easily if transactions have enforced timestamps: the output can not be unlocked if
the transaction timestamp is before the timelock specified in the output.</p>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>One of the most important change that the new output types imply is that checking the validity of an unlock block of a
certain consumed input has to be done in the context of the transaction. Previously, an unlock block was valid if the
provided signature was valid. Now, even if the signature is valid for an alias output unlocked for state transition,
additional constraints also have to be met.</p>
<h2 id="how-does-it-work-for-iscp"><a class="header" href="#how-does-it-work-for-iscp">How does it work for ISCP?</a></h2>
<ul>
<li>The new output types are completely orthogonal to colored coins, ISCP will not rely on them anymore.</li>
<li>The Alias output functions as a chain constraint to allow building a non-forkable chain of transactions in the
ledger by the state controller. The alias output holds tokens, that are the balance of the smart contract chain.
The hash of the smart contract chain state is stored in the alias output, registering each state transition as a
transaction on the ledger.</li>
<li>The governance controller of an alias output can change the state controller, meaning that a committee rotation can
be carried out without changing the smart contract chain account, aliasID.
<ul>
<li>A smart contract chain can be self governed, if the state and governance controllers coincide.</li>
<li>A smart contract chain can be governed by an address account, or by another smart contract chain through an 
alias account.</li>
</ul>
</li>
<li>Each Extended Output is a request which is “sent” to the alias account. The ISCP can retrieve the backlog of
requests by retrieving all outputs for the aliasID. Consuming the Extended Output means it is atomically removed
from the backlog. It can only be done by the state controller, i.e. the committee of the smart contract chain.</li>
<li>Fallback parameters prevent from losing funds if the committee is inactive for some timeout. After timeout the 
Extended Output can be unlocked by FallbackAccount, an address or another alias.</li>
</ul>
<h2 id="additional-use-cases"><a class="header" href="#additional-use-cases">Additional Use Cases</a></h2>
<h3 id="delegated-keys"><a class="header" href="#delegated-keys">Delegated Keys</a></h3>
<p>An alias output is controlled by two parties: the state controller and the governance controller. The state controller
can only change the state metadata and the tokens when spending the output, therefore it only has the right to move the
alias to the very same account in a transaction. The governance controller however can change the state controller, or
destroy the alias and hence release the funds locked into it.</p>
<p>This makes it an ideal candidate for mana delegation, that is a crucial part of a mana marketplace. In Coordidice,
moving funds generate access and consensus mana. Alias outputs make it possible to delegate the right to move funds
without losing control over them.</p>
<ol>
<li>An account owning funds create an alias output and locks funds into it. The governance controller of the alias output
shall be <code>ownAccount</code>.</li>
<li>An entity in need of mana generated by the locked funds can purchase the right from the governance controller to
move the alias output, generating mana.</li>
<li>Once purchased, the governance controller updates the alias output by specifying the state controller to be
<code>buyerAccount</code>.</li>
<li><code>buyerAccount</code> now can move the alias output, but only to its own account. Each move generates (access) mana.</li>
<li>Since <code>ownAccount</code> is the governance controller, it can revoke <code>buyerAccount</code>'s state controlling right at any point
in time.</li>
<li><code>ownAccount</code> can also destroy the alias and &quot;free&quot; the locked funds.</li>
</ol>
<p>Notes:</p>
<ul>
<li>The state controller can redeem funds from the alias output up to the point where only <code>minimum allowed amount</code> is
present in the alias output. Therefore, without additional mechanism, it would only make sense to lock
<code>minimum allowed amount</code> into an alias by the governance controller. This is obviously a drawback, users should not
be restricted in how many funds they would like to delegate.</li>
<li>A governance controller can destroy the alias output at any time, which is not desired from the buyer perspective.
The buyer should be able to buy the right to move the funds for a pre-defined amount of time.</li>
</ul>
<p>To solve above problems, the <code>AliasOutput</code> currently implemented in GoShimmer supports the delegation use case by
introducing two new fields in the output:</p>
<ul>
<li><code>isDelegated</code> and</li>
<li><code>delegationTimelock</code>.</li>
</ul>
<p>When an alias is delegated, the state controller cannot modify token balances, and the governor can destroy the
output with any balance. However, when delegation time lock is present, the governor is not allowed to unlock the
output until the delegation time expires.</p>
<h3 id="non-fungible-tokens"><a class="header" href="#non-fungible-tokens">Non-Fungible Tokens</a></h3>
<p>NFTs are unique tokens that have metadata attached to them. Since an AliasOutput implements a chain constraint in the
UTXO ledger, it is perfectly suited to represent NFTs. The unique identifier of the NFT is the <code>aliasID</code> or <code>AliasAddress</code>.
The <code>Immutable Data</code> field of the output can only be defined upon creation and can't be changed afterwards, therefore
it is perfect to store metadata belonging to the NFT.</p>
<p>The ID of an IOTA NFT is also a valid address, therefore the NFT itself can receive and manage funds and other NFTs as
well. Refer to the <a href="protocol_specification/../tutorials/wallet.html">cli-wallet tutorial</a> for an overview of what you can do with an NFT.</p>
<p>Interestingly, minting an IOTA NFT costs you only the minimum required deposit balance (0.0001 MI at the moment), which
you can take back when you destroy the NFT. This is required so that NFTs are not minted out of thin air, and there are
some IOTAs backing the output. Otherwise, the ledger database could be easily spammed.
Transferring NFTs is also feeless, just like any other transaction in IOTA.</p>
<h2 id="goshimmer-implementation"><a class="header" href="#goshimmer-implementation">Goshimmer Implementation</a></h2>
<p>If you are interested, you can find the GoShimmer implementation of the new ouput types in
<a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go">output.go</a>:</p>
<ul>
<li><a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go#L947">AliasOutput</a> and</li>
<li><a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go#L1840">ExtendedLockedOutput</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markers-1"><a class="header" href="#markers-1">Markers</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In order to know whether a message in the Tangle is orphaned or not, we introduce <strong>grades of finality</strong> to interpret the status of a message. The higher grade of finality is determined by the <strong>approval weight</strong>, which is the proportion of active consensus mana approving a given message.</p>
<p>To compute the approval weight of a given message we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. The <strong>marker</strong> tool is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality.</p>
<p><strong>Note</strong>: <em>Markers</em> is not a core module of the Coordicide project.</p>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p><em>Markers</em> is a tool to infer knowledge about the structure of the Tangle in terms of:
+ past/future cone membership;
+ approximate approval weight of any message;
+ tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.</p>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Active Consensus Mana</p>
<h2 id="definitions-2"><a class="header" href="#definitions-2">Definitions</a></h2>
<p>Let's define the terms related to markers:</p>
<ul>
<li><strong>Sequence:</strong> A Sequence is a sequence of markers. Each Sequence corresponds to a UTXO branch, which help us to track the structure independently. </li>
<li><strong>Sequence Identifier (<code>SID</code>):</strong> A Sequence Identifier is the unique identifier of a Sequence.</li>
<li><strong>Marker Index (<code>MI</code>):</strong> A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index. </li>
<li><strong>marker:</strong> A marker is a pair of numbers: <code>SID</code> and <code>MI</code> associated to a given message. Markers carrying the same <code>SID</code> belong to the same Sequence.</li>
<li><strong>future marker (<code>FM</code>):</strong> A future marker of a message is the first marker in its future cone from different sequences; this field in the message metadata is updated when the new marker is generated in the future, following the rules defined in <a href="protocol_specification/markers.html#future-markers">Future Markers</a>.</li>
<li><strong>past marker (<code>PM</code>):</strong> A past marker of a message is a marker in its past cone. For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest <code>MI</code>. The past marker of a marker is set to itself.</li>
<li><strong>sequence rank:</strong> The rank of a sequence will be simply called rank throughout this code. Bear in mind that for clarity the marker rank is called index.</li>
</ul>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="the-markers"><a class="header" href="#the-markers">The Markers</a></h3>
<p>Markers are messages selected from the tip set periodically and assigned unique identifiers, in the form of $[SID, MI]$. </p>
<h4 id="marker-structure"><a class="header" href="#marker-structure">Marker Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>SequenceID</td>
        <td>uint64</td>
        <td>The Sequence identifier of the marker.</td>
    </tr>
    <tr>
        <td>Index</td>
        <td>uint64</td>
        <td>The index of the marker in the sequence.</td>
    </tr>
</table>
<h4 id="create-markers"><a class="header" href="#create-markers">Create Markers</a></h4>
<p>A new marker is created when:</p>
<ol>
<li>the default conditions are met, which will be one of these options:
<ul>
<li><strong>every x messsages</strong>;</li>
</ul>
<ul>
<li><strong>every t seconds</strong>;</li>
<li>a mix of the first two!
<ul>
<li>Upperbound given by the messages</li>
<li>Lower temporal bound given by the time</li>
</ul>
</li>
<li>every x messages that reference (directly or indirectly) the previous marker
<ul>
<li>Lower bound given by rank (e.g., how far you are in terms of steps) -&gt; &gt;= 10 or something</li>
<li>Upper bound given by the amount of messages referencing the previous one -&gt; ~ 200 msgs</li>
</ul>
</li>
</ul>
</li>
<li>A new sequence is created. </li>
</ol>
<blockquote>
<p>:mega: to be confirmed here.</p>
</blockquote>
<p>A new marker is selected from the strong tips set randomly, and selected from the weak tips set if there's no strong tip. A new pair of $[SID, MI]$ is assigned to the new marker. </p>
<blockquote>
<p>:mega:  to be confirmed here.</p>
</blockquote>
<p>The <code>SID</code> is set according to the following rules:</p>
<ul>
<li>Inherit the <code>SID</code> from parents if the new marker references the latest marker of a sequence and meets the requirement to set up a new marker without initiating a new MS.</li>
<li>Create a new <code>SID</code> if it is the first marker of a new sequence.</li>
</ul>
<p>The <code>MI</code> is set to $MI = 1+ max(referencedMI)$, which complies to the rule:</p>
<ul>
<li>Marker indexes (<code>MI</code>s) are monotonically increasing such that $\forall x \in fc(y)$ =&gt; $MI_x &gt; MI_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.</li>
</ul>
<h3 id="markers-in-messages"><a class="header" href="#markers-in-messages">Markers in Messages</a></h3>
<p>Each message keeps its associated marker information in two lists:</p>
<ul>
<li>past markers </li>
<li>future markers </li>
</ul>
<p>These lists for past markers and future markers are used to determine whether a message is in the past cone of the other, and the list for future markers also helps us to efficiently estimate the approval weight of a message.</p>
<h4 id="structuredetails-structure"><a class="header" href="#structuredetails-structure">StructureDetails Structure</a></h4>
<p>StructureDetails is a structure that will be in the message metadata containing marker information.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rank</td>
        <td>uint64</td>
        <td>The rank of the message.</td>
    </tr>
    <tr>
        <td>IsPastMarker</td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td>PastMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>PM list</b>, a list of PMs from different sequences.</td>
    </tr>
    <tr>
        <td>FutureMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>FM list</b>, a list of FMs from different sequences.</td>     
    </tr>
</table>
<h5 id="past-markers"><a class="header" href="#past-markers">Past Markers</a></h5>
<ul>
<li>The <code>PM</code> list of a marker contains the marker itself only.</li>
<li>The <code>PM</code> list of non-marker messages is inherited from its <strong>strong</strong> parents, with 2 steps:
<ol>
<li>for a given sequence select only the nearest marker (i.e. the markers with the highest <code>MI</code>). Thus for every sequence from the parents there will be exactly one marker.</li>
<li>remove those that have been referenced by other markers from this set. </li>
</ol>
</li>
</ul>
<h5 id="future-markers"><a class="header" href="#future-markers">Future Markers</a></h5>
<p>The <code>FM</code> list of a message is empty at start and gets updated when a new marker directly or indirectly references it. The propagation of a <code>FM</code> to its past cone (i.e. the update of the <code>FutureMarkers</code> field in the encountered messages) does not continue beyond a message if:</p>
<ol>
<li>the <code>FM</code> list of a message includes a previous marker of the same sequence;</li>
<li>the message is the marker in the different sequence, we update the <code>FM</code> list of that marker only.</li>
</ol>
<h3 id="the-sequence"><a class="header" href="#the-sequence">The Sequence</a></h3>
<p>Sequences are used to track the UTXO DAG branches, each branch corresponds to a sequence with a unique <code>SID</code>, and the sequences form a DAG as well.</p>
<h4 id="sequence-structure"><a class="header" href="#sequence-structure">Sequence Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>id</td>
        <td>uint64</td>
        <td>The sequence identifier of the sequence.</td>
    </tr>
    <tr>
        <td>parentReferences</td>
        <td>map[uint64]Thresholdmap</td>
        <td>The marker referenced map of each parent marker.</td>
    </tr>
    <tr>
        <td>rank</td>
        <td>uint64</td>
        <td>The rank of the sequence in the marker DAG.</td>
    </tr>
    <tr>
        <td>highestIndex</td>
        <td>uint64</td>
        <td>The highest MI of the marker sequence.</td>
    </tr>
    <tr>
        <td>lowestIndex</td>
        <td>uint64</td>
        <td>The lowest MI of the sequence.</td>
    </tr>
</table>
<h4 id="create-sequence"><a class="header" href="#create-sequence">Create Sequence</a></h4>
<p>A new sequence is created when:</p>
<ol>
<li>there's a conflict in a UTXO branch.</li>
<li>the UTXO branches are aggregated.</li>
<li>UTXO branches are merged.</li>
</ol>
<p>Each new sequence starts from a new marker.</p>
<h4 id="sequences"><a class="header" href="#sequences">Sequences</a></h4>
<p>For whatever reason a sequence is created, we assign a new $SID = 1+max(referenceSequencesIdentifiers)$. To prevent assigning a new <code>SID</code> when combining same sequences again, we build parents-child relation in a map if a new sequence is created. </p>
<h4 id="sequence-rank"><a class="header" href="#sequence-rank">Sequence Rank</a></h4>
<p>The rank of a sequence graph is the number of sequences from the starting point to itself. The sequence ranks are shown in the figure above.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>Here is an example of how the markers and sequences structures would look in the Tangle:
The purple colored messages are markers.</p>
<p><img src="https://i.imgur.com/GENej3O.png" alt="" /></p>
<h2 id="example-2-test-for-the-mapping-interaction-with-the-booker"><a class="header" href="#example-2-test-for-the-mapping-interaction-with-the-booker">Example 2: Test for the Mapping interaction with the Booker</a></h2>
<p>The Marker tool implementation is tested for correct Marker and Booker mapping. A transaction-by-transaction discussion of the test can be found <a href="https://github.com/iotaledger/goshimmer/blob/develop/packages/tangle/images/TestBookerMarkerMappings.md">here</a> and can be viewed by opening the file locally in a browser. Transactions arrive in the order of the their transaction number. The end result and the values in the various fields is shown in the following figures:</p>
<p><img src="https://imgur.com/h6Hs3xG.png" alt="" /></p>
<p><img src="https://imgur.com/sCkXXrG.png" alt="" /></p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>In the following we describe some of the functions in more detail.</p>
<h3 id="normalization-of-the-referenced-pms-and-sequences"><a class="header" href="#normalization-of-the-referenced-pms-and-sequences">Normalization of the referenced PMs and Sequences</a></h3>
<p>Messages can have markers from different sequences in <code>PM</code> list and <code>FM</code> list, the order and referenced relationship among sequences are important for example when it comes to inheriting the <code>PM</code> list from parents. Thus, we need to track these sequences.</p>
<p>When a new sequence is created we check the parent marker' sequences with the function <code>normalizeMarkers()</code> in order from high to low rank. In this function, we remove those <code>PM</code>s that it's belonging sequence is referenced by others.</p>
<p>An example is <strong>msg 10</strong> in the figure above, $[0,2], [1,1], [2,3]$ are <code>PM</code>s to be considered to inherit. $[2,3]$ is the first marker to check, since it has the highest sequence rank. We select the parent sequences of $[2,3]$, which are $0$ and $1$, and the referenced <code>PM</code>s therein. Next any <code>PM</code>s that are already referenced can be removed. This results in that the PMs of <strong>msg 10</strong> is $[2,3]$ only.</p>
<p>In the following we show the implementation of  <code>normalizeMarkers()</code>, which returns the markers and sequences that will be inherited from a message.</p>
<pre><code class="language-go">// normalizeMarkers takes a set of Markers and removes each Marker that is already referenced by another Marker in the
// same set (the remaining Markers are the &quot;most special&quot; Markers that reference all Markers in the set grouped by the
// rank of their corresponding Sequence). In addition, the method returns all SequenceIDs of the Markers that were not
// referenced by any of the Markers (the tips of the Sequence DAG).
func (m *Manager) normalizeMarkers(markers *Markers) (normalizedMarkersByRank *markersByRank, normalizedSequences SequenceIDs) {
	rankOfSequencesCache := make(map[SequenceID]uint64)

	normalizedMarkersByRank = newMarkersByRank()
	normalizedSequences = make(SequenceIDs)
	// group markers with same sequence rank
	markers.ForEach(func(sequenceID SequenceID, index Index) bool {
		normalizedSequences[sequenceID] = types.Void
		normalizedMarkersByRank.Add(m.rankOfSequence(sequenceID, rankOfSequencesCache), sequenceID, index)

		return true
	})
	markersToIterate := normalizedMarkersByRank.Clone()

	//iterate from highest sequence rank to lowest
	for i := markersToIterate.HighestRank() + 1; i &gt; normalizedMarkersByRank.LowestRank(); i-- {
		currentRank := i - 1
		markersByRank, rankExists := markersToIterate.Markers(currentRank)
		if !rankExists {
			continue
		}

		// for each marker from the current sequence rank check if we can remove a marker in normalizedMarkersByRank,
		// and add the parent markers to markersToIterate if necessary
		if !markersByRank.ForEach(func(sequenceID SequenceID, index Index) bool {
			if currentRank &lt;= normalizedMarkersByRank.LowestRank() {
				return false
			}

			if !(&amp;CachedSequence{CachedObject: m.sequenceStore.Load(sequenceID.Bytes())}).Consume(func(sequence *Sequence) {
				// for each of the parentMarkers of this particular index
				sequence.HighestReferencedParentMarkers(index).ForEach(func(referencedSequenceID SequenceID, referencedIndex Index) bool {
					// of this marker delete the referenced sequences since they are no sequence tips anymore in the sequence DAG
					delete(normalizedSequences, referencedSequenceID)

					rankOfReferencedSequence := m.rankOfSequence(referencedSequenceID, rankOfSequencesCache)
					// check whether there is a marker in normalizedMarkersByRank that is from the same sequence
					if index, indexExists := normalizedMarkersByRank.Index(rankOfReferencedSequence, referencedSequenceID); indexExists {
						if referencedIndex &gt;= index {
							// this referencedParentMarker is from the same sequence as a marker in the list but with higher index - hence remove the index from the Marker list
							normalizedMarkersByRank.Delete(rankOfReferencedSequence, referencedSequenceID)

							// if rankOfReferencedSequence is already the lowest rank of the original markers list,
							// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
							if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
								markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
							}
						}

						return true
					}

					// if rankOfReferencedSequence is already the lowest rank of the original markers list,
					// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
					if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
						markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
					}

					return true
				})
			}) {
				panic(fmt.Sprintf(&quot;failed to load Sequence with %s&quot;, sequenceID))
			}

			return true
		}) {
			return
		}
	}

	return
}
</code></pre>
<h3 id="markers-application-past-cone-check"><a class="header" href="#markers-application-past-cone-check">Markers Application: Past Cone Check</a></h3>
<p>By comparing the past and future markers of messages, we can easily tell if one is in another's past cone. The function returns a <code>TriBool</code> representing the three possible statuses: <code>True</code>, <code>False</code> and <code>Maybe</code>. If <code>Maybe</code> is returned, then we need to perform a search of the Tangle by walking by means of e.g. a Breadth-First Search.</p>
<p>In the following we show the implementation of the past cone check: </p>
<pre><code class="language-go">// IsInPastCone checks if the earlier Markers are directly or indirectly referenced by the later Markers.
func (m *Manager) IsInPastCone(earlierMarkers *MarkersPair, laterMarkers *MarkersPair) (referenced TriBool) {
	// fast check: if earlier Markers have larger highest Indexes they can't be in the past cone
	if earlierMarkers.PastMarkers.HighestIndex() &gt; laterMarkers.PastMarkers.HighestIndex() {
		return False
	}

	// fast check: if earlier Marker is a past Marker and the later ones reference it we can return early
	if earlierMarkers.IsPastMarker {
		earlierMarker := earlierMarkers.PastMarkers.FirstMarker()
		if earlierMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		if laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(earlierMarker.sequenceID); sequenceExists {
			if laterIndex &gt;= earlierMarker.index {
				return True
			}

			return False
		}

		if laterMarkers.PastMarkers.HighestIndex() &lt;= earlierMarker.index {
			return False
		}
	}

	if laterMarkers.IsPastMarker {
		laterMarker := laterMarkers.PastMarkers.FirstMarker()
		if laterMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		// if the earlier Marker inherited an Index of the same Sequence that is higher than the later we return false
		if earlierIndex, sequenceExists := earlierMarkers.PastMarkers.Get(laterMarker.sequenceID); sequenceExists &amp;&amp; earlierIndex &gt;= laterMarker.index {
			return False
		}

		// if the earlier Markers are referenced by a Marker of the same Sequence that is larger, we are not in the past cone
		if earlierFutureIndex, earlierFutureIndexExists := earlierMarkers.FutureMarkers.Get(laterMarker.sequenceID); earlierFutureIndexExists &amp;&amp; earlierFutureIndex &gt; laterMarker.index {
			return False
		}

		// if the earlier Markers were referenced by the same or a higher future Marker we are not in the past cone
		// (otherwise we would be the future marker)
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			earlierIndex, similarSequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
			return !similarSequenceExists || earlierIndex &lt; laterIndex
		}) {
			return False
		}

		if earlierMarkers.PastMarkers.HighestIndex() &gt;= laterMarker.index {
			return False
		}
	}

	// if the highest Indexes of both past Markers are the same ...
	if earlierMarkers.PastMarkers.HighestIndex() == laterMarkers.PastMarkers.HighestIndex() {
		// ... then the later Markers should contain exact copies of all of the highest earlier Markers because parent
		// Markers get inherited and if they would have been captured by a new Marker in between then the highest
		// Indexes would no longer be the same
		if !earlierMarkers.PastMarkers.ForEach(func(sequenceID SequenceID, earlierIndex Index) bool {
			if earlierIndex == earlierMarkers.PastMarkers.HighestIndex() {
				laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; laterIndex != earlierIndex
			}

			return true
		}) {
			return False
		}
	}

	if earlierMarkers.FutureMarkers.HighestIndex() == laterMarkers.FutureMarkers.HighestIndex() &amp;&amp; false {
		// the earlier future markers need to contain all later ones because if there would be another marker in between that shadows them the later future Marker would have a higher index
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			if laterIndex == laterMarkers.FutureMarkers.highestIndex {
				earlierIndex, sequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; earlierIndex == laterIndex
			}

			return true
		}) {
			return False
		}
	}

	// detailed check: earlier marker is referenced by something that the later one references
	if m.markersReferenceMarkers(laterMarkers.PastMarkers, earlierMarkers.FutureMarkers, false) {
		return True
	}

	// detailed check: the
	if m.markersReferenceMarkers(earlierMarkers.FutureMarkers, laterMarkers.PastMarkers, true) {
		return Maybe
	}

	return False
}

</code></pre>
<h3 id="markers-application-approval-weight-estimation"><a class="header" href="#markers-application-approval-weight-estimation">Markers Application: Approval Weight Estimation</a></h3>
<p>To approximate the approval weight of a message, we simply retrieve the approval weight of its <code>FM</code> list. Since the message is in the past cone of its <code>FM</code>s, the approval weight and the finality will be at least the same as its <code>FM</code>s. This will of course be a lower bound (which is the “safe” bound), but if the markers are set frequently enough, it should be a good approximation.</p>
<p>For details of managing approval weight of each marker and approval weight calculation thereof please refer to <a href="protocol_specification/./consensus_mechanism.html#approval-weight-aw">Approval Weight</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<hr />
<h2 id="consensus"><a class="header" href="#consensus">CONSENSUS</a></h2>
<p>Agreement on a specific datum or value in distributed multi-agent systems, in the presence of faulty processes.</p>
<h3 id="blockchain-bottleneck"><a class="header" href="#blockchain-bottleneck">BLOCKCHAIN BOTTLENECK</a></h3>
<p>As more transactions are issued, the block rate and size become a bottleneck in the system. It can no longer include all incoming transactions promptly. Attempts to speed up block rates will introduce more orphan blocks (blocks being left behind) and reduce the security of the blockchain.</p>
<h3 id="nakamoto-consensus"><a class="header" href="#nakamoto-consensus">NAKAMOTO CONSENSUS</a></h3>
<p>Named after the originator of Bitcoin, Satoshi Nakamoto, Nakamoto consensus describes the replacement of voting/communication between known agents with a cryptographic puzzle (Proof-of-Work). Completing the puzzle determines which agent is the next to act.</p>
<h3 id="mining-races"><a class="header" href="#mining-races">MINING RACES</a></h3>
<p>In PoW-based DLTs, competition between nodes to obtain mining rewards and transaction fees are known as mining races. These are undesirable as they favor more powerful nodes, especially those with highly optimized hardware like ASICs. As such, they block participation by regular or IoT hardware and are harmful for the environment.</p>
<h3 id="proof-of-work"><a class="header" href="#proof-of-work">PROOF-OF-WORK</a></h3>
<p>Data which is difficult (costly, time-consuming) to produce but easy for others to verify.</p>
<hr />
<h2 id="coordinator"><a class="header" href="#coordinator">COORDINATOR</a></h2>
<p>A trusted entity that issues milestones to guarantee finality and protect the Tangle against attacks.</p>
<h3 id="milestones"><a class="header" href="#milestones">MILESTONES</a></h3>
<p>Milestones are transactions signed and issued by the Coordinator. Their main goal is to help the Tangle to grow healthily and to guarantee finality. When milestones directly or indirectly approve a transaction in the Tangle, nodes mark the state of that transaction and its entire history as confirmed.</p>
<hr />
<h2 id="tangle-1"><a class="header" href="#tangle-1">TANGLE</a></h2>
<p>An append only message data structure where each message references (at least) two other messages.</p>
<h3 id="subtangle"><a class="header" href="#subtangle">SUBTANGLE</a></h3>
<p>A consistent section of the Tangle (i.e. a subset of messages), such that each included message also includes its referenced messages.</p>
<hr />
<h2 id="network-layer-1"><a class="header" href="#network-layer-1">NETWORK LAYER</a></h2>
<p>This layer manages the lower layers of internet communication like TCP. It is the most technical, and in some ways the least interesting. In this layer, the connections between nodes are managed by the autopeering and peer discovery modules and the gossip protocol.</p>
<h3 id="peering"><a class="header" href="#peering">PEERING</a></h3>
<p>The procedure of discovering and connecting to other network nodes.</p>
<h3 id="neighbors"><a class="header" href="#neighbors">NEIGHBORS</a></h3>
<p>Network nodes that are directly connected and can exchange messages without intermediate nodes.</p>
<h3 id="node"><a class="header" href="#node">NODE</a></h3>
<p>A machine which is part of the IOTA network. Its role is to issue new transactions and to validate existing ones.</p>
<h3 id="small-world-network"><a class="header" href="#small-world-network">SMALL-WORLD NETWORK</a></h3>
<p>A network in which most nodes can be reached from every other node by a few intermediate steps.</p>
<h3 id="eclipse-attack"><a class="header" href="#eclipse-attack">ECLIPSE ATTACK</a></h3>
<p>A cyber-attack that aims to isolate and attack a specific user, rather than the whole network.</p>
<h3 id="splitting-attacks"><a class="header" href="#splitting-attacks">SPLITTING ATTACKS</a></h3>
<p>An attack in which a malicious node attempts to split the Tangle into two branches. As one of the branches grows, the attacker publishes transactions on the other branch to keep both alive. Splitting attacks attempt to slow down the consensus process or conduct a double spend.</p>
<h3 id="sybil-attack"><a class="header" href="#sybil-attack">SYBIL ATTACK</a></h3>
<p>An attempt to gain control over a peer-to-peer network by forging multiple fake identities.</p>
<hr />
<h2 id="communication-layer-1"><a class="header" href="#communication-layer-1">COMMUNICATION LAYER</a></h2>
<p>This layer stores and communicates information. This layer contains the “distributed ledger” or the tangle. The rate control and timestamps are in this layer too.</p>
<h3 id="message"><a class="header" href="#message">MESSAGE</a></h3>
<p>The object that is gossiped between neighbors. All gossiped information is included in a message. The most basic unit of information of the IOTA Protocol. Each message has a type and size and contains data.</p>
<h3 id="message-overhead"><a class="header" href="#message-overhead">MESSAGE OVERHEAD</a></h3>
<p>The additional information (metadata) that needs to be sent along with the actual information (data). This can contain signatures, voting, heartbeat signals, and anything that is transmitted over the network but is not the transaction itself.</p>
<h3 id="parent"><a class="header" href="#parent">PARENT</a></h3>
<p>A message approved by another message is called a parent to the latter. A parent can be selected as strong or weak parent. If the past cone of the parent is liked the parent is set as strong parent. If the message is liked but its past cone is disliked it is set as a weak parent. This mechanism is called approval switch.</p>
<h3 id="payload-2"><a class="header" href="#payload-2">PAYLOAD</a></h3>
<p>A field in a message which determines the type. Examples are:</p>
<ul>
<li>Value payload (type TransactionType)</li>
<li>FPC Opinion payload (type StatementType)</li>
<li>dRNG payload</li>
<li>Salt declaration payload</li>
<li>Generic data payload</li>
</ul>
<hr />
<h3 id="mana"><a class="header" href="#mana">MANA</a></h3>
<p>The reputation of a node is based on a virtual token called mana. This reputation, working as a Sybil protection mechanism, is important for issuing more transactions (see Module 3) and having a higher influence during the voting process (see Module 5).</p>
<h4 id="epoch"><a class="header" href="#epoch">EPOCH</a></h4>
<p>A time interval that is used for a certain type of consensus mana. At the end of each epoch a snapshot of the state of mana distribution in the network is taken. Since this tool employs the timestamp of messages every node can reach consensus on a epoch's mana distibution eventually.</p>
<hr />
<h3 id="transaction-1"><a class="header" href="#transaction-1">TRANSACTION</a></h3>
<p>A message with payload of type TransactionType. It contains the information of a transfer of funds.</p>
<h4 id="utxo"><a class="header" href="#utxo">UTXO</a></h4>
<p>Unspent transaction output.</p>
<h4 id="orphan"><a class="header" href="#orphan">ORPHAN</a></h4>
<p>A transaction (or block) that is not referenced by any succeeding transaction (or block). An orphan is not considered confirmed and will not be part of the consensus.</p>
<h4 id="reattachment"><a class="header" href="#reattachment">REATTACHMENT</a></h4>
<p>Resending a transaction by redoing tip selection and referencing newer tips by redoing PoW.</p>
<h4 id="history"><a class="header" href="#history">HISTORY</a></h4>
<p>The list of transactions directly or indirectly approved by a given transaction.</p>
<h4 id="solidification-time"><a class="header" href="#solidification-time">SOLIDIFICATION TIME</a></h4>
<p>The solidification time is the point at which the entire history of a transaction has been received by a node.</p>
<h4 id="finality-1"><a class="header" href="#finality-1">FINALITY</a></h4>
<p>The property that once a transaction is completed there is no way to revert or alter it. This is the moment when the parties involved in a transfer can consider the deal done. Finality can be deterministic or probabilistic.</p>
<hr />
<h3 id="tip-selection"><a class="header" href="#tip-selection">TIP SELECTION</a></h3>
<p>The process of selecting previous messages to be referenced by a new message. These references are where a message attaches to the existing data structure. IOTA only enforces that a message approves (at least) two other messages, but the tip selection strategy is left up to the user (with a good default provided by IOTA).</p>
<h4 id="tip"><a class="header" href="#tip">TIP</a></h4>
<p>A message that has not yet been approved.</p>
<h4 id="local-modifiers"><a class="header" href="#local-modifiers">LOCAL MODIFIERS</a></h4>
<p>Custom conditions that nodes can take into account during tip selection. In IOTA, nodes do not necessarily have the same view of the Tangle; various kinds of information only locally available to them can be used to strengthen security.</p>
<h4 id="approval-switch"><a class="header" href="#approval-switch">APPROVAL SWITCH</a></h4>
<p>When selecting a message as a parent, we can select from the strong or weak tip pool. This mechanism is called approval switch.</p>
<h4 id="approval-weight-1"><a class="header" href="#approval-weight-1">APPROVAL WEIGHT</a></h4>
<p>A message gains mana weight, by messages approving it directly or indirectly. However, only strong parents can propagate the mana weight to the past, while weak parents obtain the weight from its weak children but don't propagate it.</p>
<hr />
<h2 id="application-layer"><a class="header" href="#application-layer">APPLICATION LAYER</a></h2>
<p>The IOTA Protocol allows for a host of applications to run on the message tangle. Anybody can design an application, and users can decide which applications to run on their nodes. These applications will all use the communication layer to broadcast and store data.</p>
<h3 id="core-applications"><a class="header" href="#core-applications">CORE APPLICATIONS</a></h3>
<p>Applications that are necessary for the protocol to operate. These include for example:</p>
<ul>
<li>The value transfer application</li>
<li>The distributed random number generator (DRNG for short)</li>
<li>The Fast Probabilistic Consensus (FPC) protocol</li>
</ul>
<h3 id="value-transfer-application"><a class="header" href="#value-transfer-application">VALUE TRANSFER APPLICATION</a></h3>
<p>The application which maintains the ledger state.</p>
<h3 id="faucet"><a class="header" href="#faucet">FAUCET</a></h3>
<p>A test application issuing funds on request.</p>
<hr />
<h2 id="markers-2"><a class="header" href="#markers-2">MARKERS</a></h2>
<p>A tool that exists only locally and allows performing certain calculations more efficiently. Such as approval weight calculation or the existence of certain messages in the past or future cone of another message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-lib-interaction-with-layers"><a class="header" href="#client-lib-interaction-with-layers">Client Lib: Interaction with layers</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<p>GoShimmer ships with a client Go library which communicates with the HTTP API. Please refer to the <a href="https://godoc.org/github.com/iotaledger/goshimmer/client">godoc.org docs</a> for function/struct documentation. There is also a set of APIs which do not directly have anything to do with the different layers. Since they are so simple, simply extract their usage from the GoDocs.</p>
<h1 id="use-the-api"><a class="header" href="#use-the-api">Use the API</a></h1>
<p>Simply <code>go get</code> the lib via:</p>
<pre><code>go get github.com/iotaledger/goshimmer/client
</code></pre>
<p>Init the API by passing in the API URI of your GoShimmer node:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;)
</code></pre>
<p>Optionally, define your own <code>http.Client</code> to use, in order for example to define custom timeouts:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;, client.WithHTTPClient{Timeout: 30 * time.Second})
</code></pre>
<h4 id="a-note-about-errors"><a class="header" href="#a-note-about-errors">A note about errors</a></h4>
<p>The API issues HTTP calls to the defined GoShimmer node. Non 200 HTTP OK status codes will reflect themselves as <code>error</code> in the returned arguments. Meaning that for example calling for attachments with a non existing/available transaction on a node, will return an <code>error</code> from the respective function. (There might be exceptions to this rule)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webapi---clientlib"><a class="header" href="#webapi---clientlib">WebAPI - clientLib</a></h1>
<p>The web API interface allows to access functionality of the node software via exposed http endpoints.</p>
<h2 id="how-to-use-the-api"><a class="header" href="#how-to-use-the-api">How to use the API</a></h2>
<p>The default port to access the web API is set to <code>8080:8080/tcp</code> in <code>docker-compose.yml</code>, where the first port number is the internal port number within the node software, and the second for the access from an http port. An example where these two would be set to different values, or the external port is not utilized, can be found in the docker-network tool (see also the <code>docker-compose.yml</code> file in the docker-network tool folder).</p>
<p>The server instance of the web API is contacted via <code>webapi.Server()</code>. Next we need to register a route with a matching handler.</p>
<pre><code>webapi.Server().ROUTE(path string, h HandlerFunc)
</code></pre>
<p>where <code>ROUTE</code> will be replaced later in this documentation by <code>GET</code> or <code>POST</code>. The <code>HandlerFunc</code> defines a function to serve HTTP requests that gives access to the Context</p>
<pre><code>func HandlerFunc(c Context) error
</code></pre>
<p>We can then use the Context to send a JSON response to the node: </p>
<pre><code>JSON(statuscode int, i interface{}) error
</code></pre>
<p>An implementation example is shown later for the POST method.</p>
<h2 id="get-and-post"><a class="header" href="#get-and-post">GET and POST</a></h2>
<p>Two methods are currently used. First, with <code>GET</code> we register a new GET route for a handler function. The handler is accessed via the address <code>path</code>. The handler for a GET method can set the node to perform certain actions.</p>
<pre><code>webapi.Server().GET(&quot;path&quot;, HandlerFunc)
```	
A command can be sent to the node software to the API, e.g. via command prompt: 
</code></pre>
<p>curl &quot;http://127.0.0.1:8080/path?command&quot;</p>
<pre><code>
$$ . $$

Second, with `POST` we register a new POST route for a handler function. The handler can receive a JSON body input and send specific messages to the tangle.
</code></pre>
<p>webapi.Server().POST(&quot;path&quot;, HandlerFunc)</p>
<pre><code>
For example, the following Handler `broadcastData` sends a data message to the tangle
</code></pre>
<p>func broadcastData(c echo.Context) error {
var request Request
if err := c.Bind(&amp;request); err != nil {
log.Info(err.Error())
return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}</p>
<pre><code>msg, err := messagelayer.IssuePayload(
	payload.NewGenericDataPayload(request.Data), messagelayer.Tangle())
if err != nil {
	return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}
return c.JSON(http.StatusOK, Response{ID: msg.ID().String()})
</code></pre>
<p>}</p>
<pre><code>As an example the JSON body   
</code></pre>
<p>{
&quot;data&quot;:&quot;HelloWor&quot;
}</p>
<pre><code>can be sent to `http://127.0.0.1:8080/data`, which will issue a data message containing &quot;HelloWor&quot; (note that in this  example the data input is size limited.)
 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="info-api-methods"><a class="header" href="#info-api-methods">Info API Methods</a></h1>
<p>Info API returns basic info about the node</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/info.html#info">/info</a></li>
<li><a href="apis/info.html#healthz">/healthz</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/info.html#client-lib---info">Info()</a></li>
</ul>
<h2 id="info"><a class="header" href="#info"><code>/info</code></a></h2>
<p>Returns basic info about the node.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<p>None.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="curl"><a class="header" href="#curl">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/info'
</code></pre>
<h4 id="client-lib---info"><a class="header" href="#client-lib---info">Client lib - <code>Info</code></a></h4>
<p>Information of a node can be retrieved via <code>Info() (*jsonmodels.InfoResponse, error)</code></p>
<pre><code class="language-go">info, err := goshimAPI.Info()
if err != nil {
    // return error
}

// will print the response
fmt.Println(string(info))
</code></pre>
<h4 id="response-example"><a class="header" href="#response-example">Response example</a></h4>
<pre><code class="language-json">{
  &quot;version&quot;: &quot;v0.6.2&quot;,
  &quot;networkVersion&quot;: 30,
  &quot;tangleTime&quot;: {
    &quot;messageID&quot;: &quot;6ndfmfogpH9H8C9X9Fbb7Jmuf8RJHQgSjsHNPdKUUhoJ&quot;,
    &quot;time&quot;: 1621879864032595415,
    &quot;synced&quot;: true
  },
  &quot;identityID&quot;: &quot;D9SPFofAGhA5V9QRDngc1E8qG9bTrnATmpZMdoyRiBoW&quot;,
  &quot;identityIDShort&quot;: &quot;XBgY5DsUPng&quot;,
  &quot;publicKey&quot;: &quot;9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd&quot;,
  &quot;solidMessageCount&quot;: 74088,
  &quot;totalMessageCount&quot;: 74088,
  &quot;enabledPlugins&quot;: [
    &quot;Activity&quot;,
    &quot;Analysis-Client&quot;,
    &quot;Autopeering&quot;,
    &quot;Banner&quot;,
    &quot;CLI&quot;,
    &quot;Clock&quot;,
    &quot;Config&quot;,
    &quot;Consensus&quot;,
    &quot;DRNG&quot;,
    &quot;Dashboard&quot;,
    &quot;Database&quot;,
    &quot;Gossip&quot;,
    &quot;Graceful Shutdown&quot;,
    &quot;Logger&quot;,
    &quot;Mana&quot;,
    &quot;ManaRefresher&quot;,
    &quot;Manualpeering&quot;,
    &quot;MessageLayer&quot;,
    &quot;Metrics&quot;,
    &quot;NetworkDelay&quot;,
    &quot;PoW&quot;,
    &quot;PortCheck&quot;,
    &quot;Profiling&quot;,
    &quot;Prometheus&quot;,
    &quot;RemoteLog&quot;,
    &quot;RemoteLogMetrics&quot;,
    &quot;WebAPI&quot;,
    &quot;WebAPI DRNG Endpoint&quot;,
    &quot;WebAPI Mana Endpoint&quot;,
    &quot;WebAPI WeightProvider Endpoint&quot;,
    &quot;WebAPI autopeering Endpoint&quot;,
    &quot;WebAPI data Endpoint&quot;,
    &quot;WebAPI faucet Endpoint&quot;,
    &quot;WebAPI healthz Endpoint&quot;,
    &quot;WebAPI info Endpoint&quot;,
    &quot;WebAPI ledgerstate Endpoint&quot;,
    &quot;WebAPI message Endpoint&quot;,
    &quot;WebAPI tools Endpoint&quot;,
    &quot;snapshot&quot;
  ],
  &quot;disabledPlugins&quot;: [
    &quot;Analysis-Dashboard&quot;,
    &quot;Analysis-Server&quot;,
    &quot;Faucet&quot;,
    &quot;ManaEventLogger&quot;,
    &quot;Spammer&quot;,
    &quot;TXStream&quot;
  ],
  &quot;mana&quot;: {
    &quot;access&quot;: 1,
    &quot;accessTimestamp&quot;: &quot;2021-05-24T20:11:05.451224937+02:00&quot;,
    &quot;consensus&quot;: 10439991680906,
    &quot;consensusTimestamp&quot;: &quot;2021-05-24T20:11:05.451228137+02:00&quot;
  },
  &quot;manaDelegationAddress&quot;: &quot;1HMQic52dz3xLY2aeDXcDhX53LgbsHghdfD8eGXR1qVHy&quot;,
  &quot;mana_decay&quot;: 0.00003209,
  &quot;scheduler&quot;: {
    &quot;running&quot;: true,
    &quot;rate&quot;: &quot;5ms&quot;,
    &quot;nodeQueueSizes&quot;: {}
  },
  &quot;rateSetter&quot;: {
    &quot;rate&quot;: 20000,
    &quot;size&quot;: 0
  }
}
</code></pre>
<h4 id="results"><a class="header" href="#results">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>version</code></td><td align="left"><code>String</code></td><td align="left">Version of GoShimmer.</td></tr>
<tr><td align="left"><code>networkVersion</code></td><td align="left"><code>uint32</code></td><td align="left">Network Version of the autopeering.</td></tr>
<tr><td align="left"><code>tangleTime</code></td><td align="left"><code>TangleTime</code></td><td align="left">TangleTime sync status</td></tr>
<tr><td align="left"><code>identityID</code></td><td align="left"><code>string</code></td><td align="left">Identity ID of the node encoded in base58.</td></tr>
<tr><td align="left"><code>identityIDShort</code></td><td align="left"><code>string</code></td><td align="left">Identity ID of the node encoded in base58 and truncated to its first 8 bytes.</td></tr>
<tr><td align="left"><code>publicKey</code></td><td align="left"><code>string</code></td><td align="left">Public key of the node encoded in base58</td></tr>
<tr><td align="left"><code>messageRequestQueueSize</code></td><td align="left"><code>int</code></td><td align="left">The number of messages a node is trying to request from neighbors.</td></tr>
<tr><td align="left"><code>solidMessageCount</code></td><td align="left"><code>int</code></td><td align="left">The number of solid messages in the node's database.</td></tr>
<tr><td align="left"><code>totalMessageCount</code></td><td align="left"><code>int</code></td><td align="left">The number of messages in the node's database.</td></tr>
<tr><td align="left"><code>enabledPlugins</code></td><td align="left"><code>[]string</code></td><td align="left">List of enabled plugins.</td></tr>
<tr><td align="left"><code>disabledPlugins</code></td><td align="left"><code>[]string</code></td><td align="left">List if disabled plugins.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left"><code>Mana</code></td><td align="left">Mana values.</td></tr>
<tr><td align="left"><code>manaDelegationAddress</code></td><td align="left"><code>string</code></td><td align="left">Mana Delegation Address.</td></tr>
<tr><td align="left"><code>mana_decay</code></td><td align="left"><code>float64</code></td><td align="left">The decay coefficient of <code>bm2</code>.</td></tr>
<tr><td align="left"><code>scheduler</code></td><td align="left"><code>Scheduler</code></td><td align="left">Scheduler is the scheduler used.</td></tr>
<tr><td align="left"><code>rateSetter</code></td><td align="left"><code>RateSetter</code></td><td align="left">RateSetter is the rate setter used.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<ul>
<li>Type <code>TangleTime</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>messageID</code></td><td align="left"><code>string</code></td><td align="left">ID of the last confirmed message.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left"><code>int64</code></td><td align="left">Issue timestamp of the last confirmed message.</td></tr>
<tr><td align="left"><code>synced</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether node is in sync.</td></tr>
</tbody></table>
<ul>
<li>Type <code>Scheduler</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>running</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether Scheduler has started.</td></tr>
<tr><td align="left"><code>rate</code></td><td align="left"><code>string</code></td><td align="left">Rate of the scheduler.</td></tr>
<tr><td align="left"><code>nodeQueueSizes</code></td><td align="left"><code>map[string]int</code></td><td align="left">The size for each node queue.</td></tr>
</tbody></table>
<ul>
<li>Type <code>RateSetter</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rate</code></td><td align="left"><code>float64</code></td><td align="left">The rate of the rate setter..</td></tr>
<tr><td align="left"><code>size</code></td><td align="left"><code>int</code></td><td align="left">The size of the issuing queue.</td></tr>
</tbody></table>
<ul>
<li>Type <code>Mana</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>access</code></td><td align="left"><code>float64</code></td><td align="left">Access mana assigned to the node.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left"><code>time.Time</code></td><td align="left">Time when the access mana was calculated.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left"><code>float64</code></td><td align="left">Consensus mana assigned to the node.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left"><code>time.Time</code></td><td align="left">Time when the consensus mana was calculated.</td></tr>
</tbody></table>
<h2 id="healthz"><a class="header" href="#healthz"><code>/healthz</code></a></h2>
<p>Returns HTTP code 200 if everything is running correctly.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<h4 id="curl-1"><a class="header" href="#curl-1">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/healthz'
</code></pre>
<h4 id="client-lib"><a class="header" href="#client-lib">Client lib</a></h4>
<p>This method is not available in client lib</p>
<h4 id="results-1"><a class="header" href="#results-1">Results</a></h4>
<p>Empty response with HTTP 200 success code if everything is running correctly.
Error message is returned if failed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peering-api-methods"><a class="header" href="#peering-api-methods">Peering API Methods</a></h1>
<p>The peering API allows retrieving basic information about autopeering.</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/autopeering.html#autopeeringneighbors">/autopeering/neighbors</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/autopeering.html#client-lib---getautopeeringneighbors">GetAutopeeringNeighbors()</a></li>
</ul>
<h2 id="autopeeringneighbors"><a class="header" href="#autopeeringneighbors"><code>/autopeering/neighbors</code></a></h2>
<p>Returns the chosen and accepted neighbors of the node.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>known</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>Return all known peers, set to <code>1</code> (default: <code>0</code>)</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<h4 id="curl-2"><a class="header" href="#curl-2">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/autopeering/neighbors?known=1'
</code></pre>
<h4 id="client-lib---getautopeeringneighbors"><a class="header" href="#client-lib---getautopeeringneighbors">Client lib - <code>GetAutopeeringNeighbors</code></a></h4>
<p>Messages can be retrieved via <code>GetAutopeeringNeighbors(knownPeers bool) (*jsonmodels.GetNeighborsResponse, error)</code></p>
<pre><code class="language-go">neighbors, err := goshimAPI.GetAutopeeringNeighbors(false)
if err != nil {
    // return error
}

// will print the response
fmt.Println(string(neighbors))
</code></pre>
<h4 id="response-examples"><a class="header" href="#response-examples">Response examples</a></h4>
<pre><code class="language-json">{
  &quot;chosen&quot;: [
    {
      &quot;id&quot;: &quot;PtBSYhniWR2&quot;,
      &quot;publicKey&quot;: &quot;BogpestCotcmbB2EYKSsyVMywFYvUt1MwGh6nUot8g5X&quot;,
      &quot;services&quot;: [
        {
          &quot;id&quot;: &quot;peering&quot;,
          &quot;address&quot;: &quot;178.254.42.235:14626&quot;
        },
        {
          &quot;id&quot;: &quot;gossip&quot;,
          &quot;address&quot;: &quot;178.254.42.235:14666&quot;
        },
        {
          &quot;id&quot;: &quot;FPC&quot;,
          &quot;address&quot;: &quot;178.254.42.235:10895&quot;
        }
      ]
    }
  ],
  &quot;accepted&quot;: [
    {
      &quot;id&quot;: &quot;CRPFWYijV1T&quot;,
      &quot;publicKey&quot;: &quot;GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo&quot;,
      &quot;services&quot;: [
        {
          &quot;id&quot;: &quot;peering&quot;,
          &quot;address&quot;: &quot;35.214.101.88:14626&quot;
        },
        {
          &quot;id&quot;: &quot;gossip&quot;,
          &quot;address&quot;: &quot;35.214.101.88:14666&quot;
        },
        {
          &quot;id&quot;: &quot;FPC&quot;,
          &quot;address&quot;: &quot;35.214.101.88:10895&quot;
        }
      ]
    }
  ]
}
</code></pre>
<h4 id="results-2"><a class="header" href="#results-2">Results</a></h4>
<ul>
<li>Returned type</li>
</ul>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>known</code></td><td align="left"><code>[]Neighbor</code></td><td align="left">List of known peers. Only returned when parameter is set.</td></tr>
<tr><td align="left"><code>chosen</code></td><td align="left"><code>[]Neighbor</code></td><td align="left">List of chosen peers.</td></tr>
<tr><td align="left"><code>accepted</code></td><td align="left"><code>[]Neighbor</code></td><td align="left">List of accepted peers.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<ul>
<li>Type <code>Neighbor</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Comparable node identifier.</td></tr>
<tr><td align="left"><code>publicKey</code></td><td align="left"><code>string</code></td><td align="left">Public key used to verify signatures.</td></tr>
<tr><td align="left"><code>services</code></td><td align="left"><code>[]PeerService</code></td><td align="left">List of exposed services.</td></tr>
</tbody></table>
<ul>
<li>Type <code>PeerService</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Type of service.</td></tr>
<tr><td align="left"><code>address</code></td><td align="left"><code>string</code></td><td align="left">Network address of the service.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-peering-api-methods"><a class="header" href="#manual-peering-api-methods">Manual Peering API methods</a></h1>
<p>The manual peering APIs allow managing the list of known peers of the node.</p>
<p>HTTP APIs:</p>
<ul>
<li>POST <a href="apis/manual_peering.html#post-manualpeeringpeers">/manualpeering/peers</a></li>
<li>GET <a href="apis/manual_peering.html#get-manualpeeringpeers">/manualpeering/peers</a></li>
<li>DELETE <a href="apis/manual_peering.html#delete-manualpeeringpeers">/manualpeering/peers</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/manual_peering.html#addmanualpeers">AddManualPeers()</a></li>
<li><a href="apis/manual_peering.html#getmanualpeers">GetManualPeers()</a></li>
<li><a href="apis/manual_peering.html#removemanualpeers">RemoveManualPeers()</a></li>
</ul>
<br />
<h2 id="post-manualpeeringpeers"><a class="header" href="#post-manualpeeringpeers">POST <code>/manualpeering/peers</code></a></h2>
<p>Add peers to the list of known peers of the node.</p>
<h3 id="request-body"><a class="header" href="#request-body">Request Body</a></h3>
<pre><code class="language-json">[
  {
    &quot;publicKey&quot;: &quot;CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3&quot;,
    &quot;address&quot;: &quot;127.0.0.1:14666&quot;
  }
]
</code></pre>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>publicKey</code></td><td align="left">Public key of the peer.</td></tr>
<tr><td align="left"><code>address</code></td><td align="left">IP address of the peer's node and its gossip port.</td></tr>
</tbody></table>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>HTTP status code: 204 No Content</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<h4 id="curl-3"><a class="header" href="#curl-3">cURL</a></h4>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:8080/manualpeering/peers' \
--header 'Content-Type: application/json' \
--data-raw '[
    {
        &quot;publicKey&quot;: &quot;CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3&quot;,
        &quot;address&quot;: &quot;172.19.0.3:14666&quot;
    }
]'
</code></pre>
<h3 id="client-library"><a class="header" href="#client-library">Client library</a></h3>
<h4 id="addmanualpeers"><a class="header" href="#addmanualpeers"><code>AddManualPeers</code></a></h4>
<pre><code class="language-go">import &quot;github.com/iotaledger/goshimmer/packages/manualpeering&quot;

peersToAdd := []*manualpeering.KnownPeerToAdd{{PublicKey: publicKey, Address: address}}
err := goshimAPI.AddManualPeers(peersToAdd)
if err != nil {
// return error
}
</code></pre>
<br />
<h2 id="get-manualpeeringpeers"><a class="header" href="#get-manualpeeringpeers">GET <code>/manualpeering/peers</code></a></h2>
<p>Get the list of all known peers of the node.</p>
<h3 id="request-body-1"><a class="header" href="#request-body-1">Request Body</a></h3>
<pre><code class="language-json">{
  &quot;onlyConnected&quot;: true
}
</code></pre>
<h4 id="description-1"><a class="header" href="#description-1">Description</a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>onlyConnected</code></td><td align="left">Optional, if set to true only peers with established connection will be returned.</td></tr>
</tbody></table>
<h3 id="response-1"><a class="header" href="#response-1">Response</a></h3>
<p>HTTP status code: 200 OK</p>
<pre><code class="language-json">[
  {
    &quot;publicKey&quot;: &quot;CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3&quot;,
    &quot;address&quot;: &quot;127.0.0.1:14666&quot;,
    &quot;connectionDirection&quot;: &quot;inbound&quot;,
    &quot;connectionStatus&quot;: &quot;connected&quot;
  }
]
</code></pre>
<h4 id="description-2"><a class="header" href="#description-2">Description</a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>publicKey</code></td><td align="left">The public key of the peer node.</td></tr>
<tr><td align="left"><code>address</code></td><td align="left">IP address of the peer's node and its gossip port.</td></tr>
<tr><td align="left"><code>connectionDirection</code></td><td align="left">Enum, possible values: &quot;inbound&quot;, &quot;outbound&quot;. Inbound means that the local node accepts the connection. On the other side, the other peer node dials, and it will have &quot;outbound&quot; connectionDirection.</td></tr>
<tr><td align="left"><code>connectionStatus</code></td><td align="left">Enum, possible values: &quot;disconnected&quot;, &quot;connected&quot;. Whether the actual TCP connection has been established between peers.</td></tr>
</tbody></table>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<h4 id="curl-4"><a class="header" href="#curl-4">cURL</a></h4>
<pre><code class="language-shell">curl --location --request GET 'http://localhost:8080/manualpeering/peers' \
--header 'Content-Type: application/json' \
--data-raw '{
    &quot;onlyConnected&quot;: true
}'
</code></pre>
<h3 id="client-library-1"><a class="header" href="#client-library-1">Client library</a></h3>
<h4 id="getmanualpeers"><a class="header" href="#getmanualpeers"><code>GetManualPeers</code></a></h4>
<pre><code class="language-go">import &quot;github.com/iotaledger/goshimmer/packages/manualpeering&quot;

peers, err := goshimAPI.GetManualPeers(manualpeering.WithOnlyConnectedPeers())
if err != nil {
// return error
}
fmt.Println(peers)
</code></pre>
<br />
<h2 id="delete-manualpeeringpeers"><a class="header" href="#delete-manualpeeringpeers">DELETE <code>/manualpeering/peers</code></a></h2>
<p>Remove peers from the list of known peers of the node.</p>
<h3 id="request-body-2"><a class="header" href="#request-body-2">Request Body</a></h3>
<pre><code class="language-json">[
  {
    &quot;publicKey&quot;: &quot;CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3&quot;
  }
]
</code></pre>
<h4 id="description-3"><a class="header" href="#description-3">Description</a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>publicKey</code></td><td align="left">Public key of the peer to remove from the list.</td></tr>
</tbody></table>
<h3 id="response-2"><a class="header" href="#response-2">Response</a></h3>
<p>HTTP status code: 204 No Content</p>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<h4 id="curl-5"><a class="header" href="#curl-5">cURL</a></h4>
<pre><code class="language-shell">curl --location --request DELETE 'http://localhost:8080/manualpeering/peers' \
--header 'Content-Type: application/json' \
--data-raw '[
    {
        &quot;publicKey&quot;: &quot;8qN1yD95fhbfDZtKX49RYFEXqej5fvsXJ2NPmF1LCqbd&quot;
    }
]'
</code></pre>
<h3 id="client-library-2"><a class="header" href="#client-library-2">Client library</a></h3>
<h4 id="removemanualpeers"><a class="header" href="#removemanualpeers"><code>RemoveManualPeers</code></a></h4>
<pre><code class="language-go">import &quot;github.com/iotaledger/hive.go/crypto/ed25519&quot;
import &quot;github.com/iotaledger/goshimmer/packages/manualpeering&quot;

publicKeysToRemove := []ed25519.PublicKey{publicKey1, publicKey2}
err := goshimAPI.RemoveManualPeers(publicKeysToRemove)
if err != nil {
// return error
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication-layer-apis"><a class="header" href="#communication-layer-apis">Communication Layer APIs</a></h1>
<p>The communication layer represents the base Tangle layer where so called <code>Messages</code> are gossiped around. A <code>Message</code> contains payloads and it is up to upper layers to interpret and derive functionality out of them.</p>
<p>The API provides the following functions to interact with this primitive layer:</p>
<ul>
<li><a href="apis/communication.html#messagesmessageid">/messages/:messageID</a></li>
<li><a href="apis/communication.html#messagesmessageidmetadata">/messages/:messageID/metadata</a></li>
<li><a href="apis/communication.html#messagesmessageidconsensus">/messages/:messageID/consensus</a></li>
<li><a href="apis/communication.html#data">/data</a></li>
<li><a href="apis/communication.html#messagespayload">/messages/payload</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/communication.html#client-lib---getmessage">GetMessage()</a></li>
<li><a href="apis/communication.html#client-lib---getmessagemetadata">GetMessageMetadata()</a></li>
<li><a href="apis/communication.html#client-lib---data">Data()</a></li>
<li><a href="apis/communication.html#client-lib---sendpayload">SendPayload()</a></li>
</ul>
</br>
<h2 id="messagesmessageid"><a class="header" href="#messagesmessageid"><code>/messages/:messageID</code></a></h2>
<p>Return message from the tangle.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>messageID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>ID of a message to retrieve</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<h4 id="curl-6"><a class="header" href="#curl-6">cURL</a></h4>
<pre><code class="language-shell">curl --location --request GET 'http://localhost:8080/messages/:messageID'
</code></pre>
<p>where <code>:messageID</code> is the base58 encoded message ID, e.g. 4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc.</p>
<h4 id="client-lib---getmessage"><a class="header" href="#client-lib---getmessage">Client lib - <code>GetMessage</code></a></h4>
<p>Messages can be retrieved via <code>GetMessage(base58EncodedID string) (*jsonmodels.Message, error) </code></p>
<pre><code class="language-go">message, err := goshimAPI.GetMessage(base58EncodedMessageID)
if err != nil {
    // return error
}

// will print &quot;Hello GoShimmer World&quot;
fmt.Println(string(message.Payload))
</code></pre>
<p>Note that we're getting actual <code>Message</code> objects from this call which represent a vertex in the communication layer Tangle. It does not matter what type of payload the message contains, meaning that this will also return messages which contain a transactions or DRNG payloads.</p>
<h4 id="response-examples-1"><a class="header" href="#response-examples-1">Response examples</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc&quot;,
    &quot;strongParents&quot;: [
        &quot;6LrXyDCorw8bTWKFaEmm3CZG6Nb6Ga8Bmosi1GPypGc1&quot;,
        &quot;B89koPthm9zDx1p1fbkHwoyC1Buq896Spu3Mx1SmSete&quot;
    ],
    &quot;weakParents&quot;: [],
    &quot;strongApprovers&quot;: [
        &quot;4E4ucAA9UTTd1UC6ri4GYaS4dpzEnHPjs5gMEYhpUK8p&quot;,
        &quot;669BRH69afQ7VfZGmNTMTeh2wnwXGKdBxtUCcRQ9CPzq&quot;
    ],
    &quot;weakApprovers&quot;: [],
    &quot;issuerPublicKey&quot;: &quot;9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd&quot;,
    &quot;issuingTime&quot;: 1621873309,
    &quot;sequenceNumber&quot;: 4354,
    &quot;payloadType&quot;: &quot;GenericDataPayloadType(0)&quot;,
    &quot;payload&quot;: &quot;BAAAAAAAAAA=&quot;,
    &quot;signature&quot;: &quot;2J5XuVnmaHo54WipirWo7drJeXG3iRsnLYfzaPPuy6TXKiVBqv6ZYg2NjYP75xvgvut1SKNm8oYTchGi5t2SjyWJ&quot;
}
</code></pre>
<h4 id="results-3"><a class="header" href="#results-3">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID.</td></tr>
<tr><td align="left"><code>strongParents</code></td><td align="left"><code>[]string</code></td><td align="left">List of strong parents' message IDs.</td></tr>
<tr><td align="left"><code>weakParents</code></td><td align="left"><code>[]string</code></td><td align="left">List of weak parents' message IDs.</td></tr>
<tr><td align="left"><code>strongApprovers</code></td><td align="left"><code>[]string</code></td><td align="left">List of strong approvers' message IDs.</td></tr>
<tr><td align="left"><code>weakApprovers</code></td><td align="left"><code>[]string</code></td><td align="left">List of weak approvers' message IDs.</td></tr>
<tr><td align="left"><code>issuerPublicKey</code></td><td align="left"><code>[]string</code></td><td align="left">Public key of issuing node.</td></tr>
<tr><td align="left"><code>issuingTime</code></td><td align="left"><code>int64</code></td><td align="left">Time this message was issued</td></tr>
<tr><td align="left"><code>sequenceNumber</code></td><td align="left"><code>uint64</code></td><td align="left">Message sequence number.</td></tr>
<tr><td align="left"><code>payloadType</code></td><td align="left"><code>string</code></td><td align="left">Payload type.</td></tr>
<tr><td align="left"><code>payload</code></td><td align="left"><code>[]byte</code></td><td align="left">The contents of the message.</td></tr>
<tr><td align="left"><code>signature</code></td><td align="left"><code>string</code></td><td align="left">Message signature.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="messagesmessageidmetadata"><a class="header" href="#messagesmessageidmetadata"><code>/messages/:messageID/metadata</code></a></h2>
<p>Return message metadata.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>messageID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>ID of a message to retrieve</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<h4 id="curl-7"><a class="header" href="#curl-7">cURL</a></h4>
<pre><code class="language-shell">curl --location --request GET 'http://localhost:8080/messages/:messageID/metadata'
</code></pre>
<p>where <code>:messageID</code> is the base58 encoded message ID, e.g. 4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc.</p>
<h4 id="client-lib---getmessagemetadata"><a class="header" href="#client-lib---getmessagemetadata">Client lib - <code>GetMessageMetadata</code></a></h4>
<p>Message metadata can be retrieved via <code>GetMessageMetadata(base58EncodedID string) (*jsonmodels.MessageMetadata, error)</code></p>
<pre><code class="language-go">message, err := goshimAPI.GetMessageMetadata(base58EncodedMessageID)
if err != nil {
    // return error
}

// will print whether message is finalized
fmt.Println(string(message.Finalized))
</code></pre>
<h4 id="response-examples-2"><a class="header" href="#response-examples-2">Response examples</a></h4>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc&quot;,
    &quot;receivedTime&quot;: 1621873309,
    &quot;solid&quot;: true,
    &quot;solidificationTime&quot;: 1621873309,
    &quot;structureDetails&quot;: {
        &quot;rank&quot;: 23323,
        &quot;pastMarkerGap&quot;: 0,
        &quot;isPastMarker&quot;: true,
        &quot;pastMarkers&quot;: {
            &quot;markers&quot;: {
                &quot;1&quot;: 21904
            },
            &quot;highestIndex&quot;: 21904,
            &quot;lowestIndex&quot;: 21904
        },
        &quot;futureMarkers&quot;: {
            &quot;markers&quot;: {
                &quot;1&quot;: 21905
            },
            &quot;highestIndex&quot;: 21905,
            &quot;lowestIndex&quot;: 21905
        }
    },
    &quot;branchID&quot;: &quot;BranchID(MasterBranchID)&quot;,
    &quot;scheduled&quot;: false,
    &quot;booked&quot;: true,
    &quot;eligible&quot;: true,
    &quot;invalid&quot;: false,
    &quot;finalized&quot;: true,
    &quot;finalizedTime&quot;: 1621873310
}
</code></pre>
<h4 id="results-4"><a class="header" href="#results-4">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID.</td></tr>
<tr><td align="left"><code>receivedTime</code></td><td align="left"><code>int64</code></td><td align="left">Time when message was received by the node.</td></tr>
<tr><td align="left"><code>solid</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is solid.</td></tr>
<tr><td align="left"><code>solidificationTime</code></td><td align="left"><code>int64</code></td><td align="left">Time when message was solidified by the node.</td></tr>
<tr><td align="left"><code>structureDetails</code></td><td align="left"><code>StructureDetails</code></td><td align="left">List of weak approvers' message IDs.</td></tr>
<tr><td align="left"><code>branchID</code></td><td align="left"><code>string</code></td><td align="left">Name of branch that the message is part of.</td></tr>
<tr><td align="left"><code>scheduled</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is scheduled.</td></tr>
<tr><td align="left"><code>booked</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is booked.</td></tr>
<tr><td align="left"><code>eligible</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is eligible.</td></tr>
<tr><td align="left"><code>invalid</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is invalid.</td></tr>
<tr><td align="left"><code>finalized</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the message is finalized.</td></tr>
<tr><td align="left"><code>finalizedTime</code></td><td align="left"><code>string</code></td><td align="left">Time when message was finalized.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="messagesmessageidconsensus"><a class="header" href="#messagesmessageidconsensus"><code>/messages/:messageID/consensus</code></a></h2>
<p>Return message consensus info such as opinion and FCoB data.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>messageID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>ID of a message to retrieve</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<h4 id="curl-8"><a class="header" href="#curl-8">cURL</a></h4>
<pre><code class="language-shell">curl --location --request GET 'http://localhost:8080/messages/:messageID/consensus'
</code></pre>
<p>where <code>:messageID</code> is the base58 encoded message ID, e.g. 4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc.</p>
<h4 id="client-lib-1"><a class="header" href="#client-lib-1">Client lib</a></h4>
<p>This method is not available in the client library.</p>
<h4 id="response-examples-3"><a class="header" href="#response-examples-3">Response examples</a></h4>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;MessageID(4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc)&quot;,
  &quot;opinionFormedTime&quot;: 1621873309,
  &quot;payloadOpinionFormed&quot;: true,
  &quot;timestampOpinionFormed&quot;: true,
  &quot;messageOpinionFormed&quot;: true,
  &quot;messageOpinionTriggered&quot;: true,
  &quot;timestampOpinion&quot;: &quot;Like&quot;,
  &quot;timestampLoK&quot;: &quot;LevelOfKnowledge(Two)&quot;
}
</code></pre>
<h4 id="results-5"><a class="header" href="#results-5">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID.</td></tr>
<tr><td align="left"><code>opinionFormedTime</code></td><td align="left"><code>int64</code></td><td align="left">Time when the node formed full opinion.</td></tr>
<tr><td align="left"><code>payloadOpinionFormed</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the node formed opinion about the payload.</td></tr>
<tr><td align="left"><code>timestampOpinionFormed</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the node formed opinion about the timestamp.</td></tr>
<tr><td align="left"><code>messageOpinionFormed</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the node formed opinion about the message.</td></tr>
<tr><td align="left"><code>messageOpinionTriggered</code></td><td align="left"><code>bool</code></td><td align="left">Flag indicating whether the node triggered an opinion formed event for the message.</td></tr>
<tr><td align="left"><code>timestampOpinion</code></td><td align="left"><code>string</code></td><td align="left">Opinion about the message's timestamp.</td></tr>
<tr><td align="left"><code>timestampLoK</code></td><td align="left"><code>bool</code></td><td align="left">Level of knowledge about message's timestamp.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="data"><a class="header" href="#data"><code>/data</code></a></h2>
<p>Method: <code>POST</code></p>
<p>A data message is simply a <code>Message</code> containing some raw data (literally bytes). This type of message has therefore no real functionality other than that it is retrievable via <code>GetMessage</code>.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>data</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>data bytes</td></tr>
<tr><td><strong>Type</strong></td><td>base64 serialized bytes</td></tr>
</tbody></table>
<h4 id="body"><a class="header" href="#body">Body</a></h4>
<pre><code class="language-json">{
  &quot;data&quot;: &quot;dataBytes&quot;
}
</code></pre>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<h4 id="curl-9"><a class="header" href="#curl-9">cURL</a></h4>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:8080/data' \
--header 'Content-Type: application/json' \
--data-raw '{&quot;data&quot;: &quot;dataBytes&quot;}'
</code></pre>
<h4 id="client-lib---data"><a class="header" href="#client-lib---data">Client lib - <code>Data</code></a></h4>
<h5 id="datadata-byte-string-error"><a class="header" href="#datadata-byte-string-error"><code>Data(data []byte) (string, error)</code></a></h5>
<pre><code class="language-go">messageID, err := goshimAPI.Data([]byte(&quot;Hello GoShimmer World&quot;))
if err != nil {
    // return error
}
</code></pre>
<p>Note that there is no need to do any additional work, since things like tip-selection, PoW and other tasks are done by the node itself.</p>
<h3 id="response-examples-4"><a class="header" href="#response-examples-4">Response examples</a></h3>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;messageID&quot; 
}
</code></pre>
<h3 id="results-6"><a class="header" href="#results-6">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID of the message. Omitted if error.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="messagespayload"><a class="header" href="#messagespayload"><code>/messages/payload</code></a></h2>
<p>Method: <code>POST</code></p>
<p><code>SendPayload()</code> takes a <code>payload</code> object of any type (data, transaction, drng, etc.) as a byte slice, issues a message with the given payload and returns its <code>messageID</code>. Note that the payload must be valid, otherwise an error is returned.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>payload</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>payload bytes</td></tr>
<tr><td><strong>Type</strong></td><td>base64 serialized bytes</td></tr>
</tbody></table>
<h4 id="body-1"><a class="header" href="#body-1">Body</a></h4>
<pre><code class="language-json">{
  &quot;payload&quot;: &quot;payloadBytes&quot;
}
</code></pre>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<h4 id="curl-10"><a class="header" href="#curl-10">cURL</a></h4>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:8080/messages/payload' \
--header 'Content-Type: application/json' \
--data-raw '{&quot;payload&quot;: &quot;payloadBytes&quot;}'
</code></pre>
<h4 id="client-lib---sendpayload"><a class="header" href="#client-lib---sendpayload">Client lib - <code>SendPayload</code></a></h4>
<h5 id="sendpayloadpayload-byte-string-error"><a class="header" href="#sendpayloadpayload-byte-string-error"><code>SendPayload(payload []byte) (string, error)</code></a></h5>
<pre><code class="language-go">helloPayload := payload.NewData([]byte{&quot;Hello GoShimmer World!&quot;})
messageID, err := goshimAPI.SendPayload(helloPayload.Bytes())
</code></pre>
<h3 id="response-examples-5"><a class="header" href="#response-examples-5">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;id&quot;: &quot;messageID&quot; 
}
</code></pre>
<h3 id="results-7"><a class="header" href="#results-7">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID of the message. Omitted if error.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<p>Note that there is no need to do any additional work, since things like tip-selection, PoW and other tasks are done by the node itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ledgerstate-api-methods"><a class="header" href="#ledgerstate-api-methods">Ledgerstate API Methods</a></h1>
<h2 id="http-apis"><a class="header" href="#http-apis">HTTP APIs:</a></h2>
<ul>
<li><a href="apis/ledgerstate.html#ledgerstateaddressesaddress">/ledgerstate/addresses/:address</a></li>
<li><a href="apis/ledgerstate.html#ledgerstateaddressesaddressunspentoutputs">/ledgerstate/addresses/:address/unspentOutputs</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatebranchesbranchid">/ledgerstate/branches/:branchID</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatebranchesbranchidchildren">/ledgerstate/branches/:branchID/children</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatebranchesbranchidconflicts">/ledgerstate/branches/:branchID/conflicts</a></li>
<li><a href="apis/ledgerstate.html#ledgerstateoutputsoutputid">/ledgerstate/outputs/:outputID</a></li>
<li><a href="apis/ledgerstate.html#ledgerstateoutputsoutputidconsumers">/ledgerstate/outputs/:outputID/consumers</a></li>
<li><a href="apis/ledgerstate.html#ledgerstateoutputsoutputidmetadata">/ledgerstate/outputs/:outputID/metadata</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactionstransactionid">/ledgerstate/transactions/:transactionID</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactionstransactionidmetadata">/ledgerstate/transactions/:transactionID/metadata</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactionstransactionidinclusionstate">/ledgerstate/transactions/:transactionID/inclusionState</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactionstransactionidconsensus">/ledgerstate/transactions/:transactionID/consensus</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactionstransactionidattachments">/ledgerstate/transactions/:transactionID/attachments</a></li>
<li><a href="apis/ledgerstate.html#ledgerstatetransactions">/ledgerstate/transactions</a></li>
<li><a href="apis/ledgerstate.html#ledgerstateaddressesunspentoutputs">/ledgerstate/addresses/unspentOutputs</a></li>
</ul>
<h2 id="client-lib-apis"><a class="header" href="#client-lib-apis">Client lib APIs:</a></h2>
<ul>
<li><a href="apis/ledgerstate.html#client-lib---getaddressoutputs">GetAddressOutputs()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getaddressunspentoutputs">GetAddressUnspentOutputs()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getbranch">GetBranch()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getbranchchildren">GetBranchChildren()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getbranchconflicts">GetBranchConflicts()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getoutput">GetOutput()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getoutputconsumers">GetOutputConsumers()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---getoutputmetadata">GetOutputMetadata()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---gettransaction">GetTransaction()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---gettransactionmetadata">GetTransactionMetadata()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---gettransactioninclusionstate">GetTransactionInclusionState()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---gettransactionconsensusmetadata">GetTransactionConsensusMetadata()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---gettransactionattachments">GetTransactionAttachments()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---posttransaction">PostTransaction()</a></li>
<li><a href="apis/ledgerstate.html#client-lib---postaddressunspentoutputs">PostAddressUnspentOutputs()</a></li>
</ul>
<h2 id="ledgerstateaddressesaddress"><a class="header" href="#ledgerstateaddressesaddress"><code>/ledgerstate/addresses/:address</code></a></h2>
<p>Get address details for a given base58 encoded address ID, such as output types and balances. For the client library API call balances will not be directly available as values because they are stored as a raw message. Balance can be read after retrieving <code>ledgerstate.Output</code> instance, as presented in the examples.</p>
<h3 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>address</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The address encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-11"><a class="header" href="#examples-11">Examples</a></h3>
<h4 id="curl-11"><a class="header" href="#curl-11">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/addresses/:address \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:address</code> is the base58 encoded address, e.g. 6PQqFcwarCVbEMxWFeAqj7YswK842dMtf84qGyKqVH7s1kK.</p>
<h4 id="client-lib---getaddressoutputs"><a class="header" href="#client-lib---getaddressoutputs">Client lib - <code>GetAddressOutputs()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetAddressOutputs(&quot;6PQqFcwarCVbEMxWFeAqj7YswK842dMtf84qGyKqVH7s1kK&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;output address: &quot;, resp.Address)

for _, output := range resp.Outputs {
    fmt.Println(&quot;outputID: &quot;, output.OutputID)
    fmt.Println(&quot;output type: &quot;, output.Type)
    // get output instance
    out, err = output.ToLedgerstateOutput()
}
</code></pre>
<h3 id="response-examples-6"><a class="header" href="#response-examples-6">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;address&quot;: {
        &quot;type&quot;: &quot;AddressTypeED25519&quot;,
        &quot;base58&quot;: &quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;
    },
    &quot;outputs&quot;: [
        {
            &quot;outputID&quot;: {
                &quot;base58&quot;: &quot;gdFXAjwsm5kDeGdcZsJAShJLeunZmaKEMmfHSdoX34ZeSs&quot;,
                &quot;transactionID&quot;: &quot;32yHjeZpghKNkybd2iHjXj7NsUdR63StbJcBioPGAut3&quot;,
                &quot;outputIndex&quot;: 0
            },
            &quot;type&quot;: &quot;SigLockedColoredOutputType&quot;,
            &quot;output&quot;: {
                &quot;balances&quot;: {
                    &quot;11111111111111111111111111111111&quot;: 1000000
                },
                &quot;address&quot;: &quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;
            }
        }
    ]
}
</code></pre>
<h3 id="results-8"><a class="header" href="#results-8">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>address</code></td><td align="left">Address</td><td align="left">The address corresponding to provided outputID.</td></tr>
<tr><td align="left"><code>outputs</code></td><td align="left">Output</td><td align="left">List of transactions' outputs.</td></tr>
</tbody></table>
<h4 id="type-address"><a class="header" href="#type-address">Type <code>Address</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The type of an address.</td></tr>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The address encoded with base58.</td></tr>
</tbody></table>
<h4 id="type-output"><a class="header" href="#type-output">Type <code>Output</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The identifier of an output.</td></tr>
<tr><td align="left"><code>outputType</code></td><td align="left">string</td><td align="left">The type of the output.</td></tr>
<tr><td align="left"><code>output</code></td><td align="left">string</td><td align="left">An output raw message containing balances and corresponding addresses.</td></tr>
</tbody></table>
<h4 id="type-outputid"><a class="header" href="#type-outputid">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstateaddressesaddressunspentoutputs"><a class="header" href="#ledgerstateaddressesaddressunspentoutputs"><code>/ledgerstate/addresses/:address/unspentOutputs</code></a></h2>
<p>Gets list of all unspent outputs for the address based on a given base58 encoded address ID.</p>
<h3 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>address</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The address encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-12"><a class="header" href="#examples-12">Examples</a></h3>
<h4 id="curl-12"><a class="header" href="#curl-12">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/addresses/:address/unspentOutputs \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:address</code> is the base58 encoded address, e.g. 6PQqFcwarCVbEMxWFeAqj7YswK842dMtf84qGyKqVH7s1kK.</p>
<h4 id="client-lib---getaddressunspentoutputs"><a class="header" href="#client-lib---getaddressunspentoutputs">Client lib - <code>GetAddressUnspentOutputs()</code></a></h4>
<pre><code class="language-Go">address := &quot;6PQqFcwarCVbEMxWFeAqj7YswK842dMtf84qGyKqVH7s1kK&quot;
resp, err := goshimAPI.GetAddressUnspentOutputs(address)
if err != nil {
    // return error
}
fmt.Println(&quot;output address: &quot;, resp.Address)

for _, output := range resp.Outputs {
    fmt.Println(&quot;outputID: &quot;, output.OutputID)
    fmt.Println(&quot;output type: &quot;, output.Type)
    // get output instance
    out, err = output.ToLedgerstateOutput()
}
</code></pre>
<h3 id="response-examples-7"><a class="header" href="#response-examples-7">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;address&quot;: {
        &quot;type&quot;: &quot;AddressTypeED25519&quot;,
        &quot;base58&quot;: &quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;
    },
    &quot;outputs&quot;: [
        {
            &quot;outputID&quot;: {
                &quot;base58&quot;: &quot;gdFXAjwsm5kDeGdcZsJAShJLeunZmaKEMmfHSdoX34ZeSs&quot;,
                &quot;transactionID&quot;: &quot;32yHjeZpghKNkybd2iHjXj7NsUdR63StbJcBioPGAut3&quot;,
                &quot;outputIndex&quot;: 0
            },
            &quot;type&quot;: &quot;SigLockedColoredOutputType&quot;,
            &quot;output&quot;: {
                &quot;balances&quot;: {
                    &quot;11111111111111111111111111111111&quot;: 1000000
                },
                &quot;address&quot;: &quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;
            }
        }
    ]
}
</code></pre>
<h3 id="results-9"><a class="header" href="#results-9">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>address</code></td><td align="left">Address</td><td align="left">The address corresponding to provided unspent outputID.</td></tr>
<tr><td align="left"><code>outputs</code></td><td align="left">Output</td><td align="left">List of transactions' unspent outputs.</td></tr>
</tbody></table>
<h4 id="type-address-1"><a class="header" href="#type-address-1">Type <code>Address</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The type of an address.</td></tr>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The address encoded with base58.</td></tr>
</tbody></table>
<h4 id="type-output-1"><a class="header" href="#type-output-1">Type <code>Output</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The identifier of an output.</td></tr>
<tr><td align="left"><code>outputType</code></td><td align="left">string</td><td align="left">The type of the output.</td></tr>
<tr><td align="left"><code>output</code></td><td align="left">string</td><td align="left">An output raw message containing balances and corresponding addresses</td></tr>
</tbody></table>
<h4 id="type-outputid-1"><a class="header" href="#type-outputid-1">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatebranchesbranchid"><a class="header" href="#ledgerstatebranchesbranchid"><code>/ledgerstate/branches/:branchID</code></a></h2>
<p>Gets a branch details for a given base58 encoded branch ID.</p>
<h3 id="parameters-11"><a class="header" href="#parameters-11">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>branchID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The branch ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-13"><a class="header" href="#examples-13">Examples</a></h3>
<h4 id="curl-13"><a class="header" href="#curl-13">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/branches/:branchID \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:branchID</code> is the ID of the branch, e.g. 2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ.</p>
<h4 id="client-lib---getbranch"><a class="header" href="#client-lib---getbranch">Client lib - <code>GetBranch()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetBranch(&quot;2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;branch ID: &quot;, resp.ID)
fmt.Println(&quot;branch type: &quot;, resp.Type)
fmt.Println(&quot;branch inclusion state: &quot;, resp.InclusionState)
fmt.Println(&quot;branch parents IDs: &quot;, resp.Parents)
fmt.Println(&quot;branch conflicts IDs: &quot;, resp.ConflictIDs)
fmt.Printf(&quot;liked: %v, finalized: %v, monotonically liked: %v&quot;, resp.Liked, resp.Finalized, resp.MonotonicallyLiked)
</code></pre>
<h3 id="response-examples-8"><a class="header" href="#response-examples-8">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;id&quot;: &quot;5v6iyxKUSSF73yoZa6YngNN5tqoX8hJQWKGXrgcz3XTg&quot;,
    &quot;type&quot;: &quot;ConflictBranchType&quot;,
    &quot;parents&quot;: [
        &quot;4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM&quot;
    ],
    &quot;conflictIDs&quot;: [
        &quot;3LrHecDf8kvDGZKTAYaKmvdsqXA18YBc8A9UePu7pCxw5ks&quot;
    ],
    &quot;liked&quot;: false,
    &quot;monotonicallyLiked&quot;: false,
    &quot;finalized&quot;: false,
    &quot;inclusionState&quot;: &quot;InclusionState(Pending)&quot;
}
</code></pre>
<h3 id="results-10"><a class="header" href="#results-10">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left">string</td><td align="left">The branch identifier encoded with base58.</td></tr>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The type of the branch.</td></tr>
<tr><td align="left"><code>parents</code></td><td align="left">[]string</td><td align="left">The list of parent branches IDs.</td></tr>
<tr><td align="left"><code>conflictIDs</code></td><td align="left">[]string</td><td align="left">The list of conflicts identifiers.</td></tr>
<tr><td align="left"><code>liked</code></td><td align="left">bool</td><td align="left">The boolean indicator if branch is liked.</td></tr>
<tr><td align="left"><code>monotonicallyLiked</code></td><td align="left">bool</td><td align="left">The boolean indicator if branch is monotonically liked.</td></tr>
<tr><td align="left"><code>finalized</code></td><td align="left">bool</td><td align="left">The boolean indicator if branch is finalized.</td></tr>
<tr><td align="left"><code>inclusionState</code></td><td align="left">string</td><td align="left">Inclusion state of a branch.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatebranchesbranchidchildren"><a class="header" href="#ledgerstatebranchesbranchidchildren"><code>/ledgerstate/branches/:branchID/children</code></a></h2>
<p>Gets a list of all child branches for a branch with given base58 encoded branch ID.</p>
<h3 id="parameters-12"><a class="header" href="#parameters-12">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>branchID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The branch ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-14"><a class="header" href="#examples-14">Examples</a></h3>
<h4 id="curl-14"><a class="header" href="#curl-14">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/branches/:branchID/children \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:branchID</code> is the ID of the branch, e.g. 2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ.</p>
<h4 id="client-lib---getbranchchildren"><a class="header" href="#client-lib---getbranchchildren">Client lib - <code>GetBranchChildren()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetBranchChildren(&quot;2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ&quot;)
if err != nil {
    //return error
}
fmt.Printf(&quot;All children branches for branch %s:\n&quot;, resp.BranchID)
for _, branch := range resp.ChildBranches {
    fmt.Println(&quot;branchID: &quot;, branch.BranchID)
    fmt.Printf(&quot;type: %s\n&quot;, branch.BranchID)
}
</code></pre>
<h3 id="response-examples-9"><a class="header" href="#response-examples-9">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;branchID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;childBranches&quot;: [
        {
            &quot;branchID&quot;: &quot;4SdXm5NXEcVogiJNEKkecqd5rZzRYeGYBj8oBNsdX91W&quot;,
            &quot;type&quot;: &quot;AggregatedBranchType&quot;
        }
    ]
}
</code></pre>
<h3 id="results-11"><a class="header" href="#results-11">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>branchID</code></td><td align="left">string</td><td align="left">The branch identifier encoded with base58.</td></tr>
<tr><td align="left"><code>childBranches</code></td><td align="left">[]ChildBranch</td><td align="left">The child branches data.</td></tr>
</tbody></table>
<h4 id="type-childbranch"><a class="header" href="#type-childbranch">Type <code>ChildBranch</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>branchID</code></td><td align="left">string</td><td align="left">The branch identifier encoded with base58.</td></tr>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The type of the branch.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatebranchesbranchidconflicts"><a class="header" href="#ledgerstatebranchesbranchidconflicts"><code>/ledgerstate/branches/:branchID/conflicts</code></a></h2>
<p>Get all conflicts for a given branch ID, their outputs and conflicting branches.</p>
<h3 id="parameters-13"><a class="header" href="#parameters-13">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>branchID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The conflicting branch ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-15"><a class="header" href="#examples-15">Examples</a></h3>
<h4 id="curl-15"><a class="header" href="#curl-15">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/branches/:branchID/conflicts \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:branchID</code> is the ID of the branch, e.g. 2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ.</p>
<h4 id="client-lib---getbranchconflicts"><a class="header" href="#client-lib---getbranchconflicts">Client lib - <code>GetBranchConflicts()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetBranchConflicts(&quot;2e2EU6fhxRhrXVnYQ6US4zmUkE5YJip25ecafn8gZeoZ&quot;)
if err != nil {
    // return error
}
fmt.Printf(&quot;All conflicts for branch %s:\n&quot;, resp.BranchID)
// iterate over all conflicts
for _, branch := range resp.Conflicts {
    fmt.Println(&quot;output ID: &quot;, branch.OutputID.Base58)
    fmt.Println(&quot;conflicting transaction ID: &quot;, branch.OutputID.TransactionID)
    fmt.Printf(&quot;related branches: %v\n&quot;, branch.BranchIDs)
}
</code></pre>
<h3 id="response-examples-10"><a class="header" href="#response-examples-10">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;branchID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;conflicts&quot;: [
        {
            &quot;outputID&quot;: {
                &quot;base58&quot;: &quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;,
                &quot;transactionID&quot;: &quot;9wr21zza46Y5QonKEHNQ6x8puA7Rbq5LAbsQZJCK1g1g&quot;,
                &quot;outputIndex&quot;: 0
            },
            &quot;branchIDs&quot;: [
                &quot;b8QRhHerfg14cYQ4VFD7Fyh1HYTCbjt9aK1XJmdoXwq&quot;,
                &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;
            ]
        }
    ]
}
</code></pre>
<h3 id="results-12"><a class="header" href="#results-12">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>branchID</code></td><td align="left">string</td><td align="left">The branch identifier encoded with base58.</td></tr>
<tr><td align="left"><code>conflicts</code></td><td align="left">[]Conflict</td><td align="left">The conflict data.</td></tr>
</tbody></table>
<h4 id="type-conflict"><a class="header" href="#type-conflict">Type <code>Conflict</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The branch identifier encoded with base58.</td></tr>
<tr><td align="left"><code>branchIDs</code></td><td align="left">[]string</td><td align="left">The identifiers of all related branches encoded in base58.</td></tr>
</tbody></table>
<h4 id="type-outputid-2"><a class="header" href="#type-outputid-2">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstateoutputsoutputid"><a class="header" href="#ledgerstateoutputsoutputid"><code>/ledgerstate/outputs/:outputID</code></a></h2>
<p>Get an output details for a given base58 encoded output ID, such as output types, addresses, and their corresponding balances.
For the client library API call balances will not be directly available as values because they are stored as a raw message. </p>
<h3 id="parameters-14"><a class="header" href="#parameters-14">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>outputID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The output ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-16"><a class="header" href="#examples-16">Examples</a></h3>
<h4 id="curl-16"><a class="header" href="#curl-16">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/outputs/:outputID \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:outputID</code> is the ID of the output, e.g. 41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK.</p>
<h4 id="client-lib---getoutput"><a class="header" href="#client-lib---getoutput">Client lib - <code>GetOutput()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetOutput(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;outputID: &quot;, resp.OutputID.Base58)
fmt.Println(&quot;output type: &quot;, resp.Type)
fmt.Println(&quot;transactionID: &quot;, resp.OutputID.TransactionID)
</code></pre>
<h3 id="response-examples-11"><a class="header" href="#response-examples-11">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;outputID&quot;: {
        &quot;base58&quot;: &quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;,
        &quot;transactionID&quot;: &quot;9wr21zza46Y5QonKEHNQ6x8puA7Rbq5LAbsQZJCK1g1g&quot;,
        &quot;outputIndex&quot;: 0
    },
    &quot;type&quot;: &quot;SigLockedColoredOutputType&quot;,
    &quot;output&quot;: {
        &quot;balances&quot;: {
            &quot;11111111111111111111111111111111&quot;: 1000000
        },
        &quot;address&quot;: &quot;1F95a2yceDicNLvqod6P3GLFZDAFdwizcTTYow4Y1G3tt&quot;
    }
}
</code></pre>
<h3 id="results-13"><a class="header" href="#results-13">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The identifier of an output.</td></tr>
<tr><td align="left"><code>outputType</code></td><td align="left">string</td><td align="left">The type of the output.</td></tr>
<tr><td align="left"><code>output</code></td><td align="left">string</td><td align="left">An output raw message containing balances and corresponding addresses</td></tr>
</tbody></table>
<h4 id="type-outputid-3"><a class="header" href="#type-outputid-3">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstateoutputsoutputidconsumers"><a class="header" href="#ledgerstateoutputsoutputidconsumers"><code>/ledgerstate/outputs/:outputID/consumers</code></a></h2>
<p>Get a list of consumers based on a provided base58 encoded output ID. Transactions that contains the output and information about its validity.</p>
<h3 id="parameters-15"><a class="header" href="#parameters-15">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>outputID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The output ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-17"><a class="header" href="#examples-17">Examples</a></h3>
<h4 id="curl-17"><a class="header" href="#curl-17">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/outputs/:outputID/consumers \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:outputID</code> is the ID of the output, e.g. 41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK.</p>
<h4 id="client-lib---getoutputconsumers"><a class="header" href="#client-lib---getoutputconsumers">Client lib - <code>GetOutputConsumers()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetOutputConsumers(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;outputID: &quot;, resp.OutputID.Base58)
// iterate over output consumers
for _, consumer := range resp.Consumers {
    fmt.Println(&quot;transactionID: &quot;, consumer.TransactionID)
    fmt.Println(&quot;valid: &quot;, consumer.Valid)
}
</code></pre>
<h3 id="response-examples-12"><a class="header" href="#response-examples-12">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;outputID&quot;: {
        &quot;base58&quot;: &quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;,
        &quot;transactionID&quot;: &quot;9wr21zza46Y5QonKEHNQ6x8puA7Rbq5LAbsQZJCK1g1g&quot;,
        &quot;outputIndex&quot;: 0
    },
    &quot;consumers&quot;: [
        {
            &quot;transactionID&quot;: &quot;b8QRhHerfg14cYQ4VFD7Fyh1HYTCbjt9aK1XJmdoXwq&quot;,
            &quot;valid&quot;: &quot;true&quot;
        },
        {
            &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
            &quot;valid&quot;: &quot;true&quot;
        }
    ]
}
</code></pre>
<h3 id="results-14"><a class="header" href="#results-14">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>consumers</code></td><td align="left">[]Consumer</td><td align="left">Consumers of the requested output.</td></tr>
</tbody></table>
<h4 id="type-outputid-4"><a class="header" href="#type-outputid-4">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<h4 id="type-consumers"><a class="header" href="#type-consumers">Type <code>Consumers</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>valid</code></td><td align="left">string</td><td align="left">The boolean indicator if the transaction is valid.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstateoutputsoutputidmetadata"><a class="header" href="#ledgerstateoutputsoutputidmetadata"><code>/ledgerstate/outputs/:outputID/metadata</code></a></h2>
<p>Gets an output metadata for a given base58 encoded output ID.</p>
<h3 id="parameters-16"><a class="header" href="#parameters-16">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>outputID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The output ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-18"><a class="header" href="#examples-18">Examples</a></h3>
<h4 id="curl-18"><a class="header" href="#curl-18">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/outputs/:outputID/metadata \
-X GET \
-H 'Content-Type: application/json'

</code></pre>
<p>where <code>:outputID</code> is the ID of the output, e.g. 41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK.</p>
<h4 id="client-lib---getoutputmetadata"><a class="header" href="#client-lib---getoutputmetadata">Client lib - <code>GetOutputMetadata()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetOutputMetadata(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Printf(&quot;Metadata of an output %s:\n&quot;, resp.OutputID.Base58)
fmt.Println(&quot;branchID: &quot;, resp.BranchID)
fmt.Println(&quot;first consumer: &quot;, resp.FirstConsumer)
fmt.Println(&quot;number of consumers: &quot;, resp.ConsumerCount)
fmt.Printf(&quot;finalized: %v, solid: %v\n&quot;, resp.Finalized, resp.Solid)
fmt.Println(&quot;solidification time: &quot;,  time.Unix(resp.SolidificationTime, 0))
</code></pre>
<h3 id="response-examples-13"><a class="header" href="#response-examples-13">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;outputID&quot;: {
        &quot;base58&quot;: &quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;,
        &quot;transactionID&quot;: &quot;9wr21zza46Y5QonKEHNQ6x8puA7Rbq5LAbsQZJCK1g1g&quot;,
        &quot;outputIndex&quot;: 0
    },
    &quot;branchID&quot;: &quot;4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM&quot;,
    &quot;solid&quot;: true,
    &quot;solidificationTime&quot;: 1621889327,
    &quot;consumerCount&quot;: 2,
    &quot;firstConsumer&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;finalized&quot;: true
}
</code></pre>
<h3 id="results-15"><a class="header" href="#results-15">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>branchID</code></td><td align="left">string</td><td align="left">The identifier of the branch encoded with base58.</td></tr>
<tr><td align="left"><code>solid</code></td><td align="left">bool</td><td align="left">The boolean indicator if the message is solid.</td></tr>
<tr><td align="left"><code>solidificationTime</code></td><td align="left">int64</td><td align="left">The time of solidification of a message.</td></tr>
<tr><td align="left"><code>consumerCount</code></td><td align="left">int</td><td align="left">The number of consumers.</td></tr>
<tr><td align="left"><code>firstConsumer</code></td><td align="left">string</td><td align="left">The first consumer of the output.</td></tr>
<tr><td align="left"><code>finalized</code></td><td align="left">bool</td><td align="left">The boolean indicator if the transaction is finalized.</td></tr>
</tbody></table>
<h4 id="type-outputid-5"><a class="header" href="#type-outputid-5">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactionstransactionid"><a class="header" href="#ledgerstatetransactionstransactionid"><code>/ledgerstate/transactions/:transactionID</code></a></h2>
<p>Gets a transaction details for a given base58 encoded transaction ID.</p>
<h3 id="parameters-17"><a class="header" href="#parameters-17">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>transactionID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The transaction ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-19"><a class="header" href="#examples-19">Examples</a></h3>
<h4 id="curl-19"><a class="header" href="#curl-19">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/transactions/:transactionID \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:transactionID</code> is the ID of the branch, e.g. HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV.</p>
<h4 id="client-lib---gettransaction"><a class="header" href="#client-lib---gettransaction">Client lib - <code>GetTransaction()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetTransaction(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;transaction inputs:&quot;)
for _, input := range resp.Inputs {
    fmt.Println(&quot;inputID:&quot;, input.ReferencedOutputID.Base58)
}
fmt.Println(&quot;transaction outputs:&quot;)
for _, output := range resp.Outputs{
    fmt.Println(&quot;outputID:&quot;, output.OutputID.Base58)
    fmt.Println(&quot;output type:&quot;, output.Type)
}
fmt.Println(&quot;access mana pledgeID:&quot;, resp.AccessPledgeID)
fmt.Println(&quot;consensus mana pledgeID:&quot;, resp.ConsensusPledgeID)
</code></pre>
<h3 id="response-examples-14"><a class="header" href="#response-examples-14">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;version&quot;: 0,
    &quot;timestamp&quot;: 1621889348,
    &quot;accessPledgeID&quot;: &quot;DsHT39ZmwAGrKQe7F2rAjwHseUnJeY89gDPEH1FJxYdH&quot;,
    &quot;consensusPledgeID&quot;: &quot;DsHT39ZmwAGrKQe7F2rAjwHseUnJeY89gDPEH1FJxYdH&quot;,
    &quot;inputs&quot;: [
        {
            &quot;type&quot;: &quot;UTXOInputType&quot;,
            &quot;referencedOutputID&quot;: {
                &quot;base58&quot;: &quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;,
                &quot;transactionID&quot;: &quot;9wr21zza46Y5QonKEHNQ6x8puA7Rbq5LAbsQZJCK1g1g&quot;,
                &quot;outputIndex&quot;: 0
            }
        }
    ],
    &quot;outputs&quot;: [
        {
            &quot;outputID&quot;: {
                &quot;base58&quot;: &quot;6gMWUCgJDozmyLeGzW3ibGFicEq2wbhsxgAw8rUVPvn9bj5&quot;,
                &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
                &quot;outputIndex&quot;: 0
            },
            &quot;type&quot;: &quot;SigLockedColoredOutputType&quot;,
            &quot;output&quot;: {
                &quot;balances&quot;: {
                    &quot;11111111111111111111111111111111&quot;: 1000000
                },
                &quot;address&quot;: &quot;1HrUn1jWAjrMU58LLdFhfnWBwUKVdWjP5ojp7oCL9mVWs&quot;
            }
        }
    ],
    &quot;unlockBlocks&quot;: [
        {
            &quot;type&quot;: &quot;SignatureUnlockBlockType&quot;,
            &quot;publicKey&quot;: &quot;12vNcfgRHLSsobeqZFrjFRcVAmFQbDVniguPnEoxmkbG&quot;,
            &quot;signature&quot;: &quot;4isq3qzhY4MwbSeYM2NgRn5noWAyh5rqD12ruiTQ7P89TfXNecwHZ5nbpDc4UB7md1bkfM1xYtSh18FwLqK8HAC6&quot;
        }
    ],
    &quot;dataPayload&quot;: &quot;&quot;
}
</code></pre>
<h3 id="results-16"><a class="header" href="#results-16">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>version</code></td><td align="left">uint8</td><td align="left">The version of the transaction essence.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The issuing time of the transaction.</td></tr>
<tr><td align="left"><code>accessPledgeID</code></td><td align="left">string</td><td align="left">The node ID indicating to which node pledge the access mana.</td></tr>
<tr><td align="left"><code>consensusPledgeID</code></td><td align="left">string</td><td align="left">The node ID indicating to which node pledge the consensus mana.</td></tr>
<tr><td align="left"><code>inputs</code></td><td align="left">[]Input</td><td align="left">The inputs of the transaction.</td></tr>
<tr><td align="left"><code>outputs</code></td><td align="left">[]Output</td><td align="left">The outputs of the transaction.</td></tr>
<tr><td align="left"><code>unlockBlocks</code></td><td align="left">[]UnlockBlock</td><td align="left">The unlock block containing signatures unlocking the inputs or references to previous unlock blocks.</td></tr>
<tr><td align="left"><code>dataPayload</code></td><td align="left">[]byte</td><td align="left">The raw data payload that can be attached to the transaction.</td></tr>
</tbody></table>
<h4 id="type-input"><a class="header" href="#type-input">Type <code>Input </code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>Type</code></td><td align="left">string</td><td align="left">The type of input.</td></tr>
<tr><td align="left"><code>ReferencedOutputID</code></td><td align="left">ReferencedOutputID</td><td align="left">The output ID that is used as an input for the transaction.</td></tr>
</tbody></table>
<h4 id="type-referencedoutputid"><a class="header" href="#type-referencedoutputid">Type <code>ReferencedOutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The referenced output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of a referenced output.</td></tr>
</tbody></table>
<h4 id="type-output-2"><a class="header" href="#type-output-2">Type <code>Output</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The identifier of an output.</td></tr>
<tr><td align="left"><code>outputType</code></td><td align="left">string</td><td align="left">The type of the output.</td></tr>
<tr><td align="left"><code>output</code></td><td align="left">string</td><td align="left">An output raw message containing balances and corresponding addresses.</td></tr>
</tbody></table>
<h4 id="type-outputid-6"><a class="header" href="#type-outputid-6">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<h4 id="type-unlockblock"><a class="header" href="#type-unlockblock">Type <code>UnlockBlock</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The unlock block type: signature or reference.</td></tr>
<tr><td align="left"><code>referencedIndex</code></td><td align="left">uint16</td><td align="left">The reference index of an unlock block.</td></tr>
<tr><td align="left"><code>signatureType</code></td><td align="left">uint8</td><td align="left">The unlock block signature type: ED25519 or BLS.</td></tr>
<tr><td align="left"><code>publicKey</code></td><td align="left">string</td><td align="left">The public key of a transaction owner.</td></tr>
<tr><td align="left"><code>signature</code></td><td align="left">string</td><td align="left">The string representation of a signature encoded with base58 signed over a transaction essence.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactionstransactionidmetadata"><a class="header" href="#ledgerstatetransactionstransactionidmetadata"><code>/ledgerstate/transactions/:transactionID/metadata</code></a></h2>
<p>Gets a transaction metadata for a given base58 encoded transaction ID.</p>
<h3 id="parameters-18"><a class="header" href="#parameters-18">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>transactionID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The transaction ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-20"><a class="header" href="#examples-20">Examples</a></h3>
<h4 id="curl-20"><a class="header" href="#curl-20">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/transactions/:transactionID/metadata \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:transactionID</code> is the ID of the branch, e.g. HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV.</p>
<h4 id="client-lib---gettransactionmetadata"><a class="header" href="#client-lib---gettransactionmetadata">Client lib - <code>GetTransactionMetadata()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetTransactionMetadata(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Println(&quot;transactionID:&quot;, resp.TransactionID)
fmt.Println(&quot;branchID:&quot;, resp.BranchID)
fmt.Printf(&quot;branch lazy booked: %v, solid: %v, finalized: %v\n&quot;, resp.LazyBooked, resp.Solid, resp.Finalized)
fmt.Println(&quot;solidification time:&quot;,  time.Unix(resp.SolidificationTime, 0))
</code></pre>
<h3 id="response-examples-15"><a class="header" href="#response-examples-15">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;branchID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;solid&quot;: true,
    &quot;solidificationTime&quot;: 1621889358,
    &quot;finalized&quot;: true,
    &quot;lazyBooked&quot;: false
}
</code></pre>
<h3 id="results-17"><a class="header" href="#results-17">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>branchID</code></td><td align="left">string</td><td align="left">The branch identifier of the transaction.</td></tr>
<tr><td align="left"><code>solid</code></td><td align="left">bool</td><td align="left">The boolean indicator if the transaction is solid.</td></tr>
<tr><td align="left"><code>solidificationTime</code></td><td align="left">uint64</td><td align="left">The time of solidification of the transaction.</td></tr>
<tr><td align="left"><code>finalized</code></td><td align="left">bool</td><td align="left">The boolean indicator if the transaction is finalized.</td></tr>
<tr><td align="left"><code>lazyBooked</code></td><td align="left">bool</td><td align="left">The boolean indicator if the transaction is lazily booked.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactionstransactionidinclusionstate"><a class="header" href="#ledgerstatetransactionstransactionidinclusionstate"><code>/ledgerstate/transactions/:transactionID/inclusionState</code></a></h2>
<p>Gets the fcob opinion associated with transaction based on a given base58 encoded transaction ID.</p>
<h3 id="parameters-19"><a class="header" href="#parameters-19">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>transactionID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The transaction ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-21"><a class="header" href="#examples-21">Examples</a></h3>
<h4 id="curl-21"><a class="header" href="#curl-21">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/transactions/:transactionID/inclusionState \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:transactionID</code> is the ID of the branch, e.g. HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV.</p>
<h4 id="client-lib---gettransactioninclusionstate"><a class="header" href="#client-lib---gettransactioninclusionstate">Client lib - <code>GetTransactionInclusionState()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetTransactionInclusionState(&quot;41GvDSQnd12e4nWnd2WzmdLmffruXqsE46jgeUbnB8s1QnK&quot;)
if err != nil {
    // return error
}
fmt.Printf(&quot;Inclusion state of transaction %s:\n&quot;, resp.TransactionID)
fmt.Printf(&quot;conflicting: %v, confirmed: %v, rejected: %v, pending: %v\n&quot;, resp.Conflicting, resp.Confirmed, resp.Rejected, resp.Pending)
</code></pre>
<h3 id="response-examples-16"><a class="header" href="#response-examples-16">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;pending&quot;: false,
    &quot;confirmed&quot;: true,
    &quot;rejected&quot;: false,
    &quot;conflicting&quot;: true
}
</code></pre>
<h3 id="results-18"><a class="header" href="#results-18">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>pending</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction has not yet been confirmed nor rejected.</td></tr>
<tr><td align="left"><code>confirmed</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction is confirmed.</td></tr>
<tr><td align="left"><code>rejected</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction was rejected and is booked to the rejected branch.</td></tr>
<tr><td align="left"><code>conflicting</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction is conflicting with some other transaction.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactionstransactionidconsensus"><a class="header" href="#ledgerstatetransactionstransactionidconsensus"><code>/ledgerstate/transactions/:transactionID/consensus</code></a></h2>
<p>Gets the fcob opinion associated with transaction based on a given base58 encoded transaction ID.</p>
<h3 id="parameters-20"><a class="header" href="#parameters-20">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>transactionID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The transaction ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-22"><a class="header" href="#examples-22">Examples</a></h3>
<h4 id="curl-22"><a class="header" href="#curl-22">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/transactions/:transactionID/consensus \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:transactionID</code> is the ID of the branch, e.g. HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV.</p>
<h4 id="client-lib---gettransactionconsensusmetadata"><a class="header" href="#client-lib---gettransactionconsensusmetadata">Client lib - <code>GetTransactionConsensusMetadata()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetTransactionConsensusMetadata(&quot;DNSN8GaCeep6CVuUV6KXAabXkL3bv4PUP4NkTNKoZMqS&quot;)
if err != nil {
    // return err
}
fmt.Printf(&quot;Consensus metadata for transaction %s:\n&quot;, resp.TransactionID)
fmt.Println(&quot;fcob opinion, is liked:&quot;, resp.Liked)
fmt.Println(&quot;level of knowledge:&quot;, resp.LoK)
fmt.Println(&quot;fcob timestamp:&quot;, time.Unix(resp.Timestamp, 0))
fmt.Println(&quot;fcob time 1:&quot;, time.Unix(resp.FCOBTime1, 0))
fmt.Println(&quot;fcob time 2:&quot;, time.Unix(resp.FCOBTime2, 0))
</code></pre>
<h3 id="response-examples-17"><a class="header" href="#response-examples-17">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;timestamp&quot;: 1621889358,
    &quot;liked&quot;: true,
    &quot;lok&quot;: &quot;LevelOfKnowledge(Three)&quot;,
    &quot;fcobTime1&quot;: 1621889360,
    &quot;fcobTime2&quot;: 1621889362
}
</code></pre>
<h3 id="results-19"><a class="header" href="#results-19">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">uint64</td><td align="left">The timestamp of the arrival.</td></tr>
<tr><td align="left"><code>lok</code></td><td align="left">string</td><td align="left">The level of knowledge of the transaction - the degree of certainty of the associated opinion.</td></tr>
<tr><td align="left"><code>liked</code></td><td align="left">bool</td><td align="left">The fcob opinion for the transaction.</td></tr>
<tr><td align="left"><code>fcobTime1</code></td><td align="left">uint64</td><td align="left">The fcob opinion's execution time.</td></tr>
<tr><td align="left"><code>fcobTime2</code></td><td align="left">uint64</td><td align="left">The fcob opinion's locally finalized execution time.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactionstransactionidattachments"><a class="header" href="#ledgerstatetransactionstransactionidattachments"><code>/ledgerstate/transactions/:transactionID/attachments</code></a></h2>
<p>Gets the list of messages IDs with attachments of the base58 encoded transaction ID.</p>
<h3 id="parameters-21"><a class="header" href="#parameters-21">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>transactionID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>The transaction ID encoded in base58.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-23"><a class="header" href="#examples-23">Examples</a></h3>
<h4 id="curl-23"><a class="header" href="#curl-23">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/transactions/:transactionID/attachments \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<p>where <code>:transactionID</code> is the ID of the branch, e.g. HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV.</p>
<h4 id="client-lib---gettransactionattachments"><a class="header" href="#client-lib---gettransactionattachments">Client lib - <code>GetTransactionAttachments()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.GetTransactionAttachments(&quot;DNSN8GaCeep6CVuUV6KXAabXkL3bv4PUP4NkTNKoZMqS&quot;)
if err != nil {
    // return error
}
fmt.Printf(&quot;Messages IDs containing transaction %s:\n&quot;, resp.TransactionID)
for _, msgID := range resp.MessageIDs {
    fmt.Println(msgID)
}
</code></pre>
<h3 id="response-examples-18"><a class="header" href="#response-examples-18">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;transactionID&quot;: &quot;HuYUAwCeexmBePNXx5rNeJX1zUvUdUUs5LvmRmWe7HCV&quot;,
    &quot;messageIDs&quot;: [
        &quot;J1FQdMcticXiiuKMbjobq4zrYGHagk2mtTzkVwbqPgSq&quot;
    ]
}
</code></pre>
<h3 id="results-20"><a class="header" href="#results-20">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>messageIDs</code></td><td align="left">[]string</td><td align="left">The messages IDs that contains the requested transaction.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstatetransactions"><a class="header" href="#ledgerstatetransactions"><code>/ledgerstate/transactions</code></a></h2>
<p>Sends transaction provided in form of a binary data, validates transaction before issuing the message payload. For more detail on how to prepare transaction bytes see the <a href="apis/">tutorial</a>.</p>
<h3 id="examples-24"><a class="header" href="#examples-24">Examples</a></h3>
<h4 id="client-lib---posttransaction"><a class="header" href="#client-lib---posttransaction">Client lib - <code>PostTransaction()</code></a></h4>
<pre><code class="language-GO">// prepare tx essence and signatures
...
// create transaction
tx := ledgerstate.NewTransaction(txEssence, ledgerstate.UnlockBlocks{unlockBlock})
resp, err := goshimAPI.PostTransaction(tx.Bytes())
if err != nil {
    // return error
}
fmt.Println(&quot;Transaction sent, txID: &quot;, resp.TransactionID)
</code></pre>
<h3 id="results-21"><a class="header" href="#results-21">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>Error</code></td><td align="left">error</td><td align="left">The error returned if transaction was not processed correctly, otherwise is nil.</td></tr>
</tbody></table>
<br />
<h2 id="ledgerstateaddressesunspentoutputs"><a class="header" href="#ledgerstateaddressesunspentoutputs"><code>/ledgerstate/addresses/unspentOutputs</code></a></h2>
<p>Gets all unspent outputs for a list of addresses that were sent in the body message.  Returns the unspent outputs along with inclusion state and metadata for the wallet. </p>
<h3 id="request-body-3"><a class="header" href="#request-body-3">Request Body</a></h3>
<pre><code class="language-json">{
    &quot;addresses&quot;: [
        &quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;
    ]
}
</code></pre>
<h3 id="examples-25"><a class="header" href="#examples-25">Examples</a></h3>
<h4 id="curl-24"><a class="header" href="#curl-24">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/ledgerstate/addresses/unspentOutputs \
-X POST \
-H 'Content-Type: application/json'
--data-raw '{&quot;addresses&quot;: [&quot;18LhfKUkWt4M9YR6Q3au4LT8wWCERwzHaqn153K78Eixp&quot;]}'
</code></pre>
<h4 id="client-lib---postaddressunspentoutputs"><a class="header" href="#client-lib---postaddressunspentoutputs">Client lib - <code>PostAddressUnspentOutputs()</code></a></h4>
<pre><code class="language-Go">resp, err := goshimAPI.PostAddressUnspentOutputs([]string{&quot;H36sZQkopfoEzP3WCMThSjUv5v9MLVYuaQ73tsKgVzXo&quot;})
if err != nil {
    return
}
for _, outputs := range resp.UnspentOutputs {
    fmt.Println(&quot;address ID:&quot;, outputs.Address.Base58)
    fmt.Println(&quot;address type:&quot;, outputs.Address.Type)

    for _, output := range outputs.Outputs {
        fmt.Println(&quot;output ID:&quot;, output.Output.OutputID.Base58)
        fmt.Println(&quot;output type:&quot;, output.Output.Type)
    }
}
</code></pre>
<h3 id="response-examples-19"><a class="header" href="#response-examples-19">Response examples</a></h3>
<pre><code class="language-json">{
    &quot;unspentOutputs&quot;: [
        {
            &quot;address&quot;: {
                &quot;type&quot;: &quot;AddressTypeED25519&quot;,
                &quot;base58&quot;: &quot;1Z4t5KEKU65fbeQCbNdztYTB1B4Cdxys1XRzTFrmvAf3&quot;
            },
            &quot;outputs&quot;: [
                {
                    &quot;output&quot;: {
                        &quot;outputID&quot;: {
                            &quot;base58&quot;: &quot;4eGoQWG7UDtBGK89vENQ5Ea1N1b8xF26VD2F8nigFqgyx5m&quot;,
                            &quot;transactionID&quot;: &quot;BqzgVk4yY9PDZuDro2mvT36U52ZYbJDfM41Xng3yWoQK&quot;,
                            &quot;outputIndex&quot;: 0
                        },
                        &quot;type&quot;: &quot;SigLockedColoredOutputType&quot;,
                        &quot;output&quot;: {
                            &quot;balances&quot;: {
                                &quot;11111111111111111111111111111111&quot;: 1000000
                            },
                            &quot;address&quot;: &quot;1Z4t5KEKU65fbeQCbNdztYTB1B4Cdxys1XRzTFrmvAf3&quot;
                        }
                    },
                    &quot;inclusionState&quot;: {
                        &quot;confirmed&quot;: true,
                        &quot;rejected&quot;: false,
                        &quot;conflicting&quot;: false
                    },
                    &quot;metadata&quot;: {
                        &quot;timestamp&quot;: &quot;2021-05-25T15:47:04.50470213+02:00&quot;
                    }
                }
            ]
        }
    ]
}
</code></pre>
<h3 id="results-22"><a class="header" href="#results-22">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>unspentOutputs</code></td><td align="left">WalletOutputsOnAddress</td><td align="left">Unspent outputs representation for wallet.</td></tr>
</tbody></table>
<h4 id="type-walletoutputsonaddress"><a class="header" href="#type-walletoutputsonaddress">Type <code>WalletOutputsOnAddress</code></a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>Address</code></td><td align="left">Address</td><td align="left">The address corresponding to the unspent output.</td></tr>
<tr><td align="left"><code>Outputs</code></td><td align="left">[]WalletOutput</td><td align="left">Unspent outputs representation for wallet.</td></tr>
</tbody></table>
<h4 id="type-address-2"><a class="header" href="#type-address-2">Type <code>Address</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>type</code></td><td align="left">string</td><td align="left">The type of an address.</td></tr>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The address encoded with base58.</td></tr>
</tbody></table>
<h4 id="type-walletoutput"><a class="header" href="#type-walletoutput">Type <code>WalletOutput</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>output</code></td><td align="left">Output</td><td align="left">The unspent output.</td></tr>
<tr><td align="left"><code>inclusionState</code></td><td align="left">InclusionState</td><td align="left">The inclusion state of the transaction containing the output.</td></tr>
<tr><td align="left"><code>metadata</code></td><td align="left">WalletOutputMetadata</td><td align="left">The metadata of the output for the wallet lib.</td></tr>
</tbody></table>
<h4 id="type-output-3"><a class="header" href="#type-output-3">Type <code>Output</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>outputID</code></td><td align="left">OutputID</td><td align="left">The identifier of an output.</td></tr>
<tr><td align="left"><code>outputType</code></td><td align="left">string</td><td align="left">The type of the output.</td></tr>
<tr><td align="left"><code>output</code></td><td align="left">string</td><td align="left">An outputs raw message containing balances and corresponding addresses</td></tr>
</tbody></table>
<h4 id="type-outputid-7"><a class="header" href="#type-outputid-7">Type <code>OutputID</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>base58</code></td><td align="left">string</td><td align="left">The output identifier encoded with base58.</td></tr>
<tr><td align="left"><code>transactionID</code></td><td align="left">string</td><td align="left">The transaction identifier encoded with base58.</td></tr>
<tr><td align="left"><code>outputIndex</code></td><td align="left">int</td><td align="left">The index of an output.</td></tr>
</tbody></table>
<h4 id="type-inclusionstate"><a class="header" href="#type-inclusionstate">Type <code>InclusionState</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>confirmed</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction containing the output is confirmed.</td></tr>
<tr><td align="left"><code>rejected</code></td><td align="left">bool</td><td align="left">The boolean indicating if the transaction that contains the output was rejected and is booked to the rejected branch.</td></tr>
<tr><td align="left"><code>conflicting</code></td><td align="left">bool</td><td align="left">The boolean indicating if the output is in conflicting transaction.</td></tr>
</tbody></table>
<h4 id="type-walletoutputmetadata"><a class="header" href="#type-walletoutputmetadata">Type <code>WalletOutputMetadata</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>timestamp</code></td><td align="left">time.Time</td><td align="left">The timestamp of the transaction containing the output.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mana-api-methods"><a class="header" href="#mana-api-methods">Mana API Methods</a></h1>
<p>The mana APIs provide methods for people to retrieve the amount of access/consensus mana of nodes and outputs, as well as the event logs.</p>
<p>HTTP APIs:</p>
<ul>
<li><a href="apis/mana.html#mana">/mana</a></li>
<li><a href="apis/mana.html#manaall">/mana/all</a></li>
<li><a href="apis/mana.html#manapercentile">/mana/percentile</a></li>
<li><a href="apis/mana.html#manaaccessonline">/mana/access/online</a></li>
<li><a href="apis/mana.html#manaconsensusonline">/mana/consensus/online</a></li>
<li><a href="apis/mana.html#manaaccessnhighest">/mana/access/nhighest</a></li>
<li><a href="apis/mana.html#manaconsensusnhighest">/mana/consensus/nhighest</a></li>
<li><a href="apis/mana.html#manapending">/mana/pending</a></li>
<li><a href="apis/mana.html#manaconsensuspast">/mana/consensus/past</a></li>
<li><a href="apis/mana.html#manaconsensuslogs">/mana/consensus/logs</a></li>
<li><a href="apis/mana.html#manaallowedmanapledge">/mana/allowedManaPledge</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/mana.html#getownmana">GetOwnMana()</a></li>
<li><a href="apis/mana.html#getmanafullnodeid">GetManaFullNodeID()</a></li>
<li><a href="apis/mana.html#getmana-with-short-node-id">GetMana with short node ID()</a></li>
<li><a href="apis/mana.html#client-lib---getallmana">GetAllMana()</a></li>
<li><a href="apis/mana.html#client-lib---getmanapercentile">GetManaPercentile()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineaccessmana">GetOnlineAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineconsensusmana">GetOnlineConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestaccessmana">GetNHighestAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestconsensusmana">GetNHighestConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getpending">GetPending()</a></li>
<li><a href="apis/mana.html#client-lib---getpastconsensusmanavector">GetPastConsensusManaVector()</a></li>
<li><a href="apis/mana.html#client-lib---getconsensuseventlogs">GetConsensusEventLogs()</a></li>
<li><a href="apis/mana.html#client-lib---getallowedmanapledgenodeids">GetAllowedManaPledgeNodeIDs()</a></li>
</ul>
<br />
<h2 id="mana-1"><a class="header" href="#mana-1"><code>/mana</code></a></h2>
<p>Get the access and consensus mana of the node.</p>
<h3 id="parameters-22"><a class="header" href="#parameters-22">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>node ID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h4 id="note"><a class="header" href="#note"><strong>Note</strong></a></h4>
<p>If no node ID is given, it returns the access and consensus mana of the node you're communicating with.</p>
<h3 id="examples-26"><a class="header" href="#examples-26">Examples</a></h3>
<h4 id="curl-25"><a class="header" href="#curl-25">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib-2"><a class="header" href="#client-lib-2">client lib</a></h4>
<p>There are 3 APIs to get mana of a node, which is based on the same HTTP API <code>/mana</code>.</p>
<h5 id="getownmana"><a class="header" href="#getownmana"><code>GetOwnMana</code></a></h5>
<p>Get the access and consensus mana of the node this API client is communicating with.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetOwnMana()
if err != nil {
    // return error
}

// print the node ID
fmt.Println(&quot;full ID: &quot;, manas.NodeID, &quot;short ID: &quot;, manas.ShortNodeID)

// get access mana of the node
fmt.Println(&quot;access mana: &quot;, manas.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)

// get consensus mana of the node
fmt.Println(&quot;consensus mana: &quot;, manas.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h5 id="getmanafullnodeid"><a class="header" href="#getmanafullnodeid"><code>GetManaFullNodeID</code></a></h5>
<p>Get Mana of a node with its full node ID.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetManaFullNodeID(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}
</code></pre>
<h5 id="getmana-with-short-node-id"><a class="header" href="#getmana-with-short-node-id"><code>GetMana</code> with short node ID</a></h5>
<pre><code class="language-go">manas, err := goshimAPI.GetMana(&quot;4AeXyZ26e4G&quot;)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-examples-20"><a class="header" href="#response-examples-20">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 26.5,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 26.5,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results-23"><a class="header" href="#results-23">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<br />
<h2 id="manaall"><a class="header" href="#manaall"><code>/mana/all</code></a></h2>
<p>Get the mana perception of the node in the network. You can retrieve the full/short node ID, consensus mana, access mana of each node, and the mana updated time.</p>
<h3 id="parameters-23"><a class="header" href="#parameters-23">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-27"><a class="header" href="#examples-27">Examples</a></h3>
<h4 id="curl-26"><a class="header" href="#curl-26">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/all \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallmana"><a class="header" href="#client-lib---getallmana">Client lib - <code>GetAllMana()</code></a></h4>
<pre><code class="language-go">manas, err := goshimAPI.GetAllMana()
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)

// get access mana of each node
for _, m := range manas.Access {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;access mana: &quot;, m.Mana)
}

// get consensus mana of each node
for _, m := range manas.Consensus {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-21"><a class="header" href="#response-examples-21">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;access&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;consensusTimestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-24"><a class="header" href="#results-24">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>access</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h4 id="type-mananodestr"><a class="header" href="#type-mananodestr">Type <code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<br />
<h2 id="manapercentile"><a class="header" href="#manapercentile"><code>/mana/percentile</code></a></h2>
<p>To learn the top percentile the node belongs to relative to the network in terms of mana. The input should be a full node ID.</p>
<h3 id="parameters-24"><a class="header" href="#parameters-24">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>node ID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-28"><a class="header" href="#examples-28">Examples</a></h3>
<h4 id="curl-27"><a class="header" href="#curl-27">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/percentile?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getmanapercentile"><a class="header" href="#client-lib---getmanapercentile">Client lib - <code>GetManaPercentile()</code></a></h4>
<pre><code class="language-go">mana, err := goshimAPI.GetManaPercentile(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana percentile: &quot;, mana.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana percentile: &quot;, mana.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h3 id="response-examples-22"><a class="header" href="#response-examples-22">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 75,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 75,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results-25"><a class="header" href="#results-25">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<br />
<h2 id="manaaccessonline"><a class="header" href="#manaaccessonline"><code>/mana/access/online</code></a></h2>
<p>You can get a sorted list of online access mana of nodes, sorted from the highest access mana to the lowest. The highest access mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-25"><a class="header" href="#parameters-25">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-29"><a class="header" href="#examples-29">Examples</a></h3>
<h4 id="curl-28"><a class="header" href="#curl-28">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineaccessmana"><a class="header" href="#client-lib---getonlineaccessmana">Client lib - <code>GetOnlineAccessMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineAccessMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;access mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-23"><a class="header" href="#response-examples-23">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-26"><a class="header" href="#results-26">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The access mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="type-onlinenodestr"><a class="header" href="#type-onlinenodestr">Type <code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
</tbody></table>
<br />
<h2 id="manaconsensusonline"><a class="header" href="#manaconsensusonline"><code>/mana/consensus/online</code></a></h2>
<p>You can get a sorted list of online consensus mana of nodes, sorted from the highest consensus mana to the lowest. The highest consensus mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-26"><a class="header" href="#parameters-26">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-30"><a class="header" href="#examples-30">Examples</a></h3>
<h4 id="curl-29"><a class="header" href="#curl-29">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineconsensusmana"><a class="header" href="#client-lib---getonlineconsensusmana">Client lib - <code>GetOnlineConsensusMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineConsensusMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-24"><a class="header" href="#response-examples-24">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-27"><a class="header" href="#results-27">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The consensus mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="type-onlinenodestr-1"><a class="header" href="#type-onlinenodestr-1">Type <code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
</tbody></table>
<br />
<h2 id="manaaccessnhighest"><a class="header" href="#manaaccessnhighest"><code>/mana/access/nhighest</code></a></h2>
<p>You can get the N highest access mana holders in the network, sorted in descending order.
If N=0, all nodes that have access mana are returned sorted.</p>
<h3 id="parameters-27"><a class="header" href="#parameters-27">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-31"><a class="header" href="#examples-31">Examples</a></h3>
<h4 id="curl-30"><a class="header" href="#curl-30">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestaccessmana"><a class="header" href="#client-lib---getnhighestaccessmana">Client lib - <code>GetNHighestAccessMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest access mana nodes
accessMana, err := goshimAPI.GetNHighestAccessMana(5)
if err != nil {
    // return error
}

for _, m := accessMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;access mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-25"><a class="header" href="#response-examples-25">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-28"><a class="header" href="#results-28">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest access mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="type-mananodestr-1"><a class="header" href="#type-mananodestr-1">Type <code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<br />
<h2 id="manaconsensusnhighest"><a class="header" href="#manaconsensusnhighest"><code>/mana/consensus/nhighest</code></a></h2>
<p>You can get the N highest consensus mana holders in the network, sorted in descending order.</p>
<h3 id="parameters-28"><a class="header" href="#parameters-28">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest consensus mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-32"><a class="header" href="#examples-32">Examples</a></h3>
<h4 id="curl-31"><a class="header" href="#curl-31">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestconsensusmana"><a class="header" href="#client-lib---getnhighestconsensusmana">Client lib - <code>GetNHighestConsensusMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest consensus mana nodes
consensusMana, err := goshimAPI.GetNHighestConsensusMana(5)
if err != nil {
    // return error
}

for _, m := consensusMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-26"><a class="header" href="#response-examples-26">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-29"><a class="header" href="#results-29">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest consensus mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="type-mananodestr-2"><a class="header" href="#type-mananodestr-2">Type <code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<br />
<h2 id="manapending"><a class="header" href="#manapending"><code>/mana/pending</code></a></h2>
<p>Get the amount of base access mana that would be pledged if the given output was spent.</p>
<h3 id="parameters-29"><a class="header" href="#parameters-29">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>outputID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The requesting output ID.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-33"><a class="header" href="#examples-33">Examples</a></h3>
<h4 id="curl-32"><a class="header" href="#curl-32">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/pending?outputid=&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot; \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpending"><a class="header" href="#client-lib---getpending">Client lib - <code>GetPending()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPending(&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;)
if err != nil {
    // return error
}

// get the amount of mana
fmt.Println(&quot;mana be pledged: &quot;, res.Mana)
fmt.Println(&quot;the timestamp of the output (decay duration)&quot;, res.Timestamp)
</code></pre>
<h3 id="response-examples-27"><a class="header" href="#response-examples-27">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;mana&quot;: 26.5,
  &quot;outputID&quot;: &quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;,  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-30"><a class="header" href="#results-30">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access base mana to be pledged.</td></tr>
<tr><td align="left"><code>outputID</code></td><td align="left">string</td><td align="left">The output ID of the request.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<br />
<h2 id="manaconsensuspast"><a class="header" href="#manaconsensuspast"><code>/mana/consensus/past</code></a></h2>
<p>Get the consensus base mana vector of a time (int64) in the past.</p>
<h3 id="parameters-30"><a class="header" href="#parameters-30">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>timestamp</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The timestamp of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>int64</td></tr>
</tbody></table>
<h3 id="examples-34"><a class="header" href="#examples-34">Examples</a></h3>
<h4 id="curl-33"><a class="header" href="#curl-33">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/past?timestamp=1614924295 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpastconsensusmanavector"><a class="header" href="#client-lib---getpastconsensusmanavector">Client lib - <code>GetPastConsensusManaVector()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPastConsensusManaVector(1614924295)
if err != nil {
    // return error
}

// the mana vector of each node
for _, m := range res.Consensus {
    fmt.Println(&quot;node ID:&quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-28"><a class="header" href="#response-examples-28">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;consensus&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5 
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-31"><a class="header" href="#results-31">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">The consensus mana of nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="type-mananodestr-3"><a class="header" href="#type-mananodestr-3">Type <code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<br />
<h2 id="manaconsensuslogs"><a class="header" href="#manaconsensuslogs"><code>/mana/consensus/logs</code></a></h2>
<p>Get the consensus event logs of the given node IDs.</p>
<h3 id="parameters-31"><a class="header" href="#parameters-31">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>nodeIDs</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>A list of node ID of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>string array</td></tr>
</tbody></table>
<h3 id="examples-35"><a class="header" href="#examples-35">Examples</a></h3>
<h4 id="curl-34"><a class="header" href="#curl-34">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/logs \
-X GET \
-H 'Content-Type: application/json'
-d '{
  &quot;nodeIDs&quot;: [
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux6&quot;
  ]
}'
</code></pre>
<h4 id="client-lib---getconsensuseventlogs"><a class="header" href="#client-lib---getconsensuseventlogs">Client lib - <code>GetConsensusEventLogs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetConsensusEventLogs([]string{&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;})
if err != nil {
    // return error
}

for nodeID, e := range res.Logs {
    fmt.Println(&quot;node ID:&quot;, nodeID)
    
    // pledge logs
    for _, p := e.Pledge {
        fmt.Println(&quot;mana type: &quot;, p.ManaType)
        fmt.Println(&quot;node ID: &quot;, p.NodeID)
        fmt.Println(&quot;time: &quot;, p.Time)
        fmt.Println(&quot;transaction ID: &quot;, p.TxID)
        fmt.Println(&quot;mana amount: &quot;, p.Amount)
    }

    // revoke logs
    for _, r := e.Revoke {
        fmt.Println(&quot;mana type: &quot;, r.ManaType)
        fmt.Println(&quot;node ID: &quot;, r.NodeID)
        fmt.Println(&quot;time: &quot;, r.Time)
        fmt.Println(&quot;transaction ID: &quot;, r.TxID)
        fmt.Println(&quot;mana amount: &quot;, r.Amount)
        fmt.Println(&quot;input ID: &quot;, r.InputID)
    }
}
</code></pre>
<h3 id="response-examples-29"><a class="header" href="#response-examples-29">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;logs&quot;: [
      &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;: {
          &quot;pledge&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28
               }
          ],
          &quot;revoke&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28,
                  &quot;inputID&quot;: &quot;35P4cW9QfzHNjXJwZMDMCUxAR7F9mfm6FvPbdpJWudK2nBZ&quot;
              }
          ]
      }
  ],  
  &quot;startTime&quot;: 1614924295,
  &quot;endTime&quot;: 1614924300
}
</code></pre>
<h3 id="results-32"><a class="header" href="#results-32">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>logs</code></td><td align="left">map[string]*EventLogsJSON</td><td align="left">The consensus mana of nodes. The key of map is node ID.</td></tr>
<tr><td align="left"><code>startTime</code></td><td align="left">int64</td><td align="left">The starting time of collecting logs.</td></tr>
<tr><td align="left"><code>endTime</code></td><td align="left">int64</td><td align="left">The ending time of collecting logs.</td></tr>
</tbody></table>
<h4 id="type-eventlogsjson"><a class="header" href="#type-eventlogsjson">Type <code>EventLogsJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>pledge</code></td><td align="left">PledgedEventJSON</td><td align="left">Pledged event logs.</td></tr>
<tr><td align="left"><code>revoke</code></td><td align="left">RevokedEventJSON</td><td align="left">Revoked event logs.</td></tr>
</tbody></table>
<h4 id="type-pledgedeventjson"><a class="header" href="#type-pledgedeventjson">Type <code>PledgedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of pledged mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of pledged mana.</td></tr>
</tbody></table>
<h4 id="type-revokedeventjson"><a class="header" href="#type-revokedeventjson">Type <code>RevokedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of revoked mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of revoked mana.</td></tr>
<tr><td align="left"><code>inputID</code></td><td align="left">string</td><td align="left">The input ID of revoked mana.</td></tr>
</tbody></table>
<br />
<h2 id="manaallowedmanapledge"><a class="header" href="#manaallowedmanapledge"><code>/mana/allowedManaPledge</code></a></h2>
<p>This returns the list of allowed mana pledge node IDs.</p>
<h3 id="parameters-32"><a class="header" href="#parameters-32">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-36"><a class="header" href="#examples-36">Examples</a></h3>
<h4 id="curl-35"><a class="header" href="#curl-35">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/allowedManaPledge \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallowedmanapledgenodeids"><a class="header" href="#client-lib---getallowedmanapledgenodeids">Client lib - <code>GetAllowedManaPledgeNodeIDs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetAllowedManaPledgeNodeIDs()
if err != nil {
    // return error
}

// print the list of nodes that access mana is allowed to be pledged to
for _, id := range res.Access.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}

// print the list of nodes that consensus mana is allowed to be pledged to
for _, id := range res.Consensus.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}
</code></pre>
<h3 id="response-examples-30"><a class="header" href="#response-examples-30">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;accessMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
  &quot;consensusMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
}
</code></pre>
<h3 id="results-33"><a class="header" href="#results-33">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>accessMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge access mana.</td></tr>
<tr><td align="left"><code>consensusMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge consensus mana.</td></tr>
</tbody></table>
<h4 id="type-allowedpledge"><a class="header" href="#type-allowedpledge">Type <code>AllowedPledge</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>isFilterEnabled</code></td><td align="left">bool</td><td align="left">A flag shows that if mana pledge filter is enabled.</td></tr>
<tr><td align="left"><code>allowed</code></td><td align="left">[]string</td><td align="left">A list of node ID that allow to be pledged mana. This list has effect only if <code>isFilterEnabled</code> is <code>true</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drng-api-methods"><a class="header" href="#drng-api-methods">dRNG API Methods</a></h1>
<p>The dRNG APIs provide methods to retrieve basic info about dRNG committees and randomness as well as to broadcast collective randomness beacon.</p>
<p>HTTP APIs:</p>
<ul>
<li><a href="apis/dRNG.html#drngcollectivebeacon">/drng/collectiveBeacon</a></li>
<li><a href="apis/dRNG.html#drnginfocommittee">/drng/info/committee</a></li>
<li><a href="apis/dRNG.html#drnginforandomness">/drng/info/randomness</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/dRNG.html#client-lib---broadcastcollectivebeacon">BroadcastCollectiveBeacon()</a></li>
<li><a href="apis/dRNG.html#client-lib---getrandomness">GetRandomness()</a></li>
<li><a href="apis/dRNG.html#client-lib---getcommittee">GetCommittee()</a></li>
</ul>
<h2 id="drngcollectivebeacon"><a class="header" href="#drngcollectivebeacon"><code>/drng/collectiveBeacon</code></a></h2>
<p>Method: <code>POST</code></p>
<p>Sends the given collective beacon (payload) by creating a message in the backend.</p>
<h3 id="parameters-33"><a class="header" href="#parameters-33">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>payload</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>collective beacon payload</td></tr>
<tr><td><strong>Type</strong></td><td>base64 serialized bytes</td></tr>
</tbody></table>
<h4 id="body-2"><a class="header" href="#body-2">Body</a></h4>
<pre><code class="language-json">{
  &quot;payload&quot;: &quot;collectiveBeaconBytes&quot;
}
</code></pre>
<h3 id="examples-37"><a class="header" href="#examples-37">Examples</a></h3>
<h4 id="curl-36"><a class="header" href="#curl-36">cURL</a></h4>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:8080/drng/collectiveBeacon' \
--header 'Content-Type: application/json' \
--data-raw '{&quot;payload&quot;: &quot;collectiveBeaconBytes&quot;}'
</code></pre>
<h4 id="client-lib---broadcastcollectivebeacon"><a class="header" href="#client-lib---broadcastcollectivebeacon">Client lib - <code>BroadcastCollectiveBeacon</code></a></h4>
<p>Collective beacon can be broadcast using <code>BroadcastCollectiveBeacon(payload []byte) (string, error)</code>.</p>
<pre><code class="language-go">msgId, err := goshimAPI.BroadcastCollectiveBeacon(payload)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-example-1"><a class="header" href="#response-example-1">Response example</a></h3>
<pre><code class="language-shell">{
  &quot;id&quot;: &quot;messageID&quot; 
}
</code></pre>
<h3 id="results-34"><a class="header" href="#results-34">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID of beacon message. Omitted if error.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="drnginfocommittee"><a class="header" href="#drnginfocommittee"><code>/drng/info/committee</code></a></h2>
<p>Returns the current dRNG committee used.</p>
<h3 id="parameters-34"><a class="header" href="#parameters-34">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-38"><a class="header" href="#examples-38">Examples</a></h3>
<h4 id="curl-37"><a class="header" href="#curl-37">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/drng/info/committee
</code></pre>
<h4 id="client-lib---getcommittee"><a class="header" href="#client-lib---getcommittee">Client lib - <code>GetCommittee</code></a></h4>
<p>Available committees can be retrieved using <code>GetCommittee() (*jsonmodels.CommitteeResponse, error)</code>.</p>
<pre><code class="language-go">committees, err := goshimAPI.GetCommittee()
if err != nil {
    // return error
}

// list committees
for _, m := range committees.Committees {
    fmt.Println(&quot;committee ID: &quot;, m.InstanceID, &quot;distributed PK:&quot;, m.DistributedPK)
}
</code></pre>
<h3 id="response-example-2"><a class="header" href="#response-example-2">Response example</a></h3>
<pre><code class="language-json">{
    &quot;committees&quot;: [
        {
            &quot;instanceID&quot;: 1,
            &quot;threshold&quot;: 3,
            &quot;identities&quot;: [
                &quot;AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG&quot;,
                &quot;FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z&quot;,
                &quot;GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P&quot;,
                &quot;4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7&quot;,
                &quot;64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga&quot;
            ],
            &quot;distributedPK&quot;: &quot;884bc65f1d023d84e2bd2e794320dc29600290ca7c83fefb2455dae2a07f2ae4f969f39de6b67b8005e3a328bb0196de&quot;
        }
    ]
}
</code></pre>
<h3 id="results-35"><a class="header" href="#results-35">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>committees</code></td><td align="left"><code>[]Committee</code></td><td align="left">A list of DRNG committees.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<ul>
<li>Type <code>Committee</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>instanceID</code></td><td align="left"><code>string</code></td><td align="left">The identifier of the dRAND instance.</td></tr>
<tr><td align="left"><code>threshold</code></td><td align="left"><code>string</code></td><td align="left">The threshold of the secret sharing protocol.</td></tr>
<tr><td align="left"><code>identities</code></td><td align="left"><code>float64</code></td><td align="left">The nodes' identities of the committee members.</td></tr>
<tr><td align="left"><code>distributedPK</code></td><td align="left"><code>string</code></td><td align="left">Distributed Public Key of the committee</td></tr>
</tbody></table>
<h2 id="drnginforandomness"><a class="header" href="#drnginforandomness"><code>/drng/info/randomness</code></a></h2>
<p>Returns the current DRNG randomness used.</p>
<h3 id="parameters-35"><a class="header" href="#parameters-35">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-39"><a class="header" href="#examples-39">Examples</a></h3>
<h4 id="curl-38"><a class="header" href="#curl-38">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/drng/info/randomness
</code></pre>
<h4 id="client-lib---getrandomness"><a class="header" href="#client-lib---getrandomness">client lib - <code>GetRandomness</code></a></h4>
<p>Current randomness from known committees can be retrieved using <code>GetRandomness() (*jsonmodels.RandomnessResponse,  error)</code>.</p>
<pre><code class="language-go">randomness, err := goshimAPI.GetRandomness()
if err != nil {
    // return error
}

// list randomness
for _, m := range randomness.Randomness {
    fmt.Println(&quot;committee ID: &quot;, m.InstanceID, &quot;Randomness:&quot;, m.Randomness)
}
</code></pre>
<h3 id="response-example-3"><a class="header" href="#response-example-3">Response example</a></h3>
<pre><code class="language-json">{
    &quot;randomness&quot;: [
        {
            &quot;instanceID&quot;: 1,
            &quot;round&quot;: 2461530,
            &quot;timestamp&quot;: &quot;2021-05-24T18:06:20.394849622+02:00&quot;,
            &quot;randomness&quot;: &quot;Kr5buSEtgLuPxZrax0HfoiougcOXS/75JOBu2Ld6peO77qdKiNyjDueXQZlPE0UCTKkVhehEvfIXhESK9DF3aQ==&quot;
        }
    ]
}
</code></pre>
<h3 id="results-36"><a class="header" href="#results-36">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>randomness</code></td><td align="left"><code>[]Randomness</code></td><td align="left">List of randomness</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<ul>
<li>Type <code>Randomness</code></li>
</ul>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>instanceID</code></td><td align="left"><code>uint32</code></td><td align="left">The identifier of the dRAND instance.</td></tr>
<tr><td align="left"><code>round</code></td><td align="left"><code>uint64</code></td><td align="left">The current DRNG round.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left"><code>time.Time</code></td><td align="left">The timestamp of the current randomness message</td></tr>
<tr><td align="left"><code>randomness</code></td><td align="left"><code>[]byte</code></td><td align="left">The current randomness as a slice of bytes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapshot-api-methods"><a class="header" href="#snapshot-api-methods">Snapshot API Methods</a></h1>
<p>Snapshot API allows retrieving current snapshot.</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/snapshot.html#snapshot">/snapshot</a></li>
</ul>
<h2 id="snapshot"><a class="header" href="#snapshot"><code>/snapshot</code></a></h2>
<p>Returns a snapshot file.</p>
<h3 id="parameters-36"><a class="header" href="#parameters-36">Parameters</a></h3>
<p>None</p>
<h3 id="examples-40"><a class="header" href="#examples-40">Examples</a></h3>
<h4 id="curl-39"><a class="header" href="#curl-39">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/snapshot'
</code></pre>
<h4 id="client-lib-3"><a class="header" href="#client-lib-3">Client lib</a></h4>
<p>Method not available in the client library.</p>
<h4 id="results-37"><a class="header" href="#results-37">Results</a></h4>
<p>Snapshot file is returned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faucet-api-methods"><a class="header" href="#faucet-api-methods">Faucet API Methods</a></h1>
<p>Faucet endpoint allows requesting funds from the Faucet.</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/faucet.html#faucet">/faucet</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/faucet.html#client-lib---sendfaucetrequest">SendFaucetRequest()</a></li>
</ul>
<h2 id="faucet-1"><a class="header" href="#faucet-1"><code>/faucet</code></a></h2>
<p>Method: <code>POST</code></p>
<p>POST request asking for funds from the faucet to be transferred to address in the request.</p>
<h3 id="parameters-37"><a class="header" href="#parameters-37">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>address</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>address to pledge funds to</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>accessManaPledgeID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>node ID to pledge access mana to</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>consensusManaPledgeID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>node ID to pledge consensus mana to</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>powTarget</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>proof of the PoW being done, <strong>only used in HTTP api</strong></td></tr>
<tr><td><strong>Type</strong></td><td>uint64</td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>nonce</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>target Proof of Work difficulty,<strong>only used in client lib</strong></td></tr>
<tr><td><strong>Type</strong></td><td>uint64</td></tr>
</tbody></table>
<h4 id="body-3"><a class="header" href="#body-3">Body</a></h4>
<pre><code class="language-json">{
  &quot;address&quot;: &quot;target address&quot;,
  &quot;accessManaPledgeID&quot;: &quot;nodeID&quot;,
  &quot;consensusManaPledgeID&quot;: &quot;nodeID&quot;,
  &quot;nonce&quot;: 50
}

</code></pre>
<h3 id="examples-41"><a class="header" href="#examples-41">Examples</a></h3>
<h4 id="curl-40"><a class="header" href="#curl-40">cURL</a></h4>
<pre><code class="language-shell">curl --location --request POST 'http://localhost:8080/faucet' \
--header 'Content-Type: application/json' \
--data-raw '{
	&quot;address&quot;: &quot;target address&quot;,
	&quot;accessManaPledgeID&quot;: &quot;nodeID&quot;,
	&quot;consensusManaPledgeID&quot;: &quot;nodeID&quot;,
  &quot;nonce&quot;: 50
}'
</code></pre>
<h4 id="client-lib---sendfaucetrequest"><a class="header" href="#client-lib---sendfaucetrequest">Client lib - SendFaucetRequest</a></h4>
<h5 id="sendfaucetrequestbase58encodedaddr-string-powtarget-int-pledgeids-string-jsonmodelsfaucetresponse-error"><a class="header" href="#sendfaucetrequestbase58encodedaddr-string-powtarget-int-pledgeids-string-jsonmodelsfaucetresponse-error"><code>SendFaucetRequest(base58EncodedAddr string, powTarget int, pledgeIDs ...string) (*jsonmodels.FaucetResponse, error)</code></a></h5>
<pre><code class="language-go">_, err = webConnector.client.SendFaucetRequest(addr.Address().Base58(), powTarget)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-examples-31"><a class="header" href="#response-examples-31">Response examples</a></h3>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc&quot; 
}
</code></pre>
<h3 id="results-38"><a class="header" href="#results-38">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>id</code></td><td align="left"><code>string</code></td><td align="left">Message ID of the faucet request. Omitted if error.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spammer-api-methods"><a class="header" href="#spammer-api-methods">Spammer API Methods</a></h1>
<p>The Spammer tool lets you add messages to the tangle when running GoShimmer.
<strong>Note:</strong> Make sure you enable the <strong>spammer plugin</strong> before interacting with the API.</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/spammer.html#spammer">/spammer</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/spammer.html#client-lib---togglespammer">ToggleSpammer()</a></li>
</ul>
<h2 id="spammer"><a class="header" href="#spammer"><code>/spammer</code></a></h2>
<p>In order to start the spammer, you need to send GET requests to a <code>/spammer</code> API endpoint with the following parameters:</p>
<h3 id="parameters-38"><a class="header" href="#parameters-38">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>cmd</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>Action to perform. One of two possible values: <code>start</code> and <code>stop</code>.</td></tr>
<tr><td><strong>Type</strong></td><td><code>string</code></td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>mpm</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>Messages per minute. Only applicable when <code>cmd=start</code>. (default: 1)</td></tr>
<tr><td><strong>Type</strong></td><td><code>int</code></td></tr>
</tbody></table>
</br>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>imif</code> (Inter Message Issuing Function)</th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>Parameter indicating time interval between issued messages. Possible values: <code>poisson</code>, <code>uniform</code>. Field only available in HTTP API.</td></tr>
<tr><td><strong>Type</strong></td><td><code>string</code></td></tr>
</tbody></table>
<p>Description of <code>imif</code> values:</p>
<ul>
<li><code>poisson</code> - emit messages modeled with Poisson point process, whose time intervals are exponential variables with mean 1/rate</li>
<li><code>uniform</code> - issues messages at constant rate </li>
</ul>
<h3 id="examples-42"><a class="header" href="#examples-42">Examples</a></h3>
<h4 id="curl-41"><a class="header" href="#curl-41">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/spammer?cmd=start&amp;mpm=1000'
curl --location 'http://localhost:8080/spammer?cmd=start&amp;mpm=1000&amp;imif=uniform'
curl --location 'http://localhost:8080/spammer?cmd=shutdown'
</code></pre>
<h4 id="client-lib---togglespammer"><a class="header" href="#client-lib---togglespammer">Client lib - <code>ToggleSpammer()</code></a></h4>
<p>Spammer can be enabled and disabled via <code>ToggleSpammer(enable bool, mpm int) (*jsonmodels.SpammerResponse, error)</code></p>
<pre><code class="language-go">res, err := goshimAPI.ToggleSpammer(true, 100)
if err != nil {
    // return error
}

// will print the response
fmt.Println(res.Message)
</code></pre>
<h4 id="response-examples-32"><a class="header" href="#response-examples-32">Response examples</a></h4>
<pre><code class="language-json">{&quot;message&quot;: &quot;started spamming messages&quot;}
</code></pre>
<h4 id="results-39"><a class="header" href="#results-39">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>message</code></td><td align="left"><code>string</code></td><td align="left">Message with resulting message.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-api-methods"><a class="header" href="#tools-api-methods">Tools API Methods</a></h1>
<p>Tools API allows retrieving technical info about the state of the node.</p>
<p>The API provides the following functions and endpoints:</p>
<ul>
<li><a href="apis/tools.html#toolsmessagepastcone">/tools/message/pastcone</a></li>
<li><a href="apis/tools.html#toolsmessagemissing">/tools/message/missing</a></li>
<li><a href="apis/tools.html#tools/message/approval">/tools/message/approval</a></li>
<li><a href="apis/tools.html#toolsmessageorphanage">/tools/message/orphanage</a></li>
<li><a href="apis/tools.html#toolsdiagnosticmessages">tools/diagnostic/messages</a></li>
<li><a href="apis/tools.html#toolsdiagnosticmessagesfirstweakreferences">tools/diagnostic/messages/firstweakreferences</a></li>
<li><a href="apis/tools.html#toolsdiagnosticmessagesrankrank">tools/diagnostic/messages/rank/:rank</a></li>
<li><a href="apis/tools.html#toolsdiagnosticutxodag">tools/diagnostic/utxodag</a></li>
<li><a href="apis/tools.html#toolsdiagnosticbranches">tools/diagnostic/branches</a></li>
<li><a href="apis/tools.html#toolsdiagnosticbrancheslazybooked">tools/diagnostic/branches/lazybooked</a></li>
<li><a href="apis/tools.html#toolsdiagnosticbranchesinvalid">tools/diagnostic/branches/invalid</a></li>
<li><a href="apis/tools.html#toolsdiagnostictips">tools/diagnostic/tips</a></li>
<li><a href="apis/tools.html#toolsdiagnostictipsstrong">tools/diagnostic/tips/strong</a></li>
<li><a href="apis/tools.html#toolsdiagnostictipsweak">tools/diagnostic/tips/weak</a></li>
<li><a href="apis/tools.html#toolsdiagnosticdrng">tools/diagnostic/drng</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/tools.html#client-lib---pastconeexist">PastConeExist()</a></li>
<li><a href="apis/tools.html#client-lib---missing">Missing()</a></li>
</ul>
<h2 id="toolsmessagepastcone"><a class="header" href="#toolsmessagepastcone"><code>/tools/message/pastcone</code></a></h2>
<p>Checks that all the messages in the past cone of a message are existing on the node down to the genesis. Returns the number of messages in the past cone as well.</p>
<h3 id="parameters-39"><a class="header" href="#parameters-39">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>ID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>Message ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-43"><a class="header" href="#examples-43">Examples</a></h3>
<h4 id="curl-42"><a class="header" href="#curl-42">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/message/pastcone?ID=4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc'
</code></pre>
<h4 id="client-lib---pastconeexist"><a class="header" href="#client-lib---pastconeexist">Client lib - <code>PastConeExist()</code></a></h4>
<p>Past cone can be checked using <code>PastConeExist(base58EncodedMessageID string) (*jsonmodels.PastconeResponse, error)</code></p>
<pre><code class="language-go">pastConeCheck, err := goshimAPI.PastConeExist(base58EncodedMessageID)
if err != nil {
    // return error
}

// will print the past cone size
fmt.Println(string(pastConeCheck.PastConeSize))
</code></pre>
<h4 id="response-examples-33"><a class="header" href="#response-examples-33">Response examples</a></h4>
<pre><code class="language-json">{
  &quot;exist&quot;: true,
  &quot;pastConeSize&quot;: 475855
}
</code></pre>
<h4 id="results-40"><a class="header" href="#results-40">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>exist</code></td><td align="left"><code>bool</code></td><td align="left">A boolean indicates if the message and its past cone exist.</td></tr>
<tr><td align="left"><code>pastConeSize</code></td><td align="left"><code>int</code></td><td align="left">Size of the past cone of the given message.</td></tr>
<tr><td align="left"><code>error</code></td><td align="left"><code>string</code></td><td align="left">Error message. Omitted if success.</td></tr>
</tbody></table>
<h2 id="toolsmessagemissing"><a class="header" href="#toolsmessagemissing"><code>/tools/message/missing</code></a></h2>
<p>Returns all the missing messages and their count.</p>
<h3 id="parameters-40"><a class="header" href="#parameters-40">Parameters</a></h3>
<p>None</p>
<h3 id="examples-44"><a class="header" href="#examples-44">Examples</a></h3>
<h4 id="curl-43"><a class="header" href="#curl-43">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/message/missing'
</code></pre>
<h4 id="client-lib---missing"><a class="header" href="#client-lib---missing">Client lib - <code>Missing()</code></a></h4>
<p>Missing messages can be retrieved using <code>Missing() (*jsonmodels.MissingResponse, error)</code>.</p>
<pre><code class="language-go">missingMsgs, err := goshimAPI.Missing()
if err != nil {
    // return error
}

// will print number of missing messages
fmt.Println(string(missingMsgs.Count))
</code></pre>
<h4 id="response-examples-34"><a class="header" href="#response-examples-34">Response examples</a></h4>
<pre><code class="language-json">{
  &quot;ids&quot;: [],
  &quot;count&quot;: 0
}
</code></pre>
<h4 id="results-41"><a class="header" href="#results-41">Results</a></h4>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>ids</code></td><td align="left"><code>[]string</code></td><td align="left">List of missing messages' IDs.</td></tr>
<tr><td align="left"><code>count</code></td><td align="left"><code>int</code></td><td align="left">Count of missing messages.</td></tr>
</tbody></table>
<h2 id="toolsmessageapproval"><a class="header" href="#toolsmessageapproval"><code>/tools/message/approval</code></a></h2>
<p>Returns the first approver of all messages.</p>
<h3 id="parameters-41"><a class="header" href="#parameters-41">Parameters</a></h3>
<p>None</p>
<h3 id="examples-45"><a class="header" href="#examples-45">Examples</a></h3>
<h4 id="curl-44"><a class="header" href="#curl-44">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/message/approval'
</code></pre>
<h4 id="response-examples-35"><a class="header" href="#response-examples-35">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<h2 id="toolsmessageorphanage"><a class="header" href="#toolsmessageorphanage"><code>tools/message/orphanage</code></a></h2>
<p>Returns orphaned messages of the future cone of the given message ID.</p>
<h3 id="parameters-42"><a class="header" href="#parameters-42">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>msgID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>required</td></tr>
<tr><td><strong>Description</strong></td><td>Message ID encoded in Bases58</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-46"><a class="header" href="#examples-46">Examples</a></h3>
<h4 id="curl-45"><a class="header" href="#curl-45">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/message/orphanage?msgID=4MSkwAPzGwnjCJmTfbpW4z4GRC7HZHZNS33c2JikKXJc'
</code></pre>
<h4 id="response-examples-36"><a class="header" href="#response-examples-36">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code class="language-json">MsgID,MsgIssuerID,MsgIssuanceTime,MsgArrivalTime,MsgSolidTime,MsgApprovedBy,

...

7h7arHrxYhuuzgpvRtuw6jn5AwtAA5AEiKnAzdQheyDW,dAnF7pQ6k7a,1622100376301474621,1622100390350323240,1622100390350376317,true
</code></pre>
<h2 id="toolsdiagnosticmessages"><a class="header" href="#toolsdiagnosticmessages"><code>tools/diagnostic/messages</code></a></h2>
<p>Returns all the messages in the storage.</p>
<h3 id="parameters-43"><a class="header" href="#parameters-43">Parameters</a></h3>
<p>None</p>
<h3 id="examples-47"><a class="header" href="#examples-47">Examples</a></h3>
<h4 id="curl-46"><a class="header" href="#curl-46">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/messages
</code></pre>
<h4 id="response-examples-37"><a class="header" href="#response-examples-37">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

7h7arHrxYhuuzgpvRtuw6jn5AwtAA5AEiKnAzdQheyDW,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622100376301474621,1622100390350323240,1622100390350376317,1622100390350655597,1622100390497058485,1622100394498368012,11111111111111111111111111111111,,E8jiyKgouhbk8GK8xNiwSnLM4FSzmCfvCmBijbKd8z8A,,BranchID(MasterBranchID),InclusionState(Confirmed),true,true,true,false,1,false,0:0,0,0,1:2,2,2,TransactionType(1337),DBejuv32xNJdZQurbitPTktm5HJML5SdnmN6ic6xQGKd,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnosticmessagesfirstweakreferences"><a class="header" href="#toolsdiagnosticmessagesfirstweakreferences"><code>tools/diagnostic/messages/firstweakreferences</code></a></h2>
<p>Returns the first weak reference of all messages in the storage.</p>
<h3 id="parameters-44"><a class="header" href="#parameters-44">Parameters</a></h3>
<p>None</p>
<h3 id="examples-48"><a class="header" href="#examples-48">Examples</a></h3>
<h4 id="curl-47"><a class="header" href="#curl-47">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/messages/firstweakreferences
</code></pre>
<h4 id="response-examples-38"><a class="header" href="#response-examples-38">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

7h7arHrxYhuuzgpvRtuw6jn5AwtAA5AEiKnAzdQheyDW,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622100376301474621,1622100390350323240,1622100390350376317,1622100390350655597,1622100390497058485,1622100394498368012,11111111111111111111111111111111,,E8jiyKgouhbk8GK8xNiwSnLM4FSzmCfvCmBijbKd8z8A,,BranchID(MasterBranchID),InclusionState(Confirmed),true,true,true,false,1,false,0:0,0,0,1:2,2,2,TransactionType(1337),DBejuv32xNJdZQurbitPTktm5HJML5SdnmN6ic6xQGKd,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnosticmessagesrankrank"><a class="header" href="#toolsdiagnosticmessagesrankrank"><code>tools/diagnostic/messages/rank/:rank</code></a></h2>
<p>Returns a list of messages with rank &gt;= of the given rank parameter.</p>
<h3 id="parameters-45"><a class="header" href="#parameters-45">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>rank</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>message rank</td></tr>
<tr><td><strong>Type</strong></td><td>uint64</td></tr>
</tbody></table>
<h3 id="examples-49"><a class="header" href="#examples-49">Examples</a></h3>
<h4 id="curl-48"><a class="header" href="#curl-48">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/messages/rank/:rank
</code></pre>
<p>where <code>:rank</code> is the uint64, e.g. 20.</p>
<h4 id="response-examples-39"><a class="header" href="#response-examples-39">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

Gk4QS3sjiuUGnXNJhd4i6ZcTE3ZtpTKAj31XnmkG3i2g,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622100453303518895,1622100453307914949,1622100453308087594,-6795364578871345152,1622100453308973957,1622100453309435279,59Y7xDxqyQmDkwFXeGwbMLVMAXFgToApdVwdewzuiSsp;BZfTFhPrvx4hh6vgX9uGiHHm3mr7UXAssieYrFZA84YC,,3KmrREsvgngdqCQGEWVxcGGMG3DwHnBXCmC8TvEvWB4R;GyoUwTsXCEDx796EgGoXm9wc6XwHdtompz4B8s8RkaLq,,BranchID(MasterBranchID),InclusionState(Confirmed),false,true,true,false,50,true,1:50,50,50,1:51,51,51,Statement(3),,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnosticutxodag"><a class="header" href="#toolsdiagnosticutxodag"><code>tools/diagnostic/utxodag</code></a></h2>
<p>Returns the information of all transactions in the storage.</p>
<h3 id="parameters-46"><a class="header" href="#parameters-46">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-50"><a class="header" href="#examples-50">Examples</a></h3>
<h4 id="curl-49"><a class="header" href="#curl-49">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/utxodag
</code></pre>
<h4 id="response-examples-40"><a class="header" href="#response-examples-40">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,IssuanceTime,SolidTime,OpinionFormedTime,AccessManaPledgeID,ConsensusManaPledgeID,Inputs,Outputs,Attachments,BranchID,BranchLiked,BranchMonotonicallyLiked,Conflicting,InclusionState,Finalized,LazyBooked,Liked,LoK,FCOB1Time,FCOB2Time

...

uNUZMoAdYZu74ZREoZr84AbYb9du1fC8vTbXpsX3rj6,1622102040372947362,1622102040419353230,1622102044420491940,2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5,2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5,DBejuv32xNJdZQurbitPTktm5HJML5SdnmN6ic6xQGKd:83,uNUZMoAdYZu74ZREoZr84AbYb9du1fC8vTbXpsX3rj6:0,3Lu696zF21tCAeqX7mEjwC1xPocWMnQVHAPMtd9CCdep,BranchID(MasterBranchID),true,true,false,InclusionState(Confirmed),true,false,true,LevelOfKnowledge(Two),1622102042419829963,1622102044420266997
</code></pre>
<h2 id="toolsdiagnosticbranches"><a class="header" href="#toolsdiagnosticbranches"><code>tools/diagnostic/branches</code></a></h2>
<p>Returns the information of all conflict and aggregated branches in the storag.</p>
<h3 id="parameters-47"><a class="header" href="#parameters-47">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-51"><a class="header" href="#examples-51">Examples</a></h3>
<h4 id="curl-50"><a class="header" href="#curl-50">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/branches
</code></pre>
<h4 id="response-examples-41"><a class="header" href="#response-examples-41">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,ConflictSet,IssuanceTime,SolidTime,OpinionFormedTime,Liked,MonotonicallyLiked,InclusionState,Finalized,LazyBooked,TransactionLiked

...

9vtFVukmqAbrNd4Y2iUPJ1XrqJofirv2Gg4BeJvQVSxu,CgN1qBu44ZsDD8WCCyvaBhRaRZPA4ioQfj86dosjLWJo;9vtFVukmqAbrNd4Y2iUPJ1XrqJofirv2Gg4BeJvQVSxu,1622102719697156578,1622102719714912166,-6795364578871345152,false,false,InclusionState(Pending),false,false,false
</code></pre>
<h2 id="toolsdiagnosticbrancheslazybooked"><a class="header" href="#toolsdiagnosticbrancheslazybooked"><code>tools/diagnostic/branches/lazybooked</code></a></h2>
<p>Returns the information of all lazy booked branches.</p>
<h3 id="parameters-48"><a class="header" href="#parameters-48">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-52"><a class="header" href="#examples-52">Examples</a></h3>
<h4 id="curl-51"><a class="header" href="#curl-51">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/branches/lazybooked
</code></pre>
<h4 id="response-examples-42"><a class="header" href="#response-examples-42">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,ConflictSet,IssuanceTime,SolidTime,OpinionFormedTime,Liked,MonotonicallyLiked,InclusionState,Finalized,LazyBooked,TransactionLiked

...

7tDqL25HYMjpuFziNGZksQ7BigCB85XqfYRskEwTovKo,,1622044058080683973,1622044102712464942,1622044102702350700,false,false,InclusionState(Rejected),false,true,false
</code></pre>
<h2 id="toolsdiagnosticbranchesinvalid"><a class="header" href="#toolsdiagnosticbranchesinvalid"><code>tools/diagnostic/branches/invalid</code></a></h2>
<p>Returns the information of all invalid branches.</p>
<h3 id="parameters-49"><a class="header" href="#parameters-49">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-53"><a class="header" href="#examples-53">Examples</a></h3>
<h4 id="curl-52"><a class="header" href="#curl-52">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/branches/invalid
</code></pre>
<h4 id="response-examples-43"><a class="header" href="#response-examples-43">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,ConflictSet,IssuanceTime,SolidTime,OpinionFormedTime,Liked,MonotonicallyLiked,InclusionState,Finalized,LazyBooked,TransactionLiked

...

7tDqL25HYMjpuFziNGZksQ7BigCB85XqfYRskEwTovKo,,1622044058080683973,1622044102712464942,1622044102702350700,false,false,InclusionState(Rejected),false,false,false
</code></pre>
<h2 id="toolsdiagnostictips"><a class="header" href="#toolsdiagnostictips"><code>tools/diagnostic/tips</code></a></h2>
<p>Returns the information of all tips.</p>
<h3 id="parameters-50"><a class="header" href="#parameters-50">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-54"><a class="header" href="#examples-54">Examples</a></h3>
<h4 id="curl-53"><a class="header" href="#curl-53">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/tips
</code></pre>
<h4 id="response-examples-44"><a class="header" href="#response-examples-44">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>tipType,ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

TipType(StrongTip),6fK6KYG8LroV5qZ6n7YSaG83Sd4rRLFqy5hYggvBZ1WU,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622103153705255685,1622103153707874989,1622103153707971187,-6795364578871345152,1622103153708819166,1622103153709133607,71NdGRvB2MFNutfQFsrcj5uMuEqv6fRw4vQ3GCqjEX9F,,,,BranchID(MasterBranchID),InclusionState(Confirmed),false,true,true,false,1987,true,3:1972,1972,1972,,0,0,Statement(3),,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnostictipsstrong"><a class="header" href="#toolsdiagnostictipsstrong"><code>tools/diagnostic/tips/strong</code></a></h2>
<p>Returns the information of all strong tips.</p>
<h3 id="parameters-51"><a class="header" href="#parameters-51">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-55"><a class="header" href="#examples-55">Examples</a></h3>
<h4 id="curl-54"><a class="header" href="#curl-54">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/tips/strong
</code></pre>
<h4 id="response-examples-45"><a class="header" href="#response-examples-45">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>tipType,ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

TipType(StrongTip),5rjGXZE5ZLhfnNS7sbgviDCCS3857Su9h8JjuQSb2zYH,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622103297295336333,1622103297297702646,1622103297297817779,-6795364578871345152,1622103297302792080,1622103297303196243,3F3KwuyLesP4zzqLLz5p3da5LqahRwygdQS7qAZkTQsZ,,,,BranchID(MasterBranchID),InclusionState(Confirmed),false,true,true,false,2088,true,3:2073,2073,2073,,0,0,GenericDataPayloadType(0),,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnostictipsweak"><a class="header" href="#toolsdiagnostictipsweak"><code>tools/diagnostic/tips/weak</code></a></h2>
<p>Returns the information of all weak tips.</p>
<h3 id="parameters-52"><a class="header" href="#parameters-52">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-56"><a class="header" href="#examples-56">Examples</a></h3>
<h4 id="curl-55"><a class="header" href="#curl-55">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/tips/weak
</code></pre>
<h4 id="response-examples-46"><a class="header" href="#response-examples-46">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>tipType,ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,FinalizedTime,StrongParents,WeakParents,StrongApprovers,WeakApprovers,BranchID,InclusionState,Scheduled,Booked,Eligible,Invalid,Finalized,Rank,IsPastMarker,PastMarkers,PMHI,PMLI,FutureMarkers,FMHI,FMLI,PayloadType,TransactionID,PayloadOpinionFormed,TimestampOpinionFormed,MessageOpinionFormed,MessageOpinionTriggered,TimestampOpinion,TimestampLoK

...

TipType(WeakTip),5rjGXZE5ZLhfnNS7sbgviDCCS3857Su9h8JjuQSb2zYH,dAnF7pQ6k7a,CHfU1NUf6ZvUKDQHTG2df53GR7CvuMFtyt7YymJ6DwS3,1622103297295336333,1622103297297702646,1622103297297817779,-6795364578871345152,1622103297302792080,1622103297303196243,3F3KwuyLesP4zzqLLz5p3da5LqahRwygdQS7qAZkTQsZ,,,,BranchID(MasterBranchID),InclusionState(Confirmed),false,true,true,false,2088,true,3:2073,2073,2073,,0,0,GenericDataPayloadType(0),,true,true,true,true,Like,LevelOfKnowledge(Two)
</code></pre>
<h2 id="toolsdiagnosticdrng"><a class="header" href="#toolsdiagnosticdrng"><code>tools/diagnostic/drng</code></a></h2>
<p>Returns the information of all dRNG messages.</p>
<h3 id="parameters-53"><a class="header" href="#parameters-53">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-57"><a class="header" href="#examples-57">Examples</a></h3>
<h4 id="curl-56"><a class="header" href="#curl-56">cURL</a></h4>
<pre><code class="language-shell">curl --location 'http://localhost:8080/tools/diagnostic/drng
</code></pre>
<h4 id="response-examples-47"><a class="header" href="#response-examples-47">Response examples</a></h4>
<p>The response is written in a csv file.</p>
<pre><code>ID,IssuerID,IssuerPublicKey,IssuanceTime,ArrivalTime,SolidTime,ScheduledTime,BookedTime,OpinionFormedTime,dRNGPayloadType,InstanceID,Round,PreviousSignature,Signature,DistributedPK

...

BsSw31y4BufNoPp93TRfgDfXdrjnevsm7Up2mHtybzdK,CRPFWYijV1T,GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo,1621963390710701221,1621963391011675455,1621963391011749004,1621963391011818075,1621963391011903917,1621963391012012853,dRNG(111),1339,2210960,us8vrWKdKtNvXdx424hgqGYpM65Cs2KAGmAyhinCncn6PQ8Dv4hLh1rZ3ugvk2QZkGofJhwNvx2EmD5Vzcz3RQTowfiNBTpLJYEUM4swAPXaFwSGntWhvWDYtpyHrXtGtBP,24LuByAUakW36DmEyCz58Ld5utTeKh3zCUbJ4mn6Eo6rZmhb7wnZnjQN3KMm59TjHwSm158iAviP1fS2mc2kuMc4Vf2k4M88hgN1reCUVGn5ufwxHmMEAZVXi82L2k6XLxNY,6HbdGdict6Egw8gwBRYmdgrMWt46qw1LtqkVk51D4sQx51XMDNEbsX6mcXZ1PjJJDy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<p>GoShimmer comes with some tools to test the stability of the protocol. </p>
<p>We provide a documentation for the following tools:</p>
<ul>
<li>The <a href="./tooling/docker_private_network.html">docker private network</a> with which a local test network can be set up locally with docker.</li>
<li>The <a href="./tooling/integration_tests.html">integration tests</a> spins up a <code>tester</code> container within which every test can specify its own GoShimmer network with Docker.</li>
<li>The <a href="./tutorials/wallet.html">cli-wallet</a> is described as part of the tutorial section.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-private-network"><a class="header" href="#docker-private-network">Docker private network</a></h1>
<p>We provide a tool at <code>tools/docker-network</code> with which a local test network can be set up locally with docker. </p>
<p><img src="tooling/./docker-network.png" alt="Docker network" /></p>
<h2 id="how-to-use-the-tool"><a class="header" href="#how-to-use-the-tool">How to use the tool</a></h2>
<p>In the docker network run for example</p>
<pre><code>./run.sh 5 1 1
</code></pre>
<p>The command <code>./run.sh</code> spins up a GoShimmer network within Docker as schematically shown in the figure above. The first integer input defines the number of <code>peer_replicas</code> <code>N</code>. The second argument is optional for activating the Grafana dashboard, where </p>
<ul>
<li>default (no argument) or 0: Grafana disabled</li>
<li>1: Grafana enabled</li>
</ul>
<p>More details on how to set up the dashboard can be found <a href="tooling/../tutorials/setup.html">here</a>.</p>
<p>The third argument is optional for activating a dRNG committee, where</p>
<ul>
<li>default (no argument) or 0: dRNG disabled</li>
<li>1: dRNG enabled</li>
</ul>
<p>The peers can communicate freely within the Docker network 
while the analysis and visualizer dashboard, as well as the <code>master_peer's</code> dashboard and web API are reachable from the host system on the respective ports.</p>
<p>The settings for the different containers (<code>entry_node</code>, <code>peer_master</code>, <code>peer_replica</code>) can be modified in <code>docker-compose.yml</code>.</p>
<h2 id="how-to-use-as-development-tool"><a class="header" href="#how-to-use-as-development-tool">How to use as development tool</a></h2>
<p>Using a standalone throwaway Docker network can be really helpful as a development tool. </p>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<p>Reachable from the host system</p>
<ul>
<li>analysis dashboard (autopeering visualizer): http://localhost:9000</li>
<li><code>master_peer's</code> dashboard: http: http://localhost:8081</li>
<li><code>master_peer's</code> web API: http: http://localhost:8080</li>
</ul>
<p>It is therefore possible to send messages to the local network via the <code>master_peer</code>. Log messages of a specific containter can be followed via </p>
<pre><code>docker logs --follow CONTAINERNAME
</code></pre>
<h2 id="snapshot-tool"><a class="header" href="#snapshot-tool">Snapshot tool</a></h2>
<p>A snapshot tool is provided in the tools folder. The snapshot file that is created must be moved into the <code>integration-tests/assets</code> folder. There, rename and replace the existing bin file (<code>7R1itJx5hVuo9w9hjg5cwKFmek4HMSoBDgJZN8hKGxih.bin</code>). After restarting the docker network the snapshot file will be loaded.</p>
<h2 id="how-to-use-message-approval-check-tool"><a class="header" href="#how-to-use-message-approval-check-tool">How to use message approval check tool</a></h2>
<p><code>get_approval_csv.sh</code> script helps you conveniently trigger the message approval checks on all nodes in the docker
network, and gather their results in the <code>csv</code> folder.</p>
<p>Once the network is up and running, execute the script:</p>
<pre><code>./get_approval_csv.sh
</code></pre>
<p>Example output:</p>
<pre><code>Triggering approval analysis on peer_master and 20 replicas...
Triggering approval analysis on peer_master and 20 replicas... DONE
Copying csv files from peer_master and 20 replicas...
Copying csv files from peer_master and 20 replicas... DONE
Copied files are located at ./csv
</code></pre>
<p>The exported csv files are timestamped to the date of request.</p>
<pre><code>csv
├── 210120_16_34_14-docker-network_peer_replica_10.csv
├── 210120_16_34_14-docker-network_peer_replica_11.csv
├── 210120_16_34_14-docker-network_peer_replica_12.csv
...
</code></pre>
<p>Note, that the record length of the files might differ, since the approval check execution time of the nodes might differ.</p>
<h2 id="spammer-tool"><a class="header" href="#spammer-tool">Spammer tool</a></h2>
<p>The Spammer tool lets you add messages to the tangle when running GoShimmer in a Docker network.
In order to start the spammer, you need to send GET requests to a <code>/spammer</code> API endpoint with the following parameters:</p>
<ul>
<li><code>cmd</code> - one of two possible values: <code>start</code> and <code>stop</code>.</li>
<li><code>mpm</code> - messages per minute. Only applicable when <code>cmd=start</code>. </li>
<li><code>imif</code> - (<em>optional</em>) parameter indicating time interval between issued messages. Possible values:
<ul>
<li><code>poisson</code> - emit messages modeled with Poisson point process, whose time intervals are exponential variables with mean 1/rate</li>
<li><code>uniform</code> - issues messages at constant rate</li>
</ul>
</li>
</ul>
<p>Example requests:</p>
<pre><code class="language-bash">http://localhost:8080/spammer?cmd=start&amp;mpm=1000

http://localhost:8080/spammer?cmd=start&amp;mpm=1000&amp;imif=uniform
http://localhost:8080/spammer?cmd=stop
</code></pre>
<h2 id="tangle-width"><a class="header" href="#tangle-width">Tangle width</a></h2>
<p>When running GoShimmer locally in a Docker network, the network delay is so small that only 1 tip will be available most of the time. 
In order to artificially create a tangle structure with multiple tips you can add a <code>messageLayer.tangleWidth</code> property to <a href="tooling/tools/docker-network/config.docker.json">config.docker.json</a>
that specifies the number of tips that nodes should retain. This setting exists only for local testing purposes and should not be used in a distributed testnet.</p>
<p>Here is an example config that can be added: </p>
<pre><code class="language-json">  &quot;messageLayer&quot;: {
    &quot;tangleWidth&quot;: 10
  },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests-with-docker"><a class="header" href="#integration-tests-with-docker">Integration tests with Docker</a></h1>
<p><img src="tooling/./integration-testing.png" alt="Integration testing" /></p>
<p>Running the integration tests spins up a <code>tester</code> container within which every test can specify its own GoShimmer network with Docker as schematically shown in the figure above.</p>
<p>Peers can communicate freely within their Docker network and this is exactly how the tests are run using the <code>tester</code> container.
Test can be written in regular Go style while the framework provides convenience functions to create a new network, access a specific peer's web API or logs.</p>
<h2 id="how-to-run"><a class="header" href="#how-to-run">How to run</a></h2>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<pre><code># Mac &amp; Linux
cd tools/integration-tests
./runTests.sh
</code></pre>
<p>The tests produce <code>*.log</code> files for every networks' peer in the <code>logs</code> folder after every run.</p>
<p>On GitHub logs of every peer are stored as artifacts and can be downloaded for closer inspection once the job finishes.</p>
<h2 id="creating-tests"><a class="header" href="#creating-tests">Creating tests</a></h2>
<p>Tests can be written in regular Go style. Each tested component should reside in its own test file in <code>tools/integration-tests/tester/tests</code>.
<code>main_test</code> with its <code>TestMain</code> function is executed before any test in the package and initializes the integration test framework.</p>
<p>Each test has to specify its network where the tests are run. This can be done via the framework at the beginning of a test.</p>
<pre><code class="language-go">// create a network with name 'testnetwork' with 6 peers and wait until every peer has at least 3 neighbors
n := f.CreateNetwork(&quot;testnetwork&quot;, 6, 3)
// must be called to create log files and properly clean up
defer n.Shutdown() 
</code></pre>
<h2 id="other-tips"><a class="header" href="#other-tips">Other tips</a></h2>
<p>Useful for development is to only execute the test you're currently building. For that matter, simply modify the <code>docker-compose.yml</code> file as follows:</p>
<pre><code class="language-yaml">entrypoint: go test ./tests -run &lt;YOUR_TEST_NAME&gt; -v -mod=readonly
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="team-resources"><a class="header" href="#team-resources">Team resources</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-do-a-release"><a class="header" href="#how-to-do-a-release">How to do a release</a></h1>
<ol>
<li>Create a PR into <code>develop</code> updating the banner version (<code>plugins/banner.AppVersion</code>) and mentioning the changes in <code>CHANGELOG.md</code></li>
<li>Create a PR merging <code>develop</code> into <code>master</code></li>
<li>Create a release via the release page with the same changelog entries as in <code>CHANGELOG.md</code> for the given version tagging the <code>master</code> branch</li>
<li>Pray that the CI gods let the build pass</li>
<li>Check that the binaries are working</li>
<li>Stop the entry-node</li>
<li>Delete DB</li>
<li>Update version in docker-compose</li>
<li>Pull newest image</li>
<li>Start the node</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-guidelines"><a class="header" href="#code-guidelines">Code guidelines</a></h1>
<h2 id="general-guidelines"><a class="header" href="#general-guidelines">General guidelines</a></h2>
<ul>
<li>Don’t use <code>log.Fatal()</code> or <code>os.Exit()</code> outside of the main. It immediately terminates the program and all defers are ignored and no graceful shutdown is possible. It can lead to inconsistencies. Propagate the error up to the main and let the main function exit instead. Avoid panics as well, almost always use errors. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/autopeering/autopeering.go#L135">Example</a>.</li>
<li>Don’t duplicate code, reuse it. In tests too. Example: <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L969">duplicate1</a> and <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L1053">duplicate2</a></li>
<li>Unhandled errors can cause bugs and make it harder to diagnose problems. Try to handle all errors: propagate them to the caller or log them. Even if the function call is used with a defer, and it’s inconvenient to handle the error it returns, still handle it. Wrap the function call in an anonymous function assign error to the upper error  like that:</li>
</ul>
<pre><code class="language-go">    defer func() {
        cerr := f.Close()
        if err == nil {
            err = errors.Wrap(cerr, &quot;failed to close file&quot;)
        }
    }()
</code></pre>
<ul>
<li>Wrap errors with <code>errors.Wrap()</code> when returning them to the caller. It adds the stack trace and a custom message to the error. Without that information investigating an issue is very hard.</li>
<li>Use <code>errors.Is()</code> instead of direct errors comparison. This function unwraps errors recursively. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-05fdc081489a8d5a61224d812f9bbd7bc77edf9769ed00d95ea024d2a44a699aL62">Example</a>.</li>
<li>Propagate <code>ctx</code> and use APIs that accept <code>ctx</code>, start exposing APIs that accept <code>ctx</code>. Context is a native way for timeouts/cancellation in Go. It allows writing more resilient and fault tolerant code. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f2820ed0d3d4d9ea05b78b1dd3978dbcf9401c8caaa8cc40cc1c0342a55379fcL35">Example</a>.</li>
<li>Don’t shadow builtin functions like copy, len, new etc. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f07268750a44da26386469c1b1e93574a678c3d418fce9e1f186d5f1991a92eaL14">Example</a>.</li>
<li>Don’t shadow imported packages. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/webapi/value/sendtransactionbyjson.go#L172">Example</a>.</li>
<li>Don’t do <code>[:]</code> on a slice. It has no effect. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-299a1ac5fa09739ea07b7c806ee2785d83eea110f8af143dbc853a25e4819116L133">Example</a>.</li>
<li>Avoid naked returns if the function isn’t very small. It makes the code more readable.</li>
<li>Define explicit constants for strings that are used 3 times or more. It makes the code more maintainable.</li>
<li>Define explicit constants for all numbers. It makes the code more readable.</li>
<li>Don’t write really long and complex functions. Split them into smaller ones.</li>
<li>Treat comments as regular text/documentation. Start with a capital letter, set space after <code>//</code> and end them with a dot. It’s a good habit since Go package docs are generated automatically from the comments and displayed on the godoc site.</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>We use the new error wrapping API and behavior introduced with Go 1.13 but we use the &quot;github.com/cockroachdb/errors&quot; drop-in replacement which follows the Go 2 design draft and which enables us to have a stack trace for every &quot;wrapping&quot; of the error.</p>
<p>Errors should always be wrapped and annotated with an additional message at each step. The following example shows how errors are wrapped and turned into the corresponding sentinel errors.</p>
<pre><code class="language-go">package example

import (
    &quot;3rdPartyLibrary&quot;

    &quot;github.com/cockroachdb/errors&quot;
)

// define error variables to make errors identifiable (sentinel errors)
var ErrSentinel = errors.New(&quot;identifiable error&quot;)

// turn anonymous 3rd party errors into identifiable ones
func SentinelErrFrom3rdParty() (result interface{}, err error)
    if result, err = 3rdPartyLibrary.DoSomething(); err != nil {
        err = errors.Errorf(&quot;failed to do something (%v): %w&quot;, err, ErrSentinel)
        return
    }

    return
}

// wrap recursive errors at each step
func WrappedErrFromInternalCall() error {
    return errors.Errorf(&quot;wrapped internal error: %w&quot;, SentinelErrFrom3rdParty())
}

// create &quot;new&quot; identifiable internal errors that are not originating in 3rd party libs
func ErrFromInternalCall() error {
    return errors.Errorf(&quot;internal error: %w&quot;, ErrSentinel)
}

// main function
func main() {
    err1 := WrappedErrFromInternalCall()
    if errors.Is(err1, ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err1)
    }

    err2 := ErrFromInternalCall()
    if errors.Is(err2 , ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err2 )
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golangci-lint"><a class="header" href="#golangci-lint">golangci-lint</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>We use golangci-lint v1.38.0 to run various types of linters on our codebase. All settings are stored in the <code>.golangci.yml</code> file.
golangci-lint is very flexible and customizable. Check the docs to see how configuration works https://golangci-lint.run/usage/configuration/</p>
<h2 id="how-to-run-1"><a class="header" href="#how-to-run-1">How to run</a></h2>
<ol>
<li>Install the golangci-lint program https://golangci-lint.run/usage/install/</li>
<li>In the project root: <code>golangci-lint run</code></li>
</ol>
<h2 id="dealing-with-errors"><a class="header" href="#dealing-with-errors">Dealing with errors</a></h2>
<p>Most of the errors that golangci-lint reports are errors from formatting linters like <code>gofmt</code>, <code>goimports</code> and etc. You can easily auto-fix them with:</p>
<pre><code>golangci-lint run --fix
</code></pre>
<p>Here is the full list of linters that support the auto-fix feature: <code>gofmt</code>, <code>gofumpt</code>, <code>goimports</code>, <code>misspell</code>, <code>whitespace</code>.</p>
<p>In case it's not a formatting error, do your best to fix it first. If you think it's a false alarm there are a few ways how to disable that check in golangci-lint:</p>
<ul>
<li>Exclude the check by the error text regexp. Example: <code>'Error return value of .((os\.)?std(out|err)\..*|.*Close|.*Flush|os\.Remove(All)?|.*print(f|ln)?|os\.(Un)?Setenv). is not checked'</code>.</li>
<li>Exclude the entire linter for that file type. Example: don't run <code>errcheck</code> in Go test files.</li>
<li>Change linter settings to make it more relaxed. </li>
<li>Disable that particular error occurrence: use a comment with a special <code>nolint</code> directive next to the place in code with the error. Example: <code>// nolint: errcheck</code>.</li>
</ul>
<h1 id="docker-1"><a class="header" href="#docker-1">Docker</a></h1>
<h2 id="building-image"><a class="header" href="#building-image">Building image</a></h2>
<p>We use the new buildkit docker engine to build <code>iotaledger/goshimmer</code> image. 
The minimum required docker version that supports this feature is <code>18.09</code>. 
To enable buildkit engine in your local docker add the following to the docker configuration json file:</p>
<pre><code class="language-json">{ &quot;features&quot;: { &quot;buildkit&quot;: true } }
</code></pre>
<p>Check this <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#to-enable-buildkit-builds">article</a> for details on how to do that.</p>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<p>If you are getting an error like that during the docker build:</p>
<pre><code class="language-dockerfile">Step 10/17 : RUN --mount=target=.     --mount=type=cache,target=/root/.cache/go-build     CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh
 ---&gt; Running in ecdae1c9339d
no Go files in /goshimmer
/bin/sh: 1: ./check_static.sh: not found
The command '/bin/sh -c CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh' returned a non-zero code: 127
</code></pre>
<p>It means that buildkit feature doesn't work in your docker. 
If you already enabled it in the configuration json file as described above and docker version is <code>18.09</code> or higher, 
try to set the following env variables when building the docker image:</p>
<pre><code>DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 docker build -t iotaledger/goshimmer .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goshimmer-analysis-dashboard"><a class="header" href="#goshimmer-analysis-dashboard">GoShimmer Analysis Dashboard</a></h1>
<p>Programmed using modern web technologies.</p>
<h3 id="dashboard-in-dev-mode"><a class="header" href="#dashboard-in-dev-mode">Dashboard in dev mode</a></h3>
<ol>
<li>Make sure to set <code>analysis.dashboard.dev</code> to true, to enable GoShimmer to serve assets
from the webpack-dev-server.</li>
<li>Install all needed npm modules via <code>yarn install</code>.</li>
<li>Run a webpack-dev-server instance by running <code>yarn start</code> within the <code>frontend</code> directory.</li>
<li>Using default port config, you should now be able to access the analysis dashboard under http://127.0.0.1:8000</li>
</ol>
<p>The Analysis Dashboard is hot-reload enabled.</p>
<h3 id="pack-your-changes"><a class="header" href="#pack-your-changes">Pack your changes</a></h3>
<p>We are using <a href="https://github.com/markbates/pkger">pkger</a> to wrap all built frontend files into Go files.</p>
<ol>
<li>
<p><a href="https://github.com/markbates/pkger">Install <code>pkger</code></a> if not already done.</p>
</li>
<li>
<p>Check that the correct webpack-cli (version v3.3.11) is installed: </p>
<p>2.1 <code>yarn webpack-cli --version</code></p>
<p>2.2 If a newer version is installed use <code>yarn remove webpack-cli</code> and <code>yarn add webpack-cli@3.3.11</code> </p>
</li>
<li>
<p>Build Analysis Dashboard by running <code>yarn build</code> within the <code>frontend</code> directory.</p>
</li>
<li>
<p>Navigate to the root of the repo.</p>
</li>
<li>
<p>Run <code>pkger</code> in the root of the repo.</p>
</li>
<li>
<p><code>pkged.go</code> should have been modified.</p>
</li>
<li>
<p>Done. Now you can build GoShimmer and your Analysis Dashboard changes will be included within the binary.</p>
</li>
</ol>
<p>The above steps can also be done by running the <code>scripts/pkger.sh</code> script from the root folder.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
