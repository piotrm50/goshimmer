<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Markers - IOTA GoShimmer</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../goshimmer.html"><strong aria-hidden="true">1.</strong> GoShimmer</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">2.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="../tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/setup.html"><strong aria-hidden="true">3.1.</strong> Set up a node</a></li><li class="chapter-item expanded "><a href="../tutorials/request_funds.html"><strong aria-hidden="true">3.2.</strong> Obtain tokens</a></li><li class="chapter-item expanded "><a href="../tutorials/wallet.html"><strong aria-hidden="true">3.3.</strong> Wallet library</a></li><li class="chapter-item expanded "><a href="../tutorials/dApp.html"><strong aria-hidden="true">3.4.</strong> Write a dApp</a></li><li class="chapter-item expanded "><a href="../tutorials/manual_peering.html"><strong aria-hidden="true">3.5.</strong> Manual peering</a></li><li class="chapter-item expanded "><a href="../tutorials/static_identity.html"><strong aria-hidden="true">3.6.</strong> Create a static identity</a></li><li class="chapter-item expanded "><a href="../tutorials/custom_dRNG.html"><strong aria-hidden="true">3.7.</strong> Set up a custom dRNG committee</a></li><li class="chapter-item expanded "><a href="../tutorials/monitoring.html"><strong aria-hidden="true">3.8.</strong> Set up the Monitoring Dashboard</a></li><li class="chapter-item expanded "><a href="../tutorials/send_transaction.html"><strong aria-hidden="true">3.9.</strong> How to create and send transactions</a></li></ol></li><li class="chapter-item expanded "><a href="../implementation_design.html"><strong aria-hidden="true">4.</strong> Implementation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../implementation_design/event_driven_model.html"><strong aria-hidden="true">4.1.</strong> Event driven model</a></li><li class="chapter-item expanded "><a href="../implementation_design/packages_plugins.html"><strong aria-hidden="true">4.2.</strong> Packages and plugins</a></li><li class="chapter-item expanded "><a href="../implementation_design/plugin.html"><strong aria-hidden="true">4.3.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="../implementation_design/configuration_parameters.html"><strong aria-hidden="true">4.4.</strong> Configuration parameters</a></li><li class="chapter-item expanded "><a href="../implementation_design/object_storage.html"><strong aria-hidden="true">4.5.</strong> Object storage</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol_specification.html"><strong aria-hidden="true">5.</strong> Protocol specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol_specification/protocol.html"><strong aria-hidden="true">5.1.</strong> Protocol high level overview</a></li><li class="chapter-item expanded "><a href="../protocol_specification/components.html"><strong aria-hidden="true">5.2.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol_specification/tangle.html"><strong aria-hidden="true">5.2.1.</strong> Tangle</a></li><li class="chapter-item expanded "><a href="../protocol_specification/autopeering.html"><strong aria-hidden="true">5.2.2.</strong> Autopeering</a></li><li class="chapter-item expanded "><a href="../protocol_specification/mana.html"><strong aria-hidden="true">5.2.3.</strong> Mana</a></li><li class="chapter-item expanded "><a href="../protocol_specification/congestion_control.html"><strong aria-hidden="true">5.2.4.</strong> Congestion Control</a></li><li class="chapter-item expanded "><a href="../protocol_specification/consensus_mechanism.html"><strong aria-hidden="true">5.2.5.</strong> Consensus mechanism</a></li><li class="chapter-item expanded "><a href="../protocol_specification/ledgerstate.html"><strong aria-hidden="true">5.2.6.</strong> UTXO and Ledgerstate</a></li><li class="chapter-item expanded "><a href="../protocol_specification/advanced_outputs.html"><strong aria-hidden="true">5.2.7.</strong> Advanced Outputs (Experimental)</a></li><li class="chapter-item expanded "><a href="../protocol_specification/markers.html" class="active"><strong aria-hidden="true">5.2.8.</strong> Markers</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol_specification/glossary.html"><strong aria-hidden="true">5.3.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="../api.html"><strong aria-hidden="true">6.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../apis/api.html"><strong aria-hidden="true">6.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="../apis/webAPI.html"><strong aria-hidden="true">6.2.</strong> WebAPI</a></li><li class="chapter-item expanded "><a href="../apis/info.html"><strong aria-hidden="true">6.3.</strong> Node info</a></li><li class="chapter-item expanded "><a href="../apis/autopeering.html"><strong aria-hidden="true">6.4.</strong> Autopeering</a></li><li class="chapter-item expanded "><a href="../apis/manual_peering.html"><strong aria-hidden="true">6.5.</strong> Manual peering</a></li><li class="chapter-item expanded "><a href="../apis/communication.html"><strong aria-hidden="true">6.6.</strong> Communication layer</a></li><li class="chapter-item expanded "><a href="../apis/ledgerstate.html"><strong aria-hidden="true">6.7.</strong> Ledgerstate</a></li><li class="chapter-item expanded "><a href="../apis/mana.html"><strong aria-hidden="true">6.8.</strong> Mana</a></li><li class="chapter-item expanded "><a href="../apis/dRNG.html"><strong aria-hidden="true">6.9.</strong> dRNG</a></li><li class="chapter-item expanded "><a href="../apis/snapshot.html"><strong aria-hidden="true">6.10.</strong> Snapshot</a></li><li class="chapter-item expanded "><a href="../apis/faucet.html"><strong aria-hidden="true">6.11.</strong> Faucet</a></li><li class="chapter-item expanded "><a href="../apis/spammer.html"><strong aria-hidden="true">6.12.</strong> Spammer</a></li><li class="chapter-item expanded "><a href="../apis/tools.html"><strong aria-hidden="true">6.13.</strong> Tools</a></li></ol></li><li class="chapter-item expanded "><a href="../tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tooling/docker_private_network.html"><strong aria-hidden="true">7.1.</strong> Docker private network</a></li><li class="chapter-item expanded "><a href="../tooling/integration_tests.html"><strong aria-hidden="true">7.2.</strong> Integration tests</a></li></ol></li><li class="chapter-item expanded "><a href="../team_resources.html"><strong aria-hidden="true">8.</strong> Team Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../teamresources/release.html"><strong aria-hidden="true">8.1.</strong> How to do a release</a></li><li class="chapter-item expanded "><a href="../teamresources/guidelines.html"><strong aria-hidden="true">8.2.</strong> Code Guidelines</a></li><li class="chapter-item expanded "><a href="../teamresources/local_development.html"><strong aria-hidden="true">8.3.</strong> Local development</a></li><li class="chapter-item expanded "><a href="../teamresources/analysis_dashboard.html"><strong aria-hidden="true">8.4.</strong> Modify the Analysis dashboard</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">IOTA GoShimmer</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/iotaledger/goshimmer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="markers"><a class="header" href="#markers">Markers</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In order to know whether a message in the Tangle is orphaned or not, we introduce <strong>grades of finality</strong> to interpret the status of a message. The higher grade of finality is determined by the <strong>approval weight</strong>, which is the proportion of active consensus mana approving a given message.</p>
<p>To compute the approval weight of a given message we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. The <strong>marker</strong> tool is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle that needs to be traversed, and which finally results in the grade of finality.</p>
<p><strong>Note</strong>: <em>Markers</em> is not a core module of the Coordicide project.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p><em>Markers</em> is a tool to infer knowledge about the structure of the Tangle in terms of:
+ past/future cone membership;
+ approximate approval weight of any message;
+ tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.</p>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Active Consensus Mana</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Let's define the terms related to markers:</p>
<ul>
<li><strong>Sequence:</strong> A Sequence is a sequence of markers. Each Sequence corresponds to a UTXO branch, which help us to track the structure independently. </li>
<li><strong>Sequence Identifier (<code>SID</code>):</strong> A Sequence Identifier is the unique identifier of a Sequence.</li>
<li><strong>Marker Index (<code>MI</code>):</strong> A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index. </li>
<li><strong>marker:</strong> A marker is a pair of numbers: <code>SID</code> and <code>MI</code> associated to a given message. Markers carrying the same <code>SID</code> belong to the same Sequence.</li>
<li><strong>future marker (<code>FM</code>):</strong> A future marker of a message is the first marker in its future cone from different sequences; this field in the message metadata is updated when the new marker is generated in the future, following the rules defined in <a href="#future-markers">Future Markers</a>.</li>
<li><strong>past marker (<code>PM</code>):</strong> A past marker of a message is a marker in its past cone. For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest <code>MI</code>. The past marker of a marker is set to itself.</li>
<li><strong>sequence rank:</strong> The rank of a sequence will be simply called rank throughout this code. Bear in mind that for clarity the marker rank is called index.</li>
</ul>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="the-markers"><a class="header" href="#the-markers">The Markers</a></h3>
<p>Markers are messages selected from the tip set periodically and assigned unique identifiers, in the form of $[SID, MI]$. </p>
<h4 id="marker-structure"><a class="header" href="#marker-structure">Marker Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>SequenceID</td>
        <td>uint64</td>
        <td>The Sequence identifier of the marker.</td>
    </tr>
    <tr>
        <td>Index</td>
        <td>uint64</td>
        <td>The index of the marker in the sequence.</td>
    </tr>
</table>
<h4 id="create-markers"><a class="header" href="#create-markers">Create Markers</a></h4>
<p>A new marker is created when:</p>
<ol>
<li>the default conditions are met, which will be one of these options:
<ul>
<li><strong>every x messsages</strong>;</li>
</ul>
<ul>
<li><strong>every t seconds</strong>;</li>
<li>a mix of the first two!
<ul>
<li>Upperbound given by the messages</li>
<li>Lower temporal bound given by the time</li>
</ul>
</li>
<li>every x messages that reference (directly or indirectly) the previous marker
<ul>
<li>Lower bound given by rank (e.g., how far you are in terms of steps) -&gt; &gt;= 10 or something</li>
<li>Upper bound given by the amount of messages referencing the previous one -&gt; ~ 200 msgs</li>
</ul>
</li>
</ul>
</li>
<li>A new sequence is created. </li>
</ol>
<blockquote>
<p>:mega: to be confirmed here.</p>
</blockquote>
<p>A new marker is selected from the strong tips set randomly, and selected from the weak tips set if there's no strong tip. A new pair of $[SID, MI]$ is assigned to the new marker. </p>
<blockquote>
<p>:mega:  to be confirmed here.</p>
</blockquote>
<p>The <code>SID</code> is set according to the following rules:</p>
<ul>
<li>Inherit the <code>SID</code> from parents if the new marker references the latest marker of a sequence and meets the requirement to set up a new marker without initiating a new MS.</li>
<li>Create a new <code>SID</code> if it is the first marker of a new sequence.</li>
</ul>
<p>The <code>MI</code> is set to $MI = 1+ max(referencedMI)$, which complies to the rule:</p>
<ul>
<li>Marker indexes (<code>MI</code>s) are monotonically increasing such that $\forall x \in fc(y)$ =&gt; $MI_x &gt; MI_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.</li>
</ul>
<h3 id="markers-in-messages"><a class="header" href="#markers-in-messages">Markers in Messages</a></h3>
<p>Each message keeps its associated marker information in two lists:</p>
<ul>
<li>past markers </li>
<li>future markers </li>
</ul>
<p>These lists for past markers and future markers are used to determine whether a message is in the past cone of the other, and the list for future markers also helps us to efficiently estimate the approval weight of a message.</p>
<h4 id="structuredetails-structure"><a class="header" href="#structuredetails-structure">StructureDetails Structure</a></h4>
<p>StructureDetails is a structure that will be in the message metadata containing marker information.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rank</td>
        <td>uint64</td>
        <td>The rank of the message.</td>
    </tr>
    <tr>
        <td>IsPastMarker</td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td>PastMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>PM list</b>, a list of PMs from different sequences.</td>
    </tr>
    <tr>
        <td>FutureMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>FM list</b>, a list of FMs from different sequences.</td>     
    </tr>
</table>
<h5 id="past-markers"><a class="header" href="#past-markers">Past Markers</a></h5>
<ul>
<li>The <code>PM</code> list of a marker contains the marker itself only.</li>
<li>The <code>PM</code> list of non-marker messages is inherited from its <strong>strong</strong> parents, with 2 steps:
<ol>
<li>for a given sequence select only the nearest marker (i.e. the markers with the highest <code>MI</code>). Thus for every sequence from the parents there will be exactly one marker.</li>
<li>remove those that have been referenced by other markers from this set. </li>
</ol>
</li>
</ul>
<h5 id="future-markers"><a class="header" href="#future-markers">Future Markers</a></h5>
<p>The <code>FM</code> list of a message is empty at start and gets updated when a new marker directly or indirectly references it. The propagation of a <code>FM</code> to its past cone (i.e. the update of the <code>FutureMarkers</code> field in the encountered messages) does not continue beyond a message if:</p>
<ol>
<li>the <code>FM</code> list of a message includes a previous marker of the same sequence;</li>
<li>the message is the marker in the different sequence, we update the <code>FM</code> list of that marker only.</li>
</ol>
<h3 id="the-sequence"><a class="header" href="#the-sequence">The Sequence</a></h3>
<p>Sequences are used to track the UTXO DAG branches, each branch corresponds to a sequence with a unique <code>SID</code>, and the sequences form a DAG as well.</p>
<h4 id="sequence-structure"><a class="header" href="#sequence-structure">Sequence Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>id</td>
        <td>uint64</td>
        <td>The sequence identifier of the sequence.</td>
    </tr>
    <tr>
        <td>parentReferences</td>
        <td>map[uint64]Thresholdmap</td>
        <td>The marker referenced map of each parent marker.</td>
    </tr>
    <tr>
        <td>rank</td>
        <td>uint64</td>
        <td>The rank of the sequence in the marker DAG.</td>
    </tr>
    <tr>
        <td>highestIndex</td>
        <td>uint64</td>
        <td>The highest MI of the marker sequence.</td>
    </tr>
    <tr>
        <td>lowestIndex</td>
        <td>uint64</td>
        <td>The lowest MI of the sequence.</td>
    </tr>
</table>
<h4 id="create-sequence"><a class="header" href="#create-sequence">Create Sequence</a></h4>
<p>A new sequence is created when:</p>
<ol>
<li>there's a conflict in a UTXO branch.</li>
<li>the UTXO branches are aggregated.</li>
<li>UTXO branches are merged.</li>
</ol>
<p>Each new sequence starts from a new marker.</p>
<h4 id="sequences"><a class="header" href="#sequences">Sequences</a></h4>
<p>For whatever reason a sequence is created, we assign a new $SID = 1+max(referenceSequencesIdentifiers)$. To prevent assigning a new <code>SID</code> when combining same sequences again, we build parents-child relation in a map if a new sequence is created. </p>
<h4 id="sequence-rank"><a class="header" href="#sequence-rank">Sequence Rank</a></h4>
<p>The rank of a sequence graph is the number of sequences from the starting point to itself. The sequence ranks are shown in the figure above.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>Here is an example of how the markers and sequences structures would look in the Tangle:
The purple colored messages are markers.</p>
<p><img src="https://i.imgur.com/GENej3O.png" alt="" /></p>
<h2 id="example-2-test-for-the-mapping-interaction-with-the-booker"><a class="header" href="#example-2-test-for-the-mapping-interaction-with-the-booker">Example 2: Test for the Mapping interaction with the Booker</a></h2>
<p>The Marker tool implementation is tested for correct Marker and Booker mapping. A transaction-by-transaction discussion of the test can be found <a href="https://github.com/iotaledger/goshimmer/blob/develop/packages/tangle/images/TestBookerMarkerMappings.md">here</a> and can be viewed by opening the file locally in a browser. Transactions arrive in the order of the their transaction number. The end result and the values in the various fields is shown in the following figures:</p>
<p><img src="https://imgur.com/h6Hs3xG.png" alt="" /></p>
<p><img src="https://imgur.com/sCkXXrG.png" alt="" /></p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>In the following we describe some of the functions in more detail.</p>
<h3 id="normalization-of-the-referenced-pms-and-sequences"><a class="header" href="#normalization-of-the-referenced-pms-and-sequences">Normalization of the referenced PMs and Sequences</a></h3>
<p>Messages can have markers from different sequences in <code>PM</code> list and <code>FM</code> list, the order and referenced relationship among sequences are important for example when it comes to inheriting the <code>PM</code> list from parents. Thus, we need to track these sequences.</p>
<p>When a new sequence is created we check the parent marker' sequences with the function <code>normalizeMarkers()</code> in order from high to low rank. In this function, we remove those <code>PM</code>s that it's belonging sequence is referenced by others.</p>
<p>An example is <strong>msg 10</strong> in the figure above, $[0,2], [1,1], [2,3]$ are <code>PM</code>s to be considered to inherit. $[2,3]$ is the first marker to check, since it has the highest sequence rank. We select the parent sequences of $[2,3]$, which are $0$ and $1$, and the referenced <code>PM</code>s therein. Next any <code>PM</code>s that are already referenced can be removed. This results in that the PMs of <strong>msg 10</strong> is $[2,3]$ only.</p>
<p>In the following we show the implementation of  <code>normalizeMarkers()</code>, which returns the markers and sequences that will be inherited from a message.</p>
<pre><code class="language-go">// normalizeMarkers takes a set of Markers and removes each Marker that is already referenced by another Marker in the
// same set (the remaining Markers are the &quot;most special&quot; Markers that reference all Markers in the set grouped by the
// rank of their corresponding Sequence). In addition, the method returns all SequenceIDs of the Markers that were not
// referenced by any of the Markers (the tips of the Sequence DAG).
func (m *Manager) normalizeMarkers(markers *Markers) (normalizedMarkersByRank *markersByRank, normalizedSequences SequenceIDs) {
	rankOfSequencesCache := make(map[SequenceID]uint64)

	normalizedMarkersByRank = newMarkersByRank()
	normalizedSequences = make(SequenceIDs)
	// group markers with same sequence rank
	markers.ForEach(func(sequenceID SequenceID, index Index) bool {
		normalizedSequences[sequenceID] = types.Void
		normalizedMarkersByRank.Add(m.rankOfSequence(sequenceID, rankOfSequencesCache), sequenceID, index)

		return true
	})
	markersToIterate := normalizedMarkersByRank.Clone()

	//iterate from highest sequence rank to lowest
	for i := markersToIterate.HighestRank() + 1; i &gt; normalizedMarkersByRank.LowestRank(); i-- {
		currentRank := i - 1
		markersByRank, rankExists := markersToIterate.Markers(currentRank)
		if !rankExists {
			continue
		}

		// for each marker from the current sequence rank check if we can remove a marker in normalizedMarkersByRank,
		// and add the parent markers to markersToIterate if necessary
		if !markersByRank.ForEach(func(sequenceID SequenceID, index Index) bool {
			if currentRank &lt;= normalizedMarkersByRank.LowestRank() {
				return false
			}

			if !(&amp;CachedSequence{CachedObject: m.sequenceStore.Load(sequenceID.Bytes())}).Consume(func(sequence *Sequence) {
				// for each of the parentMarkers of this particular index
				sequence.HighestReferencedParentMarkers(index).ForEach(func(referencedSequenceID SequenceID, referencedIndex Index) bool {
					// of this marker delete the referenced sequences since they are no sequence tips anymore in the sequence DAG
					delete(normalizedSequences, referencedSequenceID)

					rankOfReferencedSequence := m.rankOfSequence(referencedSequenceID, rankOfSequencesCache)
					// check whether there is a marker in normalizedMarkersByRank that is from the same sequence
					if index, indexExists := normalizedMarkersByRank.Index(rankOfReferencedSequence, referencedSequenceID); indexExists {
						if referencedIndex &gt;= index {
							// this referencedParentMarker is from the same sequence as a marker in the list but with higher index - hence remove the index from the Marker list
							normalizedMarkersByRank.Delete(rankOfReferencedSequence, referencedSequenceID)

							// if rankOfReferencedSequence is already the lowest rank of the original markers list,
							// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
							if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
								markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
							}
						}

						return true
					}

					// if rankOfReferencedSequence is already the lowest rank of the original markers list,
					// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
					if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
						markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
					}

					return true
				})
			}) {
				panic(fmt.Sprintf(&quot;failed to load Sequence with %s&quot;, sequenceID))
			}

			return true
		}) {
			return
		}
	}

	return
}
</code></pre>
<h3 id="markers-application-past-cone-check"><a class="header" href="#markers-application-past-cone-check">Markers Application: Past Cone Check</a></h3>
<p>By comparing the past and future markers of messages, we can easily tell if one is in another's past cone. The function returns a <code>TriBool</code> representing the three possible statuses: <code>True</code>, <code>False</code> and <code>Maybe</code>. If <code>Maybe</code> is returned, then we need to perform a search of the Tangle by walking by means of e.g. a Breadth-First Search.</p>
<p>In the following we show the implementation of the past cone check: </p>
<pre><code class="language-go">// IsInPastCone checks if the earlier Markers are directly or indirectly referenced by the later Markers.
func (m *Manager) IsInPastCone(earlierMarkers *MarkersPair, laterMarkers *MarkersPair) (referenced TriBool) {
	// fast check: if earlier Markers have larger highest Indexes they can't be in the past cone
	if earlierMarkers.PastMarkers.HighestIndex() &gt; laterMarkers.PastMarkers.HighestIndex() {
		return False
	}

	// fast check: if earlier Marker is a past Marker and the later ones reference it we can return early
	if earlierMarkers.IsPastMarker {
		earlierMarker := earlierMarkers.PastMarkers.FirstMarker()
		if earlierMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		if laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(earlierMarker.sequenceID); sequenceExists {
			if laterIndex &gt;= earlierMarker.index {
				return True
			}

			return False
		}

		if laterMarkers.PastMarkers.HighestIndex() &lt;= earlierMarker.index {
			return False
		}
	}

	if laterMarkers.IsPastMarker {
		laterMarker := laterMarkers.PastMarkers.FirstMarker()
		if laterMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		// if the earlier Marker inherited an Index of the same Sequence that is higher than the later we return false
		if earlierIndex, sequenceExists := earlierMarkers.PastMarkers.Get(laterMarker.sequenceID); sequenceExists &amp;&amp; earlierIndex &gt;= laterMarker.index {
			return False
		}

		// if the earlier Markers are referenced by a Marker of the same Sequence that is larger, we are not in the past cone
		if earlierFutureIndex, earlierFutureIndexExists := earlierMarkers.FutureMarkers.Get(laterMarker.sequenceID); earlierFutureIndexExists &amp;&amp; earlierFutureIndex &gt; laterMarker.index {
			return False
		}

		// if the earlier Markers were referenced by the same or a higher future Marker we are not in the past cone
		// (otherwise we would be the future marker)
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			earlierIndex, similarSequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
			return !similarSequenceExists || earlierIndex &lt; laterIndex
		}) {
			return False
		}

		if earlierMarkers.PastMarkers.HighestIndex() &gt;= laterMarker.index {
			return False
		}
	}

	// if the highest Indexes of both past Markers are the same ...
	if earlierMarkers.PastMarkers.HighestIndex() == laterMarkers.PastMarkers.HighestIndex() {
		// ... then the later Markers should contain exact copies of all of the highest earlier Markers because parent
		// Markers get inherited and if they would have been captured by a new Marker in between then the highest
		// Indexes would no longer be the same
		if !earlierMarkers.PastMarkers.ForEach(func(sequenceID SequenceID, earlierIndex Index) bool {
			if earlierIndex == earlierMarkers.PastMarkers.HighestIndex() {
				laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; laterIndex != earlierIndex
			}

			return true
		}) {
			return False
		}
	}

	if earlierMarkers.FutureMarkers.HighestIndex() == laterMarkers.FutureMarkers.HighestIndex() &amp;&amp; false {
		// the earlier future markers need to contain all later ones because if there would be another marker in between that shadows them the later future Marker would have a higher index
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			if laterIndex == laterMarkers.FutureMarkers.highestIndex {
				earlierIndex, sequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; earlierIndex == laterIndex
			}

			return true
		}) {
			return False
		}
	}

	// detailed check: earlier marker is referenced by something that the later one references
	if m.markersReferenceMarkers(laterMarkers.PastMarkers, earlierMarkers.FutureMarkers, false) {
		return True
	}

	// detailed check: the
	if m.markersReferenceMarkers(earlierMarkers.FutureMarkers, laterMarkers.PastMarkers, true) {
		return Maybe
	}

	return False
}

</code></pre>
<h3 id="markers-application-approval-weight-estimation"><a class="header" href="#markers-application-approval-weight-estimation">Markers Application: Approval Weight Estimation</a></h3>
<p>To approximate the approval weight of a message, we simply retrieve the approval weight of its <code>FM</code> list. Since the message is in the past cone of its <code>FM</code>s, the approval weight and the finality will be at least the same as its <code>FM</code>s. This will of course be a lower bound (which is the “safe” bound), but if the markers are set frequently enough, it should be a good approximation.</p>
<p>For details of managing approval weight of each marker and approval weight calculation thereof please refer to <a href="./consensus_mechanism.html#approval-weight-aw">Approval Weight</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../protocol_specification/advanced_outputs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../protocol_specification/glossary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../protocol_specification/advanced_outputs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../protocol_specification/glossary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
